Last Saturday (16/12/2023), Kaspa mining halted for about 20–30 minutes, and no new blocks were added to the BlockDAG due to a bug, which was subsequently fixed by the release of version v0.12.15. I delayed posting a post-mortem until 99% of the miners upgraded to the new version to prevent potential attackers from exploiting the situation. Now that this threshold has been reached (validated with Michael Sutton’s tool), here is a detailed explanation of the bug and how it was resolved.

In February, an Italian group working on implementing atomic swaps on Kaspa noticed an issue: even after formulating a perfect atomic swap transaction, their transaction could not be accepted into the mempool. They reached out to me for assistance, and after some investigation, I discovered the reason was a peculiar bug.

When a transaction is received from RPC, it is converted to an internal Golang type called DomainTransaction, which is then used for processing the transaction in the mempool or within the consensus layer as part of a block. There was a small bug that copied the content of one field, called lockTime, to the value of another field, called gas.

The bug can be seen in a snippet from kaspad v0.12.14. The lockTime field is related to implementing contracts where funds are locked for a certain period (for more information, you can refer to Andreas Antonopoulos’ explanation), and it is utilized by atomic swaps. The gas field is reserved for future integration of subnetworks in Kaspa, and since subnetworks support is not currently enabled, any valid transaction must set it to 0. For a typical transaction, the lockTime field is set to 0, so the bug simply copied its 0 value to the gas field, allowing the transaction to remain valid. However, in the case of atomic swap transactions, the lockTime field is set to a non-zero value, which is copied to the gas field, rendering the transaction invalid.

The solution for this was straightforward, but I wanted to wait for more feedback from the Italian group about my solution before publishing it. At the time, I believed the fix was not urgent since the function of locking funds was not available to non-developers, and if a developer attempted to use that function, the worst that could happen was that their transaction would be rejected.

I was mistaken. The bug fix was overlooked, and on December 16th, the consequences emerged. A new member of the Rust team, Maxim Biryukov, began experimenting with HTLC transactions. In one of his tests, he used a transaction with lockTime set to 1. To clarify, it was completely acceptable for Maxim to run this test, as such transactions were not anticipated to be problematic. Since Maxim used a Rusty-Kaspa node that was free of this bug, his transaction was accepted into his mempool without any issues. This transaction, which we will refer to as mtx (denoting "Maxim Transaction"), was then broadcast to the rest of the network in the P2P layer. Since the bug does not appear in the P2P code, all Golang nodes accepted the transaction into their mempool without any problems.

However, the situation became complicated. When any miner found a block, it included mtx (since it had not yet been mined). The miner then sent the block to their Golang node via RPC for propagation to the rest of the network. During the conversion of the RPC block transactions to DomainTransactions, the bug was triggered: the conversion code took mtx, and since mtx.lockTime was set to 1, it also set mtx.gas to 1. This change in the block transactions resulted in the Merkle root (the part of a block header that commits to the block content) becoming invalid, as it was built before mtx was altered. Since no blocks were mined, mtx remained in everyone’s mempool, and each block that was mined was invalid.

When pools reported receiving an ErrBadMerkleRoot error when submitting blocks, and I learned about Maxim’s tests, I connected the dots and released a new version with the fix.

To summarize:

1. Maxim creates mtx and sends it to his Rusty-Kaspa node (where mtx.lockTime=1 and mtx.gas=0).
2. Maxim’s node propagates mtx to the rest of the network, where it reaches the miners' nodes (still, mtx.lockTime=1 and mtx.gas=0).
3. When a miner solves a block b, they include mtx in it and send it to their Golang node via RPC.
4. When converting the RPC transactions of b to DomainTransactions, the miner node sets mtx.gas=mtx.lockTime=1. When the block is validated, it throws an ErrBadMerkleRoot error, and the block is rejected.
5. This results in no mining until the fix is released.

Conclusion: This case teaches us several lessons. Even when the consensus layer is well tested with nearly 100% coverage, a bug in communication between components (in this case, the bridge between the RPC layer and the consensus layer) can lead to significant issues. To prevent this, more integration tests involving multiple components should be developed. Additionally, even with perfect testing conventions, no system is immune to bugs, and we need to consider better ways to handle them when they occur. For example, I discussed this case with Yonatan Sompolinsky, and we are considering implementing a fallback mechanism that will mine empty blocks in the event of such bugs, which will help secure the network during extreme situations. More on that will follow in the future.