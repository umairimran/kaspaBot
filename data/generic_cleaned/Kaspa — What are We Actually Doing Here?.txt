It is astonishing to see how fast the Kaspa community is growing. However, as Kaspa gains more traction and popularity, it becomes clear that many people do not fully understand what Kaspa actually is. This is not their fault, as the core technology behind Kaspa has not been explained in an accessible manner. While information exists in technical papers and conference talks, these resources are not written with the common user in mind. The goal of this text is to rectify this.

Kaspa is a broad term that describes a complicated system with many components and aspects. At its core, Kaspa is an implementation of the GHOSTDAG protocol, which was first conceptualized by Yonatan Sompolinsky and Aviv Zohar in 2016. The following content is dedicated to describing this particular aspect of Kaspa.

Cryptocurrencies are often very complicated, and many users tend to forgo fully understanding the promise of one coin or another, which is acceptable. However, the true power of GHOSTDAG lies in its simplicity: GHOSTDAG is a gentle generalization of Nakamoto consensus. Unlike many coins, anyone who understands Bitcoin can easily grasp GHOSTDAG, what it achieves, and how it achieves it.

GHOSTDAG offers a simple, albeit challenging to implement, solution to the core scaling issue present in Nakamoto consensus (i.e., in any Proof of Work (PoW) based blockchain). It has the potential to replace Bitcoin and Ethereum as the layer one framework capable of supporting a decentralized global-scale economy. With this goal in mind, Kaspa is planned to provide tools that will facilitate the development of layer two applications.

This text assumes basic familiarity with Nakamoto consensus (e.g., with Bitcoin). The uninitiated can fill in the gaps with available educational resources.

The Nakamoto Consensus Scaling Problem

Bitcoin and other blockchains claim to provide 51% security. This means that as long as most of the hashes in the network are created by honest miners, the network is protected from adversaries who wish to revert arbitrarily old transactions. However, this claim is only approximately true, and this issue is at the crux of all blockchain scaling challenges.

Imagine an adversary who wishes to revert a transaction that took place 10 blocks ago. Suppose the adversary has been preparing to do so since the block was created. Bitcoin operates on a longest chain rule (technically, it works on a heaviest chain rule, but this detail is simplified for clarity). To convince the network to switch to a different chain where this transaction never occurred, the adversary must create a longer alternative chain faster than the honest network. If the adversary has less computational power than the rest of the network, the probability of successfully mining, for example, 12 blocks before the honest network does is exceedingly small.

The crux of the issue arises from the fact that honest network blocks are not always arranged in a single chain. Occasionally, two honest miners will create blocks at approximately the same time, leading to competition between these blocks until one is discarded. Such discarded blocks are often referred to as orphan blocks, and conservative estimates suggest that at least one in every 150 Bitcoin blocks is orphaned.

This means that to revert a transaction, the attacker only needs to create slightly fewer blocks than the honest network: for every 150 honest blocks, the attacker needs to create more than 149 blocks, which can be achieved with 49.9% of the global hash rate.

While this may not seem significant, there is little difference between a 50.1% attacker and a 49.9% attacker. The problem arises when attempting to upscale the throughput of the network (by increasing either the block rate or the block size), which inevitably increases the orphan rate and decreases the security of the network.

The security of any blockchain relies on the fact that the delay between blocks is significantly larger than the time it takes for the entire network to learn of a new block. Parallel blocks are orphaned, which decreases the growth rate of the honest chain. Overcoming this throughput/security tradeoff is the main motivation behind the GHOSTDAG protocol.

How Can We Allow Parallel Blocks?

The core idea of GHOSTDAG is straightforward: instead of having any block point to a single parent block, allow it to point to multiple parent blocks, thus giving the blocks in the network the structure of a Directed Acyclic Graph (DAG) rather than a chain.

A natural question arises: what about double spends? If we allow two parallel blocks to coexist, how do we handle the possibility that they contain conflicting transactions?

The solution being developed involves choosing an ordering of the blocks. This means taking the DAG structure and arranging it in a chain. We then traverse the chain and include all transactions that do not contradict previous transactions.

Choosing this ordering is crucial, as it can make or break a blockDAG. The GHOSTDAG (and its computationally unfeasible precursor, PHANTOM) protocols are essentially methods to order blocks in a DAG.

Some properties expected of a good ordering include:

1. **Topological**: A block cannot appear in the ordering before any of its parent blocks.
2. **Consensus**: At any point in time, all nodes in the network must agree on the ordering of all but a constant number of new blocks.
3. **Security**: A computationally inferior adversary cannot retroactively revert the ordering of blocks.
4. **Liveness**: There should be a clear criterion for when a block is “finalized,” meaning it will never change its position in the ordering, and every block should meet this criterion within a constant amount of time.
5. **Efficiency**: The problem of determining, calculating, and maintaining the order should be feasible for today’s computers, even as the DAG grows.

An ordering with these properties could provide a solution to the scaling problem of traditional blockchains by removing the need for a large block delay. Indeed, the GHOSTDAG protocol is provably secure regardless of the ratio between block delay and block round trip time, which is the central promise of GHOSTDAG.

For a more detailed account of how orphaned blocks affect Bitcoin security, further reading is recommended.

PHANTOM — GHOSTDAG In an Ideal World

Before delving into GHOSTDAG, it is instructive to consider a scenario where efficiency is not a concern. In this hypothetical world, we assume that any combinatorial calculations, even NP-complete ones, are feasible (while still assuming the existence of a hard-to-invert hash function, or else the entire PoW paradigm collapses). In such a world, how would one design a good ordering of the blocks?

The core idea is that the honest network blocks should be well connected. Since all honest miners communicate with each other and do not withhold blocks, their honest work should form a well-connected DAG. An attacker working on a side chain would appear disconnected from the main chain.

Translating this imprecise idea into an actual algorithm involves the mathematical notion of a k-cluster.

Given a block B, its past is the set of blocks reachable from B. Similarly, its future is the set of all blocks that can reach B (equivalently, the set of all blocks that have B in their past). The remaining blocks are called B’s anticone.

A k-cluster in a DAG is a subset with the property that no block in the subset has an anticone larger than k (when only counting blocks within this subset). A k-cluster is maximal if there are no larger k-clusters.

With this concept in hand, we can describe the PHANTOM ordering almost formally:

1. Choose k such that, most of the time, the honest network does not create more than k+1 parallel blocks.
2. Find a maximal k-cluster (arbitrarily break ties if there are multiple maximal k-clusters).
3. Order the blocks in the maximal k-cluster via an arbitrary topological order with the property that a block outside the chosen k-cluster will appear as late as possible, either after all blocks inside the k-cluster or when the ordering reaches a block in the k-cluster that has this block in its past.

Some details are simplified here, such as the meaning of “most of the time” and how the honest network occasionally creating more than k parallel blocks affects the security of the protocol. These details are thoroughly discussed in the relevant literature.

Notably, this approach is a direct generalization of Nakamoto consensus. If we choose k=0 and discard blocks outside the maximal k-cluster, we are left with the longest chain.

From PHANTOM to GHOSTDAG

There are two issues with the PHANTOM protocol as presented:

1. It could not be implemented efficiently: The problem of finding a maximal k-cluster in a given DAG is NP-complete.
2. It is not incremental: Every time the DAG updates, the entire computation must be restarted, requiring the storage of the entire DAG structure.

GHOSTDAG is a greedy variant of PHANTOM that addresses both issues. The idea is that the (now approximate) k-cluster is maintained incrementally. Each block has a number called its blue score, which indicates how many blocks in its past are in the k-cluster. Given a particular block, its selected parent is the parent with the highest blue score. When a new block is created, it does not need to calculate the entire k-cluster. Instead, it inherits most of the k-cluster from its selected parent, with the remainder chosen from the anticone of the selected parent. However, since this is a k-cluster, at most k elements from this set can be included.

This means that any block should only track at most k additional blocks: those in its blue past (the k-cluster from that block's perspective) but not in the blue past of its selected parent.

From this perspective, the generalization of Nakamoto consensus is clearer: choosing k=0, the blue score represents the length of the longest chain, and the selected chain (the chain starting from the block with the highest blue score and traversing the selected parents) is the original Nakamoto chain.

For a more detailed account of GHOSTDAG, further reading is recommended.

Why Should GHOSTDAG Be Secure?

One might hope that the security of GHOSTDAG would be directly implied by the security of Nakamoto consensus. However, additional steps are necessary.

Allowing parallel blocks and multiple parents creates a phenomenon called freeloading, which does not exist in Bitcoin. Freeloading occurs when an attacker allows their blocks to point to honest blocks to increase their own blue score. This enables an attacker to leverage the work done by the honest network to boost the score of their own chain, raising questions about why this capacity does not imply that they could rearrange the block structure without creating as many blocks as the honest network.

Fortunately, the GHOSTDAG ordering has a special property known as the freeloading bound (which appears as Lemma 12 in the relevant literature). This property essentially means that an attacker wishing to revert arbitrarily old blocks cannot use honest blocks in a meaningful way. The number of blocks they could freeload from is limited by a constant (specifically, 4k blocks). Consequently, any attack seeking to change the ordering of arbitrarily old blocks will soon encounter a race where freeloading does not provide any advantage. With careful argumentation, this can be used to reduce the security of GHOSTDAG to the security of Bitcoin.

Following this reasoning, we can prove the security property of GHOSTDAG: a computationally inferior attacker cannot revert arbitrarily old blocks, regardless of the ratio between block delay and block propagation time.

In summary, GHOSTDAG achieves the same security as Bitcoin but without constraints on the block rate, alleviating the blockchain scaling problem. It also offers nearly immediate confirmation times (on the order of seconds).

From GHOSTDAG to Kaspa — Concluding Remarks

While GHOSTDAG is an intriguing protocol, implementing it presents its own challenges. Describing Kaspa as a straightforward implementation of GHOSTDAG would be a significant understatement. In practice, many engineering and theoretical challenges had to be addressed before a usable implementation was achieved (for example, it is non-trivial to implement an efficient method to determine whether two blocks are in each other's anticones).

Additionally, Kaspa includes many other aspects not discussed in the original paper, such as a novel approach to difficulty adjustment, a sophisticated pruning mechanism, and future plans for infrastructure supporting layer two applications.

Kaspa still has a long way to go. For instance, it has not yet been stress-tested to determine how many transactions it can handle (though it has supported 40 transactions per second, which exceeds the theoretical limit of Bitcoin and Ethereum combined, without difficulty).

The future remains uncertain, but there is a non-negligible chance that Kaspa may become the most resilient, robust, and fast PoW blockchain (or rather, blockDAG) in the world.