It is astonishing to see how fast the Kaspa community is growing. However, as Kaspa gains more traction and popularity, it becomes clear that many people do not fully understand what Kaspa actually is. This is not their fault, as the core technology behind Kaspa has not been explained in an accessible manner. While the information exists in technical papers and conference talks, these are not written with the common user in mind. The goal here is to rectify this.

Kaspa is a broad term that describes a complicated system with many components and aspects. At its core, Kaspa is an implementation of the GHOSTDAG protocol, which was first conceptualized by Yonatan Sompolinsky and Aviv Zohar in 2016. The following content is dedicated to describing this particular aspect of Kaspa.

Cryptocurrencies can be very complicated, and many users tend to forgo fully understanding the promise of one coin or another, which is acceptable. However, the true power of GHOSTDAG lies in its simplicity: GHOSTDAG is a gentle generalization of Nakamoto consensus. Unlike many coins, anyone who understands Bitcoin can easily grasp GHOSTDAG, what it achieves, and how it achieves it.

Furthermore, GHOSTDAG offers a simple, albeit challenging to implement, solution to the core scaling issue present in Nakamoto consensus (i.e., in any Proof of Work (PoW) based blockchain). It has the potential to replace Bitcoin and Ethereum as the layer one framework capable of supporting a decentralized global-scale economy. With this goal in mind, Kaspa is planned to provide tools that will facilitate the development of layer two applications.

This discussion assumes basic familiarity with Nakamoto consensus (e.g., with Bitcoin). The uninitiated can fill in the gaps with available resources.

The Nakamoto Consensus Scaling Problem

Bitcoin and other blockchains claim to provide 51% security. This means that as long as most of the hashes in the network are created by honest miners, the network is protected from adversaries who wish to revert arbitrarily old transactions. However, this is only approximately true, and this issue is at the crux of all blockchain scaling challenges.

Imagine an adversary who wishes to revert a transaction that took place 10 blocks ago. If the adversary has been preparing to do so since the block was created, they must create a longer alternative chain faster than the network. Bitcoin operates on a longest chain rule (technically, it works on a heaviest chain rule, but this detail is simplified for clarity). If the adversary has less computational power than the rest of the network, the probability of successfully mining, say, 12 blocks before the honest network does is extremely low.

The crux of the issue arises when honest network blocks are not always arranged in a single chain. Occasionally, two honest miners will create blocks at approximately the same time, leading to competition between these blocks until one is discarded. Such discarded blocks are often referred to as orphan blocks, and conservative estimates suggest that at least one in every 150 Bitcoin blocks is orphaned.

This means that to revert a transaction, the attacker only needs to create slightly fewer blocks than the honest network: for every 150 honest blocks, the attacker needs to create more than 149 blocks, which can be achieved with 49.9% of the global hash rate.

While this may not seem significant, there is little difference between a 50.1% attacker and a 49.9% attacker. The problem arises when attempting to increase the throughput of the network (by either increasing the block rate or the block size), which inevitably raises the orphan rate and decreases the network's security.

The security of any blockchain relies on the fact that the delay between blocks is significantly larger than the time it takes for the entire network to learn of a new block. Parallel blocks are orphaned, which decreases the growth rate of the honest chain. Overcoming this throughput/security tradeoff is the main motivation behind the GHOSTDAG protocol.

So How Can We Allow Parallel Blocks?

The core idea is straightforward: instead of having any block point to a single parent block, allow it to point to multiple parents, thus giving the blocks in the network the structure of a Directed Acyclic Graph (DAG) rather than a chain.

The first natural question about this approach is: what about double spends? If we allow two parallel blocks to coexist, how do we handle the possibility that they contain conflicting transactions?

The solution we are working towards is to choose an ordering of the blocks. We take the DAG structure and arrange it in a chain. We then traverse the chain and include all transactions that do not contradict previous transactions.

Choosing this ordering is crucial and can determine the success of a blockDAG. The GHOSTDAG (and its computationally unfeasible precursor PHANTOM) protocols are essentially methods to order blocks in a DAG.

Before delving into these protocols, let us outline some properties we expect from a good ordering:

1. It must be topological: a block cannot appear in the ordering before any of its parent blocks.
2. It must be in consensus: at any point in time, all nodes in the network must agree on the ordering of all but a constant number of new blocks.
3. It must be secure: a computationally inferior adversary cannot retroactively revert the ordering of blocks.
4. It must offer liveness: there should be a clear criterion for when a block is “finalized” in the sense that it will never change its place in the ordering, and every block should satisfy this criterion within a constant amount of time.
5. It must be efficient: determining, calculating, and maintaining the order should be feasible for today’s computers, even as the DAG grows.

An ordering with these properties could provide a solution to the scaling problem of traditional blockchains by removing the need for a large block delay. Indeed, the GHOSTDAG protocol is provably secure regardless of the ratio between block delay and block round trip time. This is the central promise of GHOSTDAG.

For a more detailed account of how orphaned blocks affect Bitcoin security, further reading is recommended.

PHANTOM — GHOSTDAG In an Ideal World

Before diving into GHOSTDAG, it is instructive to consider a scenario where efficiency is not a concern. In this ideal world, we assume that any combinatorial calculations, even NP-complete ones, are feasible (while still assuming the existence of a hard-to-invert hash function, or else the entire PoW paradigm collapses). In such a world, how would one design a good ordering of the blocks?

The core idea is that the honest network blocks should be well connected. Since all honest miners communicate with each other and do not withhold blocks, their honest work should form a well-connected DAG. An attacker working on a side chain would appear disconnected from the main chain.

Translating this imprecise idea into an actual algorithm involves the mathematical notion of a k-cluster.

Given a block B, its past is the set of blocks reachable from B. Similarly, its future is the set of all blocks that can reach B (equivalently, the set of all blocks that have B in their past). The remaining blocks are called B’s anticone.

A k-cluster in a DAG is a subset with the property that no block in the subset has an anticone larger than k (when only counting blocks within this subset). A k-cluster is maximal if there are no larger k-clusters.

With this concept in hand, we can describe the PHANTOM ordering almost formally:

1. Choose k such that most of the time, the honest network does not create more than k+1 parallel blocks.
2. Find a maximal k-cluster (choose an arbitrary tie-breaking rule if there are several maximal k-clusters).
3. Order the blocks in the maximal k-cluster via an arbitrary topological order with the property that a block outside the chosen k-cluster will appear as late as possible, either after all blocks inside the k-cluster or when the ordering reaches a block in the k-cluster that has this block in its past.

Some details are simplified here, such as what “most of the time” means and how the occasional creation of more than k parallel blocks affects the security of the protocol. These details are thoroughly discussed in the relevant literature.

An interesting aspect of this approach is that it directly generalizes Nakamoto consensus. If we choose k=0 and discard blocks outside the maximal k-cluster, we are left with the longest chain.

From PHANTOM to GHOSTDAG

There are two issues with the PHANTOM protocol as presented:

1. It could not be implemented efficiently: finding a maximal k-cluster in a given DAG is NP-complete.
2. It is not incremental: every time the DAG updates, the entire computation must restart, requiring storage of the entire DAG structure.

GHOSTDAG is a greedy variant of PHANTOM that addresses both issues. The idea is that the (now approximate) k-cluster is maintained incrementally. Each block has a number called its blue score, indicating how many blocks in its past are in the k-cluster. Given a particular block, its selected parent is the parent with the highest blue score. When a new block is created, it does not need to calculate the entire k-cluster; instead, it inherits most of the k-cluster from its selected parent, with the remainder chosen from the anticone of the selected parent. However, since this is a k-cluster, at most k elements from this set can be included.

This means that any block should only track at most k additional blocks: those in its blue past (the k-cluster from that block's perspective) but not in the blue past of its selected parent.

From this perspective, the generalization of Nakamoto consensus becomes clearer: choosing k=0, the blue score represents the length of the longest chain, and the selected chain (the chain starting from the block with the highest blue score and traversing the selected parents) is the original Nakamoto chain.

For a more detailed account of GHOSTDAG, further reading is recommended.

But Why Should GHOSTDAG Be Secure?

One might hope that the security of GHOSTDAG would be immediately implied by the security of Nakamoto consensus. However, additional steps are necessary.

Allowing parallel blocks and multiple parents creates a phenomenon called freeloading, which does not exist in Bitcoin. Freeloading occurs when an attacker allows their blocks to point to honest blocks to increase their own blue score. This raises the question of why their ability to do so does not imply that they could rearrange the block structure without creating as many blocks as the honest network.

Fortunately, the GHOSTDAG ordering has a special property known as the freeloading bound. It essentially means that an attacker wishing to revert arbitrarily old blocks cannot use honest blocks in a meaningful way. The number of blocks they could freeload from is limited by a constant (specifically, 4k blocks). This means that any attack seeking to change the ordering of arbitrarily old blocks will soon encounter a race where freeloading does not provide any advantage. With careful argumentation, this can be used to relate the security of GHOSTDAG to the security of Bitcoin.

Following this reasoning, we can prove the security property of GHOSTDAG: a computationally inferior attacker cannot revert arbitrarily old blocks, regardless of the ratio between block delay and block propagation time.

In summary, GHOSTDAG achieves the same security as Bitcoin but without constraints on the block rate, alleviating the blockchain scaling problem. It also offers nearly immediate confirmation times (in the order of seconds).

From GHOSTDAG To Kaspa — Concluding Remarks

GHOSTDAG is an intriguing protocol, but implementing it presents its own challenges. Describing Kaspa as a straightforward implementation of GHOSTDAG would be a significant understatement. In practice, many engineering and theoretical challenges had to be addressed before a usable implementation was feasible. For example, it is non-trivial to implement an efficient method to determine whether two blocks are in each other's anticone.

Additionally, Kaspa includes many other aspects not discussed in the original paper, such as a novel approach to difficulty adjustment, a sophisticated pruning mechanism, and future plans for infrastructure supporting layer two applications.

Kaspa still has a long way to go. For instance, it has not yet been stress-tested to determine how many transactions it can handle, although it has demonstrated support for 40 transactions per second, which exceeds the theoretical limit of Bitcoin and Ethereum combined, without difficulty.

The future remains uncertain, but there is a non-negligible chance that Kaspa could become the most resilient, robust, and fast PoW blockchain (or rather, blockDAG) in the world.