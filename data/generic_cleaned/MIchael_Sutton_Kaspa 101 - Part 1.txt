This is a blog series explaining the fundamentals of Kaspa in simple and concise language. I will assume the least possible prior knowledge, although some fundamentals in blockchain theory, specifically Bitcoin, may benefit the reader.

Kaspa is a pure Proof of Work (PoW) engine that generalizes and scales Bitcoin’s blockchain paradigm.

The first change Kaspa introduces is the block-DAG mining paradigm. In Bitcoin, miners first select the longest (or, to be precise, the heaviest) chain and mine over its top-most block, known as the selected tip. Essentially, miners do not share the full information they have; they do not share the knowledge of other non-selected chains they know of and chose not to mine over.

In contrast, in the block-DAG paradigm, all information is revealed. This is referred to as “the revelation principle.” The miner references all tips they know of. Following this, any protocol can be run to make choices over this knowledge, including, for instance, the longest chain rule. However, the maximization of shared knowledge opens many more opportunities.

By having each miner mine over all known blocks, a maximal amount of time relations (e.g., this block was mined “after” this block) is revealed and shared. Each miner mining over many block tips (referencing all their hashes in its header) creates a directed graph of blocks with a link pointing from a block to each of the referenced blocks. The cryptographic irreversibility of the PoW function implies that no cycles can be created in this directed graph, making it a Directed Acyclic Graph (DAG).

In terms of block-DAG terminology, the set of blocks referenced by block B is denoted as parents(B). The set past(B) is the set of blocks reachable from block B through a chain of parent links (coined “past” because we know they existed before B). Note that past(B) is never empty since it always contains genesis, which is the initial block defining the beginning of the DAG. Likewise, future(B) is the set of blocks which B is reachable from. The set anticone(B) is the set of blocks “parallel” to B, i.e., not in its past nor in its future. Essentially, no time causality information is known between B and blocks in anticone(B). It is called “anticone” because both past and future can be seen as “cones” from B’s perspective.

Before delving into the specifics of the GHOSTDAG protocol, which is the ordering protocol used by Kaspa, I will describe a general structure for ordering a block-DAG based on any parent selection rule.

Assume a parent selection function f mapping from each block B to one of its parents P. The sub-DAG containing only these special “selected” links (from every block B to its selected parent) is, in fact, a tree. Let’s name a special non-existing block called “virtual,” which always points at all DAG tips/leaves. This virtual block represents the next mined block in the eyes of the local node.

The mapping function f can be applied on virtual in order to select a specific DAG tip. We can then walk down starting from this tip through the “selected parent” links until reaching genesis. Thus, a mapping f can be translated to selecting a chain C of blocks starting from virtual and ending at genesis.

This chain can be used to deterministically order the complete DAG structure.

To accomplish this task, we need one more definition. Let’s define the mergeset of B, mergeset(B), to be the set of blocks that B merged into the DAG. Formally, this is the set of blocks which are in past(B) but not in the past of B’s selected parent as chosen by the mapping function f. It’s called a merge-set because it’s the set of blocks that B merged into the DAG from its perspective relative to its selected parent perspective.

Given a chain C and the definition of a mergeset, we are ready to describe a complete ordering rule based on f. The idea is to start from genesis and walk up this chain, where at each chain block we add its merge-set to the ordering. Intuitively, the chain here acts as a spine of the DAG, where the merge-sets are layers added one after the other. From the definition of a mergeset and its relation to the preceding chain block, it follows that all mergesets are disjoint sets and that their union covers the entire DAG.

The following pseudo-code describes this process:

```
function Order-DAG(G):
    let C be the chain obtained by applying f on DAG G as described
    ordering = []
    for block B in C walking up from genesis up to virtual:
        ordering.Add(mergeset(B))
    return ordering
```

Understanding the relation between a chain and DAG ordering helps reason about the relationship between a chain selection protocol and the security properties required from a secure ordering protocol.

For a block-DAG representing a transaction ledger, we want the ordering of the DAG to be “robust” in the sense that only a small set of blocks near the tips of the DAG might change their order. In other words, we want the ordering to “stabilize” for any block mined “enough” time ago, where “enough” depends on the amount of certainty required.

Because ordering is governed by a chain, it follows that if the chain is “robust,” i.e., does not change up to a suffix, then the DAG ordered by it is robust as well. Thus, all we need now is a secure way to find a robust chain – a secure parent mapping function f.

In the following post, I will write about the special parent selection function f = GHOSTDAG and will provide more rigorous definitions for related terms used in Kaspa, such as “blue score,” “blue work,” etc.

I chose to explain the chain structure first because I think it’s crucial to understand this decomposition for a clear understanding of the Kaspa system. Regardless of the function f used, this chain structure is utilized by our UTXO algebra infrastructure and also plays a role in the framework we implemented for supporting DAG reachability queries.