[
  {
    "id":"kasparchive_FUD 1",
    "content":"FUD 1: \"Kaspa was unfairly launched and is secretly controlled by DAGLabs\"\nFalse Claim: Kaspa's launch was rigged, and it remains under the hidden control of DAGLabs, who enriched themselves with a pre-mine.\nFact 1: DAGLabs, founded in 2018 by Yonatan Sompolinsky, was initially funded to research and develop the GhostDAG protocol and explore optical ASIC mining for a cryptocurrency. Investment totaled $8M, primarily from Polychain.\nFact 2: By mid-2021, recognizing the limitations of optical ASIC technology and shifting crypto market sentiment away from PoW, DAGLabs and Polychain made a deliberate decision to transition Kaspa into a community-owned, open-source project, explicitly relinquishing any intellectual property rights. This directly contradicts the notion of continued secret control.\nFact 3: At the mainnet launch in November 2021, DAGLabs was in a transitional phase, providing minimal support to developers during the network's initial phase.\nFact 4: Post-launch, DAGLabs mined Kaspa openly and transparently, using publicly available rented cloud hardware (Amazon initially, then GPUs). This mining was funded by the remaining portion of their initial investment, demonstrating no secret or privileged mining operation.\nFact 5: DAGLabs' mining activity lasted only about five months, ceasing entirely when their limited remaining funds were depleted.\nFact 6: The total amount of Kaspa mined by DAGLabs was less than 3% of the total supply (estimated at 2.5%, under 850M Kas). This modest amount invalidates the claim of a massive pre-mine for enrichment.\nFact 7: The mined coins were distributed proportionally to investors and former DAGLabs contributors as part of their wind-down process, a transparent distribution, not hidden accumulation.\nFact 8: DAGLabs officially ceased operations and dissolved after this period, definitively ending any operational control or involvement with Kaspa. DAGLabs does not control Kaspa.\nFact 9: Kaspa's history demonstrates a clear and documented transition to a community-driven project, directly refuting the myth of unfair launch and ongoing DAGLabs control.",
    "source":"kasparchive",
    "section":"FUD 1",
    "url":"https:\/\/kasparchive.com",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kasparchive_FUD 2",
    "content":"FUD 2: \"PoS > PoW?\"\nFalse Claim: Many argue that PoS is more secure, more efficient, and less wasteful than PoW. However, PoS introduces economic centralization risks, validator cartels, and weak security guarantees. Kaspa's PoW model ensures true decentralization and resilience against long-range attacks, which PoS cannot achieve.\nFact 1: The supposed 'superiority' of PoS is not a universally accepted fact but a heavily debated topic, deeply influenced by complex and unpredictable economic factors, not just theoretical mathematical models. There is no definitive proof of PoS superiority.\nFact 2: Claims that 'PoS is factually better' lack objective, universally agreed-upon evidence and often ignore critical security and decentralization trade-offs. These claims are not based on settled science.\nFact 3: PoW and PoS represent fundamentally different approaches with distinct security, decentralization, and economic characteristics. The 'best' choice is context-dependent and not universally determined. To declare one definitively superior is inaccurate and ignores crucial nuances.\nFact 4: Research advancements like \"Mining in Logarithmic Space\" and NiPoPoW demonstrate that Proof-of-Work protocols can achieve near-logarithmic storage requirements through secure pruning of consensus data. In contrast, Proof-of-Stake protocols, lacking a mining mechanism, are limited to linear storage growth, making them significantly less scalable and more storage intensive over time.\nFact 5: Focusing solely on the operational costs of PoW and ignoring its security benefits presents a distorted economic comparison. PoW's costs are investments in robust, decentralized security.\nFact 6: Both PoW and PoS require economic incentives to secure the network. PoW uses mining rewards and fees, while PoS uses staking rewards and minting. The economic mechanisms are comparable in function, not inherently superior or inferior in design. To claim PoS is economically 'superior' solely due to lower operational costs is superficial and ignores the value of PoW security.\nFact 7: Comparing attack costs based only on token acquisition price for PoS versus hardware costs for PoW is a grossly oversimplified and often misleading way to evaluate network security. Real-world attack costs are far more complex.\nFact 8: The actual cost of a successful attack on both PoW and PoS networks is dynamic and significantly influenced by market conditions, token liquidity, and the specific type of attack considered. There is no simple, static 'cost' to compare.\nFact 9: Security vulnerabilities and attack vectors are fundamentally different between PoW and PoS. PoS may be more susceptible to censorship attacks with lower stake control, while PoW requires massive resource domination for sustained censorship. They have different security profiles, not simply different 'costs'.\nFact 10: Long-term centralization risks differ. PoS can exhibit 'rich-get-richer' dynamics, potentially concentrating stake and influence. PoW faces ongoing operational and technological challenges to maintain dominance, creating different, but not necessarily weaker, security dynamics. Neither is inherently immune to centralization risks. To claim PoS is always more secure based on a simplistic cost comparison is factually inaccurate.",
    "source":"kasparchive",
    "section":"FUD 2",
    "url":"https:\/\/kasparchive.com",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kasparchive_FUD 3",
    "content":"FUD 3: \"Kaspa's Scalability is Limited by Ledger Growth & L2 Flaws\"\nFalse Claim: Critics claim Kaspa will struggle with state bloat due to its high-speed transactions.\nFact 1: That's wrong! Kaspa developers have created a smart solution called KIP-9 specifically to prevent the ledger from getting too big and to make sure Kaspa can keep scaling up for many, many users.\nFact 2: KIP-9 adds a \"storage cost\" to transactions. Think of it like a small fee for using storage space on the Kaspa network. Transactions that take up more space (like creating lots of tiny coin pieces) pay a bit more, which stops the ledger from ballooning.\nFact 3: This \"storage cost\" system is designed to automatically control ledger size. The cost to make the ledger bigger increases very quickly, making it too expensive for anyone to try and overload the system and cause problems. Kaspa is designed to stay efficient as it grows.\nFact 4: KIP-9 is not just an idea \u2013 it's already part of Kaspa's software and is actively working behind the scenes to keep the ledger size in check. This is a real, working solution for long-term growth.\nFact 5: Experts have tested KIP-9 and confirmed it works. They've shown that it stops ledger bloat attacks and keeps the ledger growth manageable, even if Kaspa becomes incredibly popular. Kaspa is designed to scale, and KIP-9 is a key reason why.\nFact 6: Kaspa's L2 strategy is built upon 'based rollups,' a cutting-edge L2 design that directly addresses the shortcomings of earlier L2 architectures and offers a highly secure and scalable solution. Kaspa is using advanced L2 technology.\nFact 7: Based rollups on Kaspa inherit the uncompromising security and censorship resistance of the Kaspa L1, as L1 sequencing is deeply integrated into their design. Kaspa L2s are fundamentally secure.\nFact 8: Based rollups on Kaspa are designed to enhance user experience, streamline interoperability between different L2s within the Kaspa ecosystem, and ensure that L2 activity contributes to the economic robustness of the Kaspa L1. Kaspa L2s are designed for usability and economic alignment.\nFact 9: Kaspa's entire architecture is being meticulously engineered from the ground up to seamlessly support efficient and secure L2 solutions, recognizing L2s as an essential component of truly scalable smart contract platforms. L2 scaling is a core design principle of Kaspa. To dismiss L2 scaling for Kaspa is to ignore its fundamental architectural approach.",
    "source":"kasparchive",
    "section":"FUD 3",
    "url":"https:\/\/kasparchive.com",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kasparchive_FUD 4",
    "content":"FUD 4: \"Gaps in Kaspa's ledger history imply security or transparency issues\"\nFalse Claim: Missing ledger history data means the current state of Kaspa cannot be verified from genesis, potentially hiding a pre-mine or other malicious activities, thus compromising security and transparency.\nFact 1: Ledger pruning is essential for Kaspa's long-term decentralization and sustainability. At full capacity (10 BPS), the ledger grows by approximately 30TB per year, making archival nodes impractical for widespread decentralization without pruning.\nFact 2: The genesis block is hardcoded directly into the Kaspa node software. This hardcoded genesis block contains an empty UTXO set, verifiably demonstrating that there was no pre-mine.\nFact 3: Kaspa nodes store a \"proof-of-genesis.\" This cryptographic proof verifies that the current state of the ledger is derived from the hardcoded genesis block, without requiring the entire historical ledger data.\nFact 4: Forging the proof-of-genesis would require computational work equivalent to creating the entire ledger history, ensuring its security and authenticity.\nFact 5: The data available to each Kaspa node, including the proof-of-genesis, is sufficient to verify the current state back to genesis, ensuring transparency and security even without a complete historical ledger.\nFact 6: Kaspa employs techniques to provide proof of chain integrity without the entire ledger history. For example, a chain of checkpoint blocks (growing by one header per day) can be verified all the way back to genesis.\nFact 7: These checkpoint blocks, combined with UTXO commitments, cryptographically prove that the current state evolved from a genesis block with an empty UTXO set, thus demonstrating no pre-mine.\nFact 8: The MLS protocol, relevant to Kaspa, uses a special type of Non-Interactive Proofs of Proof-of-Work (NiPoPoW) to succinctly prove chain weight, which inherently prohibits pre-mining attacks.\nFact 9: The lack of archival nodes from the beginning was a matter of prioritization post-launch, not a security risk, as it was understood that ledger gaps do not compromise network integrity.\nFact 10: This approach provides a security level comparable to Nakamoto Consensus, offering a robust chain integrity proof that is more practical than requiring a full \"proof-of-history\" (which is considered unreasonably stringent for scalability).",
    "source":"kasparchive",
    "section":"FUD 4",
    "url":"https:\/\/kasparchive.com",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kasparchive_FUD 5",
    "content":"FUD 5: \"PoW is Unsustainable, Centralized, and Inaccessible\"\nFalse Claim: Some claim PoW mining is too expensive for average users, harms the environment, and leads to mining centralization. However, PoW enables fair participation, prevents validator cartels (unlike PoS), and can use renewable energy sources. Mining pools exist, but individual miners can still participate without giving up control.\nFact 1: PoW mining is actually more decentralized than many think! Anyone can start mining with basic hardware, and there are miners all around the world. This global spread helps keep the network secure and fair.\nFact 2: Mining costs vary a lot depending on where you are. In many places, especially where there's extra electricity that would go to waste, mining can be very profitable even for smaller miners.\nFact 3: The idea that only big companies can mine successfully isn't true. Many individual miners do well by finding good locations and keeping their costs low. It's all about being smart with your setup.\nFact 4: PoW mining predominantly uses excess, stranded, or renewable energy that would otherwise be wasted. It can actually incentivize and fund renewable energy development.\nFact 5: Mining operations are highly mobile and can be strategically located where energy is abundant and cheap, often utilizing energy that would otherwise be wasted.\nFact 6: The environmental impact must be weighed against the critical service PoW provides: securing a decentralized, permissionless monetary network. This security mechanism is essential for a truly independent financial system.\nFact 7: Mining pools are voluntary associations that miners can freely join or leave. This dynamic nature prevents any single pool from gaining too much control.\nFact 8: Kaspa's high blockrate and GHOSTDAG protocol naturally discourage pool centralization by reducing variance in mining rewards, making solo mining more viable.\nFact 9: The ability to easily switch between pools or mine independently creates market pressure that keeps pools competitive and honest.",
    "source":"kasparchive",
    "section":"FUD 5",
    "url":"https:\/\/kasparchive.com",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kasparchive_FUD 6",
    "content":"FUD 6: \"Kaspa's Speed & PoW Costs Make It Inefficient\"\nFalse Claim: Some argue Kaspa's 10-second finality is too slow and that PoW costs are wasteful. However, Kaspa's GhostDAG ensures rapid block propagation, enabling parallel transaction processing. Additionally, PoW cost secures the network, making it more robust against attacks compared to cost-efficient but weaker security models like PoS.\nFact 1: Kaspa's GhostDAG protocol is a breakthrough that allows for parallel processing of transactions, making it much faster than traditional blockchains.\nFact 2: The 10-second finality is actually incredibly fast compared to most other cryptocurrencies, which can take minutes or even hours for true finality.\nFact 3: Kaspa's design allows it to handle many more transactions per second than older blockchain designs, making it highly efficient.\nFact 4: The energy used in mining Kaspa isn't wasted \u2013 it's what makes the network secure and trustworthy.\nFact 5: Kaspa's mining efficiency comes from its ability to process multiple blocks simultaneously, maximizing the utility of the energy spent on mining.\nFact 6: The energy expenditure in PoW directly contributes to network security by making attacks economically unfeasible. This is not waste, but rather a crucial feature that enables trustless consensus.\nFact 7: PoW's energy cost creates a real-world anchor for digital scarcity, something that cannot be achieved through purely digital means. The physical cost of mining gives fundamental value to the network.\nFact 8: The competitive nature of PoW mining drives innovation in energy efficiency and utilization of otherwise wasted energy sources, contributing to broader technological advancement.",
    "source":"kasparchive",
    "section":"FUD 6",
    "url":"https:\/\/kasparchive.com",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kasparchive_FUD 7",
    "content":"FUD 7: \"Kaspa Lacks Utility Because It Has No Smart Contracts or DeFi\"\nFalse Claim: Some believe that without smart contracts and DeFi, Kaspa has no future. However, Kaspa was designed as a scalable and secure PoW Layer 1, and Layer 2 solutions will enable smart contract functionality in the future. Its instant confirmations and efficient transactions already offer strong utility for payments and settlement layers.\nFact 1: Kaspa's focus on building a robust, scalable Layer 1 is intentional and strategic. This approach ensures a solid foundation for future developments.\nFact 2: The absence of smart contracts today doesn't mean they won't be added. Kaspa's roadmap includes plans for smart contract functionality through Layer 2 solutions.\nFact 3: Many successful cryptocurrencies started without smart contracts and added them later. This approach allows for careful testing and implementation.\nFact 4: Kaspa's instant transaction finality already provides significant utility for fast, secure payments \u2013 a fundamental use case for cryptocurrency.\nFact 5: While DeFi is undeniably important, Kaspa's utility extends far beyond just DeFi. Its exceptional transaction speed and throughput make it ideal for a wide range of applications, including microtransactions, high-volume data processing, and more. Kaspa's utility is not limited to DeFi.\nFact 6: The planned integration of smart contracts is specifically intended to enable a vibrant DeFi ecosystem on Kaspa, recognizing DeFi as a crucial component of a comprehensive crypto platform. DeFi is part of Kaspa's future.\nFact 7: Kaspa's deliberate focus on foundational scaling and infrastructure improvements is building a stronger and more resilient foundation for a future DeFi ecosystem that can leverage its unique technical advantages. Kaspa is building a superior DeFi platform, not ignoring DeFi.",
    "source":"kasparchive",
    "section":"FUD 7",
    "url":"https:\/\/kasparchive.com",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kasparchive_FUD 8",
    "content":"FUD 8: \"Kaspa is just another scalable PoW L1, lacking genuine innovation\"\nFalse Claim: Kaspa offers nothing truly new or groundbreaking, simply repackaging existing ideas.\nFact 1: Kaspa represents a major leap forward in blockchain technology, achieving an unprecedented combination of scalability, speed, and security within a Proof-of-Work framework. Kaspa is demonstrably innovative.\nFact 2: Kaspa incorporates groundbreaking innovations like the GHOSTDAG protocol, BlockDAG architecture, and planned advancements for MEV resistance and secure oracles. These are not just incremental changes, but fundamental advancements.\nFact 3: Kaspa directly tackles and solves critical limitations of existing blockchains, such as state bloat and slow transaction finality, with novel and sophisticated technical solutions. Kaspa is pushing the boundaries of blockchain technology. To claim it lacks innovation is to ignore the substantial technical breakthroughs it represents.",
    "source":"kasparchive",
    "section":"FUD 8",
    "url":"https:\/\/kasparchive.com",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kasparchive_FUD 9",
    "content":"FUD 9: \"Kaspa is not quantum-secure and will be obsolete when quantum computers arrive\"\nFalse Claim: Blockchains that rely on elliptic curve (EC) cryptography will be broken once quantum computers become powerful enough. Without immediate adoption of post-quantum cryptography (PQC), these networks are ignoring the threat and will eventually become obsolete.\nFact 1: Quantum computers capable of breaking EC cryptography are still far from being practical. While advancements are being made, large-scale quantum machines with millions of stable qubits\u2014needed to break EC encryption\u2014do not yet exist. Even optimistic projections suggest this is decades away.\nFact 2: The Boneh-Lipton attack on EC cryptography is a well-known theoretical threat, but mitigations exist. Increasing key sizes or shifting to larger elliptic curves can provide additional security for years before a full transition to PQC is necessary.\nFact 3: Post-quantum cryptography (PQC) is not yet ready for large-scale blockchain adoption. Many PQC schemes have significant trade-offs, including larger key and signature sizes that increase data storage and transaction costs, higher computational requirements that slow down transaction processing, and limited real-world testing compared to the decades of security validation that EC cryptography has undergone.\nFact 4: Kaspa's blockDAG architecture makes it better suited for a future transition to PQC compared to traditional blockchain designs. Since blockDAG technology enables high throughput and efficient transaction processing, it can better accommodate the larger signature sizes required by post-quantum cryptography. While many blockchains struggle with scalability limitations, Kaspa's ability to handle high transaction volumes without bottlenecks allows for a smoother adoption of quantum-safe cryptographic solutions when the technology is mature.\nFact 5: Quantum mining, not just cryptographic breaking, presents a unique challenge. Unlike classical mining, quantum miners could attempt strategies that increase orphan rates and disrupt network stability. Protocols designed to manage high orphan rates and network adaptability may have an advantage if quantum mining ever becomes viable.\nFact 6: The timeline for quantum threats is long, allowing gradual transitions. Even if quantum advancements accelerate, blockchain protocols can adopt quantum-safe cryptographic methods when they are sufficiently tested and optimized, rather than rushing into unproven solutions.",
    "source":"kasparchive",
    "section":"FUD 9",
    "url":"https:\/\/kasparchive.com",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_1",
    "content":"FUD 1: \u201cKaspa has armies of paid shills\u201d\nFalse. Kaspa launched fairly: no premine, no presale, no VC allocation, no founders\u2019 tax. There\u2019s no corporate treasury to bankroll \u201cshills.\u201d What you\u2019re seeing is a grassroots PoW community\u2014very loud, very nerdy, and very motivated\u2014because they believe the tech matters. Strong advocacy \u2260 payroll.",
    "source":"kaspa_x_twitter",
    "section":"FUD 1",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_2",
    "content":"FUD 2: \u201cThe founder is Satoshi\u201d\nMyth. Kaspa\u2019s origin traces to academic work by researchers like Yonatan Sompolinsky (Ghost\/GHOSTDAG research since 2013). Nobody credible in the project claims \u201cYonatan = Satoshi.\u201d That rumor is internet telephone used to smear the project instead of engaging with the tech. Sure, individuals joke about the possibility of it, but that doesn't mean the majority believe it.",
    "source":"kaspa_x_twitter",
    "section":"FUD 2",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_3",
    "content":"FUD 3: \u201cThey just sped up block time; now it needs data centers; it\u2019s not decentralized\u201d\nTechnically wrong. If you only speed up Bitcoin\u2019s block interval, you would centralize. Kaspa doesn\u2019t do that. It\u2019s a BlockDAG with GHOSTDAG consensus\u2014multiple blocks can be created concurrently and still be ordered consistently. That\u2019s the breakthrough: throughput without sacrificing decentralization.\n\u2022 Not a datacenter coin: full nodes run on commodity hardware; the design targets normal bandwidth and latency assumptions across the open internet.\n\u2022 Decentralization is a first-order goal: PoW + fair launch + open participation. Speed is the outcome of the DAG design, not a shortcut that trades off decentralization.",
    "source":"kaspa_x_twitter",
    "section":"FUD 3",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_4",
    "content":"FUD 4: \u201cThe website looks amateurish\u2014this must be a scam\u201d\nCategory error. Polish isn\u2019t proof. Also: the site is community-maintained by design. There\u2019s no \u201cofficial corporate site\u201d because Kaspa has no corporate issuer. An \u201cofficial\u201d site implies a controlling entity; Kaspa avoids that central point of failure.\n\u2022 In decentralized projects, the code, consensus, and network are the products\u2014not a glossy homepage.\n\u2022 A community site isn\u2019t a bug; it\u2019s a signal: no company, no marketing department, no HQ\u2014just open-source contributors.",
    "source":"kaspa_x_twitter",
    "section":"FUD 4",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_5",
    "content":"FUD 5: \u201cNo smart contracts = useless; just a faster PoW chain\u201d\nMisleading. Kaspa\u2019s base layer deliberately prioritizes sound money properties: PoW security, high throughput, fast confirmation, simple and verifiable rules. That\u2019s a design philosophy closer to Bitcoin than to Ethereum.\n\u2022 Smart-contract functionality can live on Layer 2 or evolve incrementally without bloating L1.\n\u2022 The innovation here isn\u2019t \u201cfaster blocks,\u201d it\u2019s the BlockDAG architecture that finally scales PoW without the typical orphan\/centralization spiral.",
    "source":"kaspa_x_twitter",
    "section":"FUD 5",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_6",
    "content":"FUD 6: \u201cUsage is fake; it\u2019s all bots\u201d\nUnevidenced claim. If someone says \u201cit spiked from 40k to 1M and back\u2014it\u2019s bots,\u201d ask for methodology: data source, bot-detection criteria, time windows, and controls. Hand-wavy charts with no context prove nothing.\nOrganic signals matter more: growing miners, nodes, wallets, dev activity, infra (explorers, pools, tooling). Bots don\u2019t maintain open-source repos or volunteer to run miners.",
    "source":"kaspa_x_twitter",
    "section":"FUD 6",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_7",
    "content":"FUD 7: \u201cThere\u2019s no stablecoin, no ecosystem\u2014chain does nothing\u201d\nShort-term lens. Bitcoin \u201cdid nothing\u201d for years: no stablecoins, no DeFi, no NFTs\u2014just money. Kaspa is executing the same base-layer-first approach: make money fast, final, and decentralized; then let layers and use-cases accrete where it makes sense. That\u2019s a durable strategy, not a deficiency.",
    "source":"kaspa_x_twitter",
    "section":"FUD 7",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_8",
    "content":"FUD 8: \u201cDown vs BTC last year\u2014garbage investment\u201d\nCherry-picking. Any emerging asset will have violent periods up and down. Using a single window to define a thesis is punditry, not analysis. Zoom out: Kaspa grew from a fair-launch nothingburger to a top PoW network\u2014without VC airdrops or corporate market makers. Volatility \u2260 fraud. It\u2019s the cost of discovery.",
    "source":"kaspa_x_twitter",
    "section":"FUD 8",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_9",
    "content":"FUD 9: \u201cIt\u2019ll pump on listings then die like the rest\u201d\nSpeculation as fact. Many said the same thing about Bitcoin, Litecoin, and Monero in their adolescence. Kaspa\u2019s edge isn\u2019t \u201cmarketing\u201d or \u201chype,\u201d it\u2019s:\n\u2022 PoW + Fair Launch (no insiders)\n\u2022 BlockDAG (GHOSTDAG) for parallel blocks & high throughput\n\u2022 Simple L1, room for L2 (keeps the monetary base robust)\n\u2022 Community-run infra + open code\nThat\u2019s a long-term survivability profile, not a \u201cpump-and-dump\u201d blueprint.",
    "source":"kaspa_x_twitter",
    "section":"FUD 9",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_10",
    "content":"FUD 10: \u201cIt\u2019s immoral garbage for low-IQ retail\u201d\nNot an argument. When critiques degrade into IQ insults and moral panic, you\u2019re no longer discussing computer science or monetary policy\u2014you\u2019re just doing culture war. If Kaspa were technically weak, you could falsify it technically. Insults are a tell.\nWhy Kaspa\u2019s choices make sense (the \u201cwhy,\u201d not just the \u201cwhat\u201d)\n\u2022 Decentralization first: No corporate \u201cofficial,\u201d no VC cap table, no premine. That\u2019s harder to organize\u2014and that\u2019s the point.\n\u2022 Security model: Proof-of-Work remains the simplest, most time-tested Sybil resistance. Kaspa doesn\u2019t bolt on complexity to fake throughput; it rethinks block topology.\n\u2022 Throughput via topology: In a chain, faster blocks \u21d2 more orphans \u21d2 centralization pressure. In a DAG, concurrent blocks are expected; the protocol orders them afterward. That changes the curve: you can push throughput without herding miners into a few low-latency data centers.\n\u2022 Sane base layer: Keeping L1 lean (payments + simple scripts) preserves auditability and robustness. Complex programmability can sit on L2s or side systems that don\u2019t compromise L1\u2019s monetary assurances.\n\u2022 Community surface area: A community site and many independent builders means more eyes, more clients\/tools, and fewer single points of narrative control. Less glossy; more antifragile.\nWhat the FUD gets consistently wrong",
    "source":"kaspa_x_twitter",
    "section":"FUD 10",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_1",
    "content":"FUD 1: It treats aesthetics (website polish",
    "source":"kaspa_x_twitter",
    "section":"FUD 1",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_2",
    "content":"FUD 2: It conflates speed with centralization, ignoring DAG-based concurrency.",
    "source":"kaspa_x_twitter",
    "section":"FUD 2",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_3",
    "content":"FUD 3: It equates minimal L1 with \u201cno use,\u201d forgetting Bitcoin\u2019s own trajectory.",
    "source":"kaspa_x_twitter",
    "section":"FUD 3",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_4",
    "content":"FUD 4: It argues by vibes (bots, shills, IQ takes",
    "source":"kaspa_x_twitter",
    "section":"FUD 4",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"kaspa_x_5",
    "content":"FUD 5: It assumes a centralized issuer should exist\u2014then declares Kaspa suspicious because there isn\u2019t one. That\u2019s backwards.\n#Kaspa $KAS #GhostDAG #ProofOfWork #BitcoinEvolution #Decentralization #crypto #Bitcoin",
    "source":"kaspa_x_twitter",
    "section":"FUD 5",
    "url":"https:\/\/x.com\/dotkrueger\/status\/1956843811679989918",
    "filename":null,
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_0",
    "content":"# PHANTOM GHOSTDAG\n\n",
    "source":"whitepaper",
    "section":"PHANTOM GHOSTDAG",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_1",
    "content":"# AScalableGeneralizationofNakamotoConsensus\n\nNovember10,2021",
    "source":"whitepaper",
    "section":"AScalableGeneralizationofNakamotoConsensus",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":1.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_2",
    "content":"# YonatanSompolinsky ShaiWyborski AvivZohar\n\nyoni_sompo@cs.huji.ac.il shaide@cs.huji.ac.il avivz@cs.huji.ac.il",
    "source":"whitepaper",
    "section":"YonatanSompolinsky ShaiWyborski AvivZohar",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":3.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_3",
    "content":"# SchoolofEngineeringandComputer SchoolofEngineeringandComputer SchoolofEngineeringandComputer\n\nScience,TheHebrewUniversityof Science,TheHebrewUniversityof Science,TheHebrewUniversityof\nJerusalem,Israel Jerusalem,Israel Jerusalem,Israel\nABSTRACT GHOSTDAGinrealworldscenarios.Weprovideananalysisof\nIn2008SatoshiNakamotoinventedthebasisforblockchain-based confirmationtimesobtainedbyobservingtheKaspanetwork.\ndistributed ledgers. The core concept of this system is an open WeprovideaformalproofofthesecurityofGHOSTDAG,namely,\nand anonymous network of nodes, or miners, which together thatitsorderingofblocksisirreversibleuptoanexponentially\nmaintain a public ledger of transactions. The ledger takes the negligiblefactor.WediscussthepropertiesofGHOSTDAGand\nform of a chain of blocks, the blockchain, where each block is howitcomparestootherDAGbasedprotocols.\na batch of new transactions collected from users. One primary\nproblemwithSatoshi\u2019sblockchainisitshighlylimitedscalability.",
    "source":"whitepaper",
    "section":"SchoolofEngineeringandComputer SchoolofEngineeringandComputer SchoolofEngineeringandComputer",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":67.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_4",
    "content":"# 1 INTRODUCTION\n\nThesecurityofSatoshi\u2019slongestchainrule,moregenerallyknown",
    "source":"whitepaper",
    "section":"1 INTRODUCTION",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":1.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_5",
    "content":"# ThesecurityoftheBitcoinprotocolreliesonblockspropagating\n\nastheBitcoinprotocol,requiresthatallhonestnodesbeawareof\nquickly to all miners in the network [9, 14, 19]. Block creation\neachother\u2019sblocksverysoonaftertheblock\u2019screation.Tothisend,",
    "source":"whitepaper",
    "section":"ThesecurityoftheBitcoinprotocolreliesonblockspropagating",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":14.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_6",
    "content":"# itselfissloweddownviatherequirementthateachblockcontain\n\n",
    "source":"whitepaper",
    "section":"itselfissloweddownviatherequirementthateachblockcontain",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_7",
    "content":"# thethroughputofthesystemisartificiallysuppressedsothateach\n\na proof-of-work. For the Bitcoin protocol to be secure, block\nblockfullypropagatesbeforethenextoneiscreated,andthatvery",
    "source":"whitepaper",
    "section":"thethroughputofthesystemisartificiallysuppressedsothateach",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":11.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_8",
    "content":"# propagationmustbefasterthanthetypicaltimeittakesthenetwork\n\nfew\u201corphanblocks\u201dthatforkthechainbecreatedspontaneously.\ntogethertocreatethenextblock.Inordertoguaranteethisproperty,\nIn this paper we present PHANTOM, a proof-of-work based",
    "source":"whitepaper",
    "section":"propagationmustbefasterthanthetypicaltimeittakesthenetwork",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":11.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_9",
    "content":"# thecreationofblocksinBitcoinisregulatedbytheprotocoltooccur\n\nprotocolforapermissionlessledgerthatgeneralizesNakamoto\u2019s\nonlyonceevery10minutes,andtheblocksizeitselfislimitedto\nblockchain to a direct acyclic graph of blocks (blockDAG).\nallowforfasttransmission.Asaresult,Bitcoinsuffersfromahighly",
    "source":"whitepaper",
    "section":"thecreationofblocksinBitcoinisregulatedbytheprotocoltooccur",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":12.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_10",
    "content":"# PHANTOM includes a parameter k that controls the level of\n\nrestrictivethroughputontheorderof3-7transactionspersecond\ntoleranceoftheprotocoltoblocksthatwerecreatedconcurrently,\n(tps)1.\nwhichcanbesettoaccommodatehigherthroughput.Itthusavoids\nthesecurity-scalabilitytradeoffwhichSatoshi\u2019sprotocolsuffers ThePHANTOMprotocol.InthispaperwepresentPHANTOM,\nfrom. aprotocolthatgeneralizesNakamoto\u2019slongestchainprotocol.In\nPHANTOMsolvesanoptimizationproblemovertheblockDAG Bitcoin,blocksreferenceasinglepredecessorinthechain,hence\nto distinguish between blocks mined properly by honest nodes form a tree; in contrast, PHANTOM blocks reference multiple\nandthosecreatedbynon-cooperatingnodeswhochosetodeviate predecessors,thusformingaDirectedAcyclicGraph,ablockDAG.\nfrom the mining protocol. Using this distinction, PHANTOM Eachblockcanthusincludeseveralhashreferencestopredecessors.",
    "source":"whitepaper",
    "section":"PHANTOM includes a parameter k that controls the level of",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":39.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_11",
    "content":"# provides a robust total order on the blockDAG in a way that PHANTOM then provides a total ordering over all blocks and (Part 1)\n\nis eventually agreed upon by all honest nodes. Implementing transactions,andoutputsaconsistentsetofacceptedtransactions.\nPHANTOMrequiressolvinganNP-hardproblem,andtoavoidthis UnliketheBitcoinprotocol,whereblocksthatarenotonthemain\nprohibitivecomputation,wedevisedanefficientgreedyalgorithm chain are discarded, PHANTOM incorporates all blocks in the\nGHOSTDAGthatcapturestheessenceofPHANTOM. blockDAGintotheledger,butplacesblocksthatwerecreatedby\nThe GHOSTDAG protocol has been implemented as the attackerslaterintheorder.\nunderlyingtechnologyoftheKaspacryptocurrency.TheKaspa Inroughterms,PHANTOMconsistsofathree-stepprocedure:\nnetworkallowsustoproducestatisticsabouttheperformanceof (1) UsingthestructureoftheblockDAG,werecognizeaset\nof well-connected blocks (we later refer to these as blue\nblocks);thisprocedureisusedtoexcludeblockscreatedby\nmisbehavingnodesandistheheartoftheprotocol:Blocks\nPermissiontomakedigitalorhardcopiesofallorpartofthisworkforpersonalor thateitherreferenceonlyoldblocksfromtheDAG,orare",
    "source":"whitepaper",
    "section":"provides a robust total order on the blockDAG in a way that PHANTOM then provides a total ordering over all blocks and (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":52.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_12",
    "content":"# classroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributed\n\nwithheldbytheircreatorforsometime,willbeexcluded",
    "source":"whitepaper",
    "section":"classroomuseisgrantedwithoutfeeprovidedthatcopiesarenotmadeordistributed",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":1.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_13",
    "content":"# forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefull (Part 1)\n\ncitationonthefirstpage.Copyrightsforcomponentsofthisworkownedbyothers fromthesetofblueblockswithhighprobability.\nthantheauthor(s)mustbehonored.Abstractingwithcreditispermitted.Tocopy (2) We complete the DAG\u2019s naturally induced partial order\notherwise,orrepublish,topostonserversortoredistributetolists,requiresprior\nspecificpermissionand\/orafee.Requestpermissionsfrompermissions@acm.org. toafulltopologicalone(i.e.,anorderwhichrespectsthe\nAFT\u201921,September26\u201328,2021,Arlington,VA,USA\u00a92021Copyrightheldbythe\nowner\/author(s).PublicationrightslicensedtotheAssociationforComputing\nMachinery.ACMISBN978-1-4503-9082-8\/21\/09...$15.00 1Theexactfigurevariesaccordingtothesizeofatypicaltransaction,andchangesif\nhttps:\/\/doi.org\/10.1145\/3479722.3480990 oneincludesprotocolchangessuchasSegWit,Schnorrsignatures,etc.",
    "source":"whitepaper",
    "section":"forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefull (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":21.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_14",
    "content":"# forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefull (Part 2)\n\n--- Page 2 ---\n,, YonatanSompolinsky,ShaiWyborski,andAvivZohar\ntopology)inawaythatfavoursblocksinsidetheselected\nclusterandpenalizesthoseoutsideit.\n(3) Theorderoverblocksinducesanorderovertransactions;",
    "source":"whitepaper",
    "section":"forprofitorcommercialadvantageandthatcopiesbearthisnoticeandthefull (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":10.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_15",
    "content":"# transactions in the same block are ordered according to\n\ntheorderoftheirappearanceintheblock.Weiterateover\nalltransactionsinthisorder,andaccepteachonethatis\nconsistent(accordingtotheunderlyingconsistencynotion)\nwithalltransactionsapprovedsofar.\nPropagation delay. The first step above involves assuming\nan upper bound on the network\u2019s delay diameter D, and\nparameterizingtheprotocolaccordingly;kdenotesthisparameter.\nSuchanassumptionismadeinNakamotoConsensusaswell.Infact,\nifPHANTOMissettoprocesslowthroughput,wecansetk =0,\ninwhichcasePHANTOMcoincideswithNakamotoConsensus.\nFigure 1: An example of a block DAG G. Each block\nHowever,whileNakamotoConsensussuppressesthethroughput",
    "source":"whitepaper",
    "section":"transactions in the same block are ordered according to",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":39.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_16",
    "content":"# referencesallblocksthatwereknowntoitsmineratthe (Part 1)\n\nandsetstheblockcreationrate\u03bbsuchthatD\u00b7\u03bb\u226a1,PHANTOM\ntimeitwascreated.TheDAGterminologyappliestoH\ndoes not impose an a priori constraint over \u03bb. Instead, the asfollows:\nthroughput(intermsof\u03bbandtheblocksize)canbesettoapproach past(H) = {Genesis,C,D,E} \u2013 blocks which H\nthenetwork\u2019scapacity,andthenkcanbesetafterthefacttoensure references directly or indirectly, and which were\nthesafetyoftheprotocol.Thisalleviatesthesecurity-scalability provablycreatedbeforeH;\ntradeoffthatNakamotoConsensussuffers.Still,increasingkdoes future(H) = {J,K,M} \u2013 blocks which reference H\nnotcomewithoutcost,aswewilldiscussshortly. directlyorindirectly,andwhichwereprovablycreated\nafterH;\nGHOSTDAG. In its vanilla form, PHANTOM requires solving anticone(H) = {B,F,I,L} \u2013 the order between these\nan NP-hard problem, and is therefore unsuitable for practical\nblocksandH isambiguous.Reachingconsensusonthe\napplications.Instead,weusetheintuitionbehindPHANTOMto orderbetweenblocksandotherblocksintheiranticone\ndeviseagreedyalgorithm,GHOSTDAG,whichcanbeimplemented isthemainchallengethatweface.\nefficiently.WeproveformallythatGHOSTDAGissecure,inthe tips(G) = {J,L,M} \u2013leaf-blocks,namely,blockswith\nsensethatitsorderingofblocksbecomesexponentiallydifficultto in-degree0;thesewillbereferencedintheheaderofthe\nreverseastimedevelops. nextblock.",
    "source":"whitepaper",
    "section":"referencesallblocksthatwereknowntoitsmineratthe (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":84.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_17",
    "content":"# ThemainachievementofGHOSTDAGcanbesummarizedas\n\nfollows:\npast(B,G)andfuture(B,G)(excludingBitself);thisisthesetof\nTheorem (Informal). Given two transactions tx1,tx2 that were blocksintheDAGwhichdidnotreferenceB(directlyorindirectly\npublished and embedded in the blockDAG at some point in time, viatheirpredecessors)andwerenotreferencedbyB(directlyor\ntheprobabilitythatGHOSTDAG\u2019sorderbetweentx1andtx2changes\nindirectlyviaB\u2019spredecessors).2Finally,tips(G)isthesetofblocks\novertimedecreasesexponentiallyastimegrows,evenunderahigh within-degree0(usually,themostrecentblocks).Thisterminology\nblockcreationratethatisnon-negligiblerelativetothenetwork\u2019s isdemonstratedinFigure1.\npropagationdelay,assumingthatamajorityofthecomputational\npowerisheldbyhonestnodes. 2.2 TheDAGminingprotocol\nWewillreformalizethistheoreminSection3,andprovidea Rather than extending a single chain, a miner in PHANTOM\nformalproofinAppendixA. referencesinitsnewblockallblocksintips(G),whereG isthe",
    "source":"whitepaper",
    "section":"ThemainachievementofGHOSTDAGcanbesummarizedas",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":47.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_18",
    "content":"# WenowproceedtodescribethePHANTOMandGHOSTDAG DAGthattheminerobserveslocallyatthetimewhenthenew\n\nprotocolsmoreformally. blockiscreated.Additionally,theminershouldbroadcastitsnew\nblockasfastaspossible.Thesetworulestogetherconstitutethe\n2 THEPHANTOMPROTOCOL DAGminingprotocolinPHANTOM.\n\n## 2.1 Preliminaries\n\n\n## 2.3 TheDAGorderingprotocol",
    "source":"whitepaper",
    "section":"WenowproceedtodescribethePHANTOMandGHOSTDAG DAGthattheminerobserveslocallyatthetimewhenthenew",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":12.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_19",
    "content":"# The following terminology is used extensively throughout this\n\n",
    "source":"whitepaper",
    "section":"The following terminology is used extensively throughout this",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_20",
    "content":"# TheaforementionedDAGminingprotocolimpliesinparticularthat\n\npaper.ADAGofblocksisdenotedG =(C,E),whereCrepresents\nevenwhentwoblockscontainconflictingtransactions,bothblocks\nblocksandErepresentsthehashreferencestopreviousblocks.We\nareincorporatedintotheblockDAGandreferencedbyall(honest)\nfrequentlywriteB \u2208GinsteadofB \u2208 C.past(B,G)\u2282 Cdenotes\nminers.Thecorechallengeisthenhowtorecovertheconsistencyof\nthesubsetofblocksreachablefromB(excludingB),andsimilarly\ntheblockDAG.Thisisdoneinourframeworkbyorderingallblocks\nfuture(B,G) \u2282 C denotesthesubsetofblocksfromwhichB is\n\u2013andbyextension,alltransactions\u2013andacceptingtransactionsone\nreachable(excludingB);theseareblocksthatwereprovablycreated\nbyone,eliminatingindividualtransactionsthatareinconsistent\nbefore and after B, correspondingly. An edge in the DAG points\nbackintime,fromthenewblocktopreviouslycreatedblockswhich 2Wewillfrequentlyabbreviatethenotationandwrite,e.g.,anticone(B),insteadof\nitextends.Wedenotebyanticone(B,G)thesetofblocksoutside anticone(B,G).\n\n--- Page 3 ---",
    "source":"whitepaper",
    "section":"TheaforementionedDAGminingprotocolimpliesinparticularthat",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":40.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_21",
    "content":"# PHANTOMGHOSTDAG\n\n",
    "source":"whitepaper",
    "section":"PHANTOMGHOSTDAG",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_22",
    "content":"# AScalableGeneralizationofNakamotoConsensus\n\nNovember10,2021\nwiththoseapprovedbeforethem.PHANTOMachievesconsensus In this formulation, the parameter k is predetermined; see\nontheorderofblocks,andthisguaranteesagreementonthesetof Section4formoredetails.Anexampleofamaximumk-cluster\nacceptedtransactionsaswell. appearsinFigure2.\nEssentially,Bitcoincanbeseenasanorderingprotocolaswell,\n2.3.2 ThePHANTOMprotocol. Followingtheaboveintuition,the",
    "source":"whitepaper",
    "section":"AScalableGeneralizationofNakamotoConsensus",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":19.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_23",
    "content":"# accordingtowhichtransactionsembeddedinthelongestchainof\n\norderingprotocolofPHANTOMcomprisesthefollowingtwosteps:\nblocksprecedethoseoffthelongestchain.Unfortunately,Bitcoin\u2019s\nprotocolisknowntobesecureonlyunderslowblockrates(see\n(1) GivenablockG,solveMCS\n(G);let\u2019srefertoitsoutputas\ntheBluesetandtoitscomplementsetastheRedone.\nSection4).\n(2) DeterminetheorderbetweenBlueblocksaccordingtosome\nTheorderingruleofPHANTOMhastwostages:First,wedivide\ntheblockstoBluesandReds;theBluesetrepresentsblocksthat\ntopologicalsort.Then,foranyBlueblockB,addtotheorder\nappeartohavebeenminedbycooperatingnodes,whereasblocksin\njustbeforeBalloftheRedblocksinpast(B)thatweren\u2019t\naddedtotheorderyet;theseRedblockstooshouldbeadded",
    "source":"whitepaper",
    "section":"accordingtowhichtransactionsembeddedinthelongestchainof",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":16.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_24",
    "content":"# theRedsetareoutliersthatweremostlikelyminedbymaliciousor\n\ninatopologicalmanner.3\nstrategicnodes.Then,weordertheDAGinawaythatfavoursblue\nblocksandpenalizesredones.Thelatterstepisratherimmediate, An example of the output of the PHANTOM procedure on\nandthenoveltyofPHANTOMliesmainlyinthefirstcolouring thesmallblockDAGfromFigure2is:(A,D,C,G,B,F,I,E,J,H,K).\nprocedure. Unfortunately,theMaximumk-clusterSubDAGproblemisNPhard\n(seeproblem[GT26]in[10]),andPHANTOMisthereforeofless\n2.3.1 The intuition behind PHANTOM. Just like Bitcoin, practicaluseforanever-growingblockDAG.Wethusintroducea",
    "source":"whitepaper",
    "section":"theRedsetareoutliersthatweremostlikelyminedbymaliciousor",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":27.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_25",
    "content":"# PHANTOMreliesontheabilityofhonestnodestocommunicate\n\ngreedyalgorithmthatismoresuitableforimplementation.Wecall\nto their peers recent blocks in a timely manner, and on the thisgreedyvariantGHOSTDAG.4\nassumption that honest nodes possess more than 50% of the\nhashrate.TheblockrateinBitcoinissuppressedsoastoensure\n\n## 2.4 TheGHOSTDAGprotocol",
    "source":"whitepaper",
    "section":"PHANTOMreliesontheabilityofhonestnodestocommunicate",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":28.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_26",
    "content":"# block creation is slower than the time it takes to communicate\n\nSimilartoPHANTOM,theGHOSTDAGprotocolselectsak-cluster,\nthem.InPHANTOM,ontheotherhand,wenoticethatthesetof\nwhichinducesacolouringoftheblocksasBlues(blocksinthe",
    "source":"whitepaper",
    "section":"block creation is slower than the time it takes to communicate",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":3.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_27",
    "content":"# honestblockscanberecognizedevenwhentheblockrateishigh\n\nselectedcluster)andReds(blocksoutsidethecluster).However,\nandmanyforksappearspontaneously:Duetothecommunication\ninsteadofsearchingforthelargestk-cluster,GHOSTDAGfindsa\nandcooperationofhonestminers,weshouldexpecttoseeinthe\nk-clusterusingagreedyalgorithm.Thealgorithmconstructsthe\nDAGa\u201cwell-connected\u201dclusterofblocks.",
    "source":"whitepaper",
    "section":"honestblockscanberecognizedevenwhentheblockrateishigh",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":6.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_28",
    "content":"# BluesetoftheDAGbyfirstinheritingtheBluesetofthebesttip\n\nIndeed,letDbeanupperboundonthenetwork\u2019spropagation\ndelay.IfblockBwasminedbyanhonestminerattimet,thenany\nBmax ,i.e.,thetipwiththelargestBluesetinitspast,andthenadds\nblockpublishedbeforetimet\u2212Dnecessarilyarrivedatitsminer\ntotheBluesetblocksoutsideBmax \u2019spastinawaythatpreserves\nthek-clusterproperty.\nbeforetimet,andisthereforeincludedinpast(B).Similarly,the\nObservethatthisgreedyinheritanceruleinducesachain:The\nhonestminerwillpublishBimmediately,andsoBwillbeincluded\ninthepastsetofanyblockminedaftertimet+D.Asaresult,theset\nlastblockofthechainistheselectedtipofG,Bmax ;thenextblock\nofhonestblocksinB\u2019santiconeistypicallysmall,andconsistsonly\ninthechainistheselectedtipoftheDAGpast(Bmax);andsoon\ndowntothe\u0434enesis.WedenotethischainbyChn(G)=(\u0434enesis =\nofblockscreatedintheinterval[t\u2212D,t+D].Theproof-of-work",
    "source":"whitepaper",
    "section":"BluesetoftheDAGbyfirstinheritingtheBluesetofthebesttip",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":19.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_29",
    "content":"# mechanismguaranteesthatthenumberofblockscreatedinan (Part 1)\n\nChn0(G),Chn1(G),...,Chn\n(G)).\nThe final order over all blocks, in GHOSTDAG, follows a\nintervaloflength2\u00b7Distypicallybelowsomek >0.\nsimilarpathasthecolouringprocedure:WeordertheblockDAG\nIn short, the set of blocks created by honest nodes\nis well-connected. The following definition captures\nby first inheriting the order of Bmax on blocks inpast(Bmax ),\n\u201cwell-connectedness\u201d:\nthen adding Bmax itself to the order, and finally adding blocks\noutsidepast(Bmax )accordingtosometopologicalordering.Thus,\nDefinition1. GivenaDAGG =(C,E),asubsetS \u2286 Ciscalleda essentially,theorderoverblocksbecomesrobustasthecolouring\nk-cluster,if\u2200B \u2208S :|anticone(B)\u2229S| \u2264k. procedure.\nAttackernodesmaydeviatearbitrarilyfromtheminingrules, 2.4.1 Formal algorithm. The procedures described above are\nhavelargeanticones,andevenartificiallyincreasetheanticone formalized in Algorithm 1 below. The algorithm begins with\nofhonestblocks.Nonetheless,sincehonestminerspossessmore thebasecasewheretheDAGconsistsofthe\u0434enesis blockonly\nproof-of-workpower,itisusuallyimpossibleformaliciousminers (lines2-3).Next,itperformsarecursivecalltocomputetheBlue\ntocreateawell-connectedsetofblocksthatislargerthanthat setsandorderingofthepastofeachoftheDAG\u2019stips(lines4-5),\ncreatedbyhonestnodes.PHANTOMutilizesthisfactandselectsthe and inherits those of the best tip (lines 6-8). Then, the selected\nlargestwell-connectedsetwithintheDAG,bysolvingthefollowing\n3Thetopologicalsortsinthissecondstepareadditionallyrequiredtobeagnosticto\noptimizationproblem: futureblocks:ForanyBlueblockB,theorderonblocksinpast(B)shouldremain\nthesameifweremovefromtheDAGblocksinfuture(B).Thiscanbeimplemented,\nMaximumk-clusterSubDAG(MCS ) forinstance,usingapriorityqueuethatpopsoutblocksaccordingtothesizeoftheir\nInput:DAGG =(C,E) pastset.\n4InpreviousversionsofthispaperwereferredtobothversionsasPHANTOM.\nOutput: A subset S\u2217 \u2282 C of maximum size, s.t. Essentially,GHOSTDAGcanbeseenasafixofthegreedyalgorithmintroduced\n|anticone(B)\u2229S\u2217| \u2264kforallB \u2208S\u2217. bytheauthorsin[19],calledtheGHOSTprotocol.WethankEthanHeilmanfor\nsuggestingthisname.",
    "source":"whitepaper",
    "section":"mechanismguaranteesthatthenumberofblockscreatedinan (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":134.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_30",
    "content":"# mechanismguaranteesthatthenumberofblockscreatedinan (Part 2)\n\n--- Page 4 ---\n,, YonatanSompolinsky,ShaiWyborski,andAvivZohar\nAlgorithm1OrderingtheDAG\nInput: G\u2013ablockDAG,k\u2013thepropagationparameter\nOutput: BLUE (G) \u2013 the Blue set of G; ord \u2013 an ordered list",
    "source":"whitepaper",
    "section":"mechanismguaranteesthatthenumberofblockscreatedinan (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":23.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_31",
    "content":"# containingallblocksinG (Part 1)\n\n1: functionOrderDAG(G,k)\n2: ifG =={\u0434enesis}then\n3: return[{\u0434enesis},{\u0434enesis}]\n4: forB \u2208tips(G)do\n5: [BlueSetB ,OrderedListB ]\u2190OrderDAG(past(B),k)\n6: Bmax \u2190 argmax{|BlueSetB |:B \u2208tips(G)}\n(breaktiesaccordingtolowesthash)\n7: BlueSetG \u2190BlueSetBmax\n8: OrderedListG \u2190OrderedListBmax\n9: addBmax toBlueSetG\n10: addBmax totheendofOrderedListG\n11: forB \u2208anticone(Bmax,G)doinsometopologicalordering\nFigure2:Anexampleofthelargest3-clusterofblocks\n12: ifBlueSetG \u222a{B}isak-clusterthen\nwithinagivenDAG:A,B,C,D,F,G,I,J (colouredblue). 13: addBtoBlueSetG\nIt is easy to verify that each of these blue blocks has 14: addBtotheendofOrderedListG\nat most 3 blue blocks in its anticone, and (a bit less 15: return[BlueSetG ,OrderedListG ]\neasy) that this is the largest set with this property.\nSettingPHANTOM\u2019sinter-connectivityparameterwith\nk = 3 means that at most 4 blocks are assumed to\nbe created within each unit of delay, so that typical (seeSection4).Insuchasetup,bothPHANTOMandGHOSTDAG\nanticone sizes should not exceed 3. Blocks outside the converge to Bitcoin\u2019s rule in the sense that, in case of a chain\nlargest 3-cluster, E,H,K (coloured red), belong to the split, blocks on the longest chain precede those off the longest\nattacker(w.h.p.).Forinstance,blockEhas6blueblocks chain.TheseprotocolswoulddifferfromBitcoin\u2019sruleinthat,as\nin its anticone (B,C,D,F,G,I); these blocks didn\u2019t ofaccordingtotheDAGminingprotocol,blocksinthelongest\nreference E,presumablybecause E waswithheldfrom chainwouldeventuallyreferencethoseoffthelongestchain,in\ntheirminers.Similarly,blockK admits6blueblocksin\nPHANTOMorGHOSTDAG,andwilltherebyinserttheminthe\nits anticone (B,C,G,F,I,J); presumably, its malicious\norder.",
    "source":"whitepaper",
    "section":"containingallblocksinG (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":174.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_32",
    "content":"# minerreceivedalreadysomeoftheseblocksbutviolated\n\nInfact,itiseasytoseethatthelongestchainis,bydefinition,\ntheminingprotocolbynotreferencingthem.\nthelargest0-clusteroftheDAG.Accordingly,ourprotocolscanbe\nseenasageneralizationofSatoshi\u2019slongest-chainruletoasetup\ntipisaddedtotheBluesetBlueSetG andtothelastpositionin whereblockrateishighandpropagationdelaysarenotnegligible.\nthecurrentorderedlistOrderedListG (lines9-10).Thenweiterate InAppendixAweprovethatGHOSTDAGremainssecureunder\noveranticone(Bmax,G)insometopologicalwaywhichguarantees highblockcreationratesaswell.Weleavetheformalanalysisof\nthatablockisvisitedonlyafteritspredecessorsare(lines11-14).5\nPHANTOMforfuturework.\nForeveryblockwevisit,wecheckifaddingBtotheBluesetwill\npreservethek-clusterproperty,andifthisconditionissatisfied,",
    "source":"whitepaper",
    "section":"minerreceivedalreadysomeoftheseblocksbutviolated",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":16.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_33",
    "content":"# 3 FORMALMODELANDSTATEMENT (Part 1)\n\nweaddBtotheBlueset(lines9-13);eitherway,weaddBtothe\nIn this section we describe our formal framework. While we\ncurrentlastpositioninthelist(line14).Finally,wereturntheBlue\nintroducenewnotationandterminology,thereadershouldkeep\nsetandtheorderedNotethattherecursioninthealgorithm(line5)\nhalts,becauseforanyblockB \u2208G:|past(B)| < |G|. in mind that we stick to Nakamoto Consensus\u2019s model in almost\nWedemonstratetheoperationofthisalgorithminFigure3.We\neveryrespect\u2014transactions,blocks,Proof-of-work,computationally\nboundedattacker,P2Ppropagationofblocks,probabilisticsecurity\nhaveanefficientimplementationofAlgorithm1,andwetestedit\nguarantees,etc.The\u201conly\u201ddifferenceisthatablockreferences\nunderhighblockrates(\u03bb=10,25blockspersecond,forblocksof\n(possibly)severalpredecessorsratherthanasingleone.Whilethis\nsize0.1-1MB).Wewillmaketheimplementationavailableinthe\nhasfarreachingconsequencesonhowtheledgeristobeinterpreted,\nfullversionofthispaper.\nontheminingsidethingsremainlargelythesame.\n2.5 CollapsetoBitcoinwhenk = 0",
    "source":"whitepaper",
    "section":"3 FORMALMODELANDSTATEMENT (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":44.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_34",
    "content":"# 3 FORMALMODELANDSTATEMENT (Part 2)\n\n## 3.1 Network\n\nIftheblockcreationrateiskeptlow,asinBitcoin,theparameterk\nWefollowthemodelspecifiedin[18].Thenetworkofnodes(or\ncanbesafelysetto0,ashonestblocksarelikelytocreateachain\nminers)isdenotedN,honest denotesthesetofnodesthatabideto\n5This can be implemented in several ways, e.g., by inserting all blocks in theminingprotocol(asdefinedbelow),andmaliciousdenotesthe\nanticone(Bmax)intoadeterministicpriorityqueuewhichrespectsthetopology.\nrestofthenodes.Honestnodesformaconnectedcomponentin\nThatis,thequeueshouldpopoutablockonlyafterallofitsparentshavebeenpopped\nout,andtheorderinwhichitpopsblocksshouldbefullydeterminedbytheblockDAG. N\u2019stopology,andthecommunicationdelaydiameterofthehonest\n\n--- Page 5 ---",
    "source":"whitepaper",
    "section":"3 FORMALMODELANDSTATEMENT (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":31.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_35",
    "content":"# PHANTOMGHOSTDAG\n\n",
    "source":"whitepaper",
    "section":"PHANTOMGHOSTDAG",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_36",
    "content":"# AScalableGeneralizationofNakamotoConsensus (Part 1)\n\nNovember10,2021\nFigure3:AnexampleofablockDAGGandtheoperationofGHOSTDAGtoconstructitsbluesetBLUEk (G)set,undertheparameterk =3.\nThesmallcircleneareachblockXrepresentsitsscore,namely,thenumberofblueblocksintheDAGpast(X).Thealgorithmselectsthechain\ngreedily,startingfromthehighestscoringtipM,thenselectingitspredecessorK (thehighestscoringtipinpast(M)),thenH,D(breaking\ntheC,D,Etiearbitrarily),andfinallyGenesis.Formethodologicalreasons,weaddtothischainahypothetical\u201cvirtual\u201dblockV \u2013ablock\nwhosepastequalstheentirecurrentDAG.Blocksinthechain(\u0434enesis,D,H,K,M,V)aremarkedwithalight-blueshade.Usingthischain,\nweconstructtheDAG\u2019ssetofblueblocks,BLUEk (G).Thesetisconstructedrecursively,startingwithanemptyone,asfollows:Instep1we\nvisitDandadd\u0434enesistotheblueset,astheonlyblockinpast(D).Next,instep2,wevisitH andaddtoBLUEk (G)blocksthatarebluein\npast(H),namely,C,D,E.Instep3wevisitK andaddH,I;notethatblockBisinpast(K)butwasnotaddedtotheblueset,sinceithas4\nblueblocksinitsanticone.Instep4wevisitMandaddKtotheblueset;again,notethatF \u2208past(M)couldnotbeaddedtothebluesetdue\ntoitslargeblueanticone.Finally,instep5,wevisittheblockvirtual(G)=V,andaddMandtoBLUEk (G),leavingLawayduetoitslarge\nblueanticone,andleavingJ awaybecauseaddingitwouldcauseI tosuffertoolargeablueanticone(italreadyhasC,D,andH init).\nsubnetworkisD:ifanhonestnodev \u2208N sendsamessageofsize Blockreferences.Everyblockspecifiesitsdirectpredecessors\nb MBattimet,itarrivesatallhonestnodesbytimet +D the byreferencingtheirIDinitsheader(ablock\u2019sIDisobtainedby\nlatest.Theattackerisassumedtosuffernodelaysonitsoutgoing applying a collision resistant hash to its header); the choice of\norincominglinks. predecessorswillbedescribedinthenextsubsection.Thisresults\nTherealvalueofDisaprioriunknown.ThePHANTOMprotocol inastructureofadirectedacyclicgraphofblocks(asblockscanonly\nassumesthatDisalwayssmallerthansomeconstantDmax (both referenceblockscreatedbeforethem),denotedtypicallyG =(C,E).\ndependontheblocksizeb).TheparameterDmax isnothard-coded RecallthatthetopologyoftheDAGinducesanaturalpartial\nexplicitlyintheprotocol,ratheritinfluencesanotherparameter, orderingoverblocks(Subsection2.1):ifB \u2208past(C)(equiv.C \u2208\nk =k(Dmax ),whichishard-codedanddecidedonceandforallat future(B))thenC wasprovablycreatedafterBandthereforeB\ntheinceptionofthesystem.Roughlyspeaking,k(Dmax )represents shouldprecedeCintheorder.7\nanupperboundonthenumberofblocksthatthenetworkcreates DAGminingprotocol.Gv denotestheblockDAGthatnodev \u2208\ninoneunitofdelayandthatmaynotbereferencedbyoneanother. N observesattimet.ThisD t AGrepresentsthehistoryofall(valid)\nSection4discussesthisparameterinmoredetail. block-messagesreceivedbythenode.Anodedoesnotconsidera\nblockasvaliduntilitreceivesitsentirepastset.Theuniqueblock\n3.2 Miningframework \u0434enesisistheblockcreatedattheinceptionofthesystem,andevery\nProof-of-work.Nodescreateblocksoftransactionsbysolving validblockmusthaveitinitspastset.\nProof-of-workpuzzles.BlockcreationfollowsaPoissonprocess AtipoftheDAGisaleaf-block,namely,ablockwithin-degree\nwithparameter\u03bb.Forthesakeofsimplicity,weassumethat\u03bbis 0.TheinstructionstoaminerintheDAGparadigmaresimple:\nconstant.6Wedenotebytime(B)theabsolutetimeofB\u2019screation.\n(1) Whencreatingorreceivingablock,transmitittoallofone\u2019s\nThecomputationalpowerofnodev \u2208Niscapturedby0<\u03b1v <1, peersinN.Formally,thisimpliesthat\u2200v,u \u2208honest :Gv\nwhichrepresentstheprobabilitythatnodev willbethecreator Gu .\nof the next block in the system (at any point in time; this is a\nt+D\n(2) Whencreatingablock,embedinitsheaderalistcontaining\nmemorylessprocess).\nthehashofalltipsinthelocally-observedDAG.Formally,this\n6Inpractice,\u03bb mustoccasionallybereadjustedtoaccountforshiftingnetwork\nconditions.PHANTOMcansupportaretargetingmechanismsimilartoBitcoin\u2019s, 7NotethatanedgeintheDAGpointsbackintime,fromthenewblocktopreviously\ne.g.,readjusteverytimethatChn(G)growsby2016blocks. createdblockswhichitreferences.",
    "source":"whitepaper",
    "section":"AScalableGeneralizationofNakamotoConsensus (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":129.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_37",
    "content":"# AScalableGeneralizationofNakamotoConsensus (Part 2)\n\n--- Page 6 ---\n,, YonatanSompolinsky,ShaiWyborski,andAvivZohar\nimpliesthatifblockBwascreatedattimet,byhonestnodev, \u2022 ThefunctionRiskisthemaximalRisku overhonestnodes:\nthenpast(B)=Gv t . 8 Risk(B,t,r):= max Risku (B,t,r)\nSince these are the only two mining rules in our system, a u\u2208honest\nbyzantine behaviour of the attacker (which controls up to\u03b1 of Intuitively,trepresentsthetimeatwhichblockBwasincludedin\ntheminingpower)amountstoanarbitrarydeviationfromoneor theDAG,andt+rthetimeatwhichtransactionsinBcanbesafely\nbothoftheseinstructions. acceptedasnoconflictingoneswouldbeabletobypassthem.Inthe\nForconvenience,weadditionallyregardthevirtualblockofthe definitionabove,theprobabilityistakenoverallrandomeventsin\nDAG,virtual(G),whichisahypothetical(un-mined)blockwhich thenetwork,includingblockcreationandpropagation,aswellas\npointstotheDAG\u2019stipsasitsparents.Thus,past(virtual(G))=G. theattacker\u2019sarbitrarybehaviour.Theconvergencepropertybelow\nEssentially,virtual(G)representtheblocktemplateforthenext guaranteesthattheorderbetweenablockandthosesucceeding\nblocktobecreatedbytheminer,ifitishonest. it (or those not published yet) will not be reversed, w.h.p. This\ncapturesthesecurityoftheprotocol,asitprovideshonestnodes\n3.3 DAGclientprotocol with(probabilistic)securityguaranteesregardingpossiblereorgs.\nThe DAG as described so far possibly embeds conflicting Property1. Anorderingruleordissaidto(1-\u03b1)-convergeif\u2200t >0,\ntransactions. In our work, these conflicts are resolved via an \u2200u \u2208 honest and\u2200B \u2208 Gu: lim Risk(B,t,r) = 0, even when a\nordering protocol, namely, a protocol through which all nodes t r\u2192\u221e\nfraction\u03b1 oftheminingpowerisbyzantine.\nagreeontheorderofalltransactionsinthesystem.Wereferto\ntheorderingruleastheclientprotocol,aseveryparticipantinthe Ideally,wewouldwantRisk(B,t,\u00b7)tovanishexponentiallyfast\nnetworkcanruntheorderingprocedureonitsclientlocallywithout soastoensurespeedyconfirmationtimes.\nanyneedtocommunicateadditionalmessageswithotherclients.\nRemark. Property 1 essentially couples the Safety and Liveness\nOncesuchanorderisagreed,onecaniterateoveralltransactions\nproperties required from consensus protocols. Indeed, once",
    "source":"whitepaper",
    "section":"AScalableGeneralizationofNakamotoConsensus (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":142.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_38",
    "content":"# in the prescribed order and approve each transaction that is\n\nRisk(B,t,r)<\u03f5,adecisiontoaccepttransactionsinBcanbemade\nconsistentwiththoseapprovedsofar.Inthecasewheretransactions\n(Liveness),andisguaranteedtobeirreversible(Safety)uptoanerror\nrepresentpaymentsinBitcoin\u2019sUTXOmodel,atransactionwould\nprobabilityof\u03f5\u2014asinNakamotoConsensusandsimilarprotocols,",
    "source":"whitepaper",
    "section":"in the prescribed order and approve each transaction that is",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":5.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_39",
    "content":"# beconsistentwiththesetofpreviouslyapprovedtransactionsifits\n\ndecisionsareonlyirreversibleintheprobabilisticsense.Nevertheless,",
    "source":"whitepaper",
    "section":"beconsistentwiththesetofpreviouslyapprovedtransactionsifits",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":1.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_40",
    "content":"# inputsbelongtothissetandnoneoftheseinputsarealreadyspent\n\nweavoidphrasingourresultsintheseterms,forthesakeofclarityof\nbyanothertransactionintheset(i.e.,no\u201cdoublespend\u201d).However,\npresentation.Thecomplicationarisesfromtheneedtoanalyzethe",
    "source":"whitepaper",
    "section":"inputsbelongtothissetandnoneoftheseinputsarealreadyspent",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":3.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_41",
    "content":"# ourworkisagnostictotheprecisedefinitionsofthetransaction\n\nsystemfromtheperspectiveof everynodeGv;thistechnicalityis\nspaceandoftheunderlyingconsistencynotion\u2014forourpurpose, t\nnotuniquetoPHANTOM,andshouldberegardedinanyworkthat",
    "source":"whitepaper",
    "section":"ourworkisagnostictotheprecisedefinitionsofthetransaction",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":5.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_42",
    "content":"# sufficeittoregardanabstracttransactionspaceUandanabstract\n\nformalizesblockchainbasedconsensus(unlesspropagationdelays",
    "source":"whitepaper",
    "section":"sufficeittoregardanabstracttransactionspaceUandanabstract",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":1.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_43",
    "content":"# consistencyfunctionthatdetermineswhetherasetoftransactions\n\nareassumedtobenegligible).Weleavethetaskofbridgingthisgap\nT \u2286Uisconsistentornot.\ntoalaterversion.\nFormally,anorderingruleordtakesasinputablockDAGGand\noutputsalinearorderoverG\u2019sblocks,ord(G)=(B0,B1,...,B|G| ). Thesecuritythresholdistheminimalportionofthehashing",
    "source":"whitepaper",
    "section":"consistencyfunctionthatdetermineswhetherasetoftransactions",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":8.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_44",
    "content":"# Transactions in the same block are ordered according to their power that an attacker must acquire in order to disrupt the\n\nappearanceinit,andthisconventionallowsustotalkhenceforth protocol\u2019soperation:\nontheorderofblocksonly.Withrespecttoagivenruleord,we\nDefinition 3. The security threshold of an ordering ruleord is\nwriteB \u227a ord(G) C iftheindexofBprecedesthatofC inord(G); definedasthemaximal\u03b1 (attacker\u2019srelativecomputationalpower)\nweabbreviateandwriteB \u227a\nCorevenB \u227aCwhenthecontext\nforwhichord(1-\u03b1)-convergesexponentiallyfast.\nisunderstood.Forconvenience,weusethesamenotationB \u227a G C\nwhenB \u2208GbutC (cid:60)G.\n\n## 3.5 Mainresult",
    "source":"whitepaper",
    "section":"Transactions in the same block are ordered according to their power that an attacker must acquire in order to disrupt the",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":36.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_45",
    "content":"# Aprotocolisscalableifitissafetoincreasetheblockcreation\n\n## 3.4 Convergenceoftheorder\n\nrate\u03bbwithoutcompromisingthesecurity,thatis,ifthesecurity",
    "source":"whitepaper",
    "section":"Aprotocolisscalableifitissafetoincreasetheblockcreation",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":4.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_46",
    "content":"# The following definition captures the desired security of the (Part 1)\n\nthresholddoesnotdeteriorateas\u03bbincreases(thiscanbephrased\nprotocol,intermsoftheprobabilitythatsomeorderbetweentwo\nalsointermsofincreasingtheblocksizebratherthan\u03bb).\nblockswillbereversed.\nWeclaimthatGHOSTDAGisindeedascalableprotocol,inthis\nDefinition2. Fixaruleord,timet >0,andnodeu \u2208N. sense:\n\u2022 ForB \u2208Gu\n,Risku (B,t,r)isdefinedbytheprobabilitythat, Theorem4(GHOSTDAGscales). Givenablockcreationrate\u03bb>0,\nfromthepointofviewofu,ablockthatdidnotprecedeBin \u03b4 > 0, and Dmax > 0, if Dmax is equal to or greater than the\ntimet+r willlatercometoprecedeit: network\u2019spropagationdelaydiameterD,thenthesecuritythreshold\nRisku (B,t,r):=Pr (cid:16) \u2203s >t+r,\u2203C \u2208G s u :B \u227a G t u +r C\u2227C \u227a Gs u B (cid:17) o b f y G 1 2 H \u00b7 O (1 ST \u2212 D \u03b4 A ) G . ,parameterizedwithk(Dmax,\u03bb,\u03b4),islowerbounded\n\u2022 IfB(cid:60)Gu t wedefineRisku (B,t,r)=1. The parameterization of GHOSTDAG via k(Dmax,\u03bb,\u03b4) is\ndefined in the subsequent section. Theorem 4 encapsulates the\n8Technicallyitismoreaccuratetowritepast(B)=Gv\\{B},asablockdoesnot\nbelongstoitsownpastset. t mainachievementofourwork.Weprovethetheoremformallyin",
    "source":"whitepaper",
    "section":"The following definition captures the desired security of the (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":102.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_47",
    "content":"# The following definition captures the desired security of the (Part 2)\n\n--- Page 7 ---",
    "source":"whitepaper",
    "section":"The following definition captures the desired security of the (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_48",
    "content":"# PHANTOMGHOSTDAG\n\n",
    "source":"whitepaper",
    "section":"PHANTOMGHOSTDAG",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_49",
    "content":"# AScalableGeneralizationofNakamotoConsensus\n\nNovember10,2021",
    "source":"whitepaper",
    "section":"AScalableGeneralizationofNakamotoConsensus",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":1.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_50",
    "content":"# tto\n\n1\u2212\u03b4;theterm(cid:205)\u221e\nj=k \u02c6+1\ne\u22122\u00b7Dmax \u00b7\u03bb \u00b7 (2\u00b7Dm\nx \u00b7\u03bb)j from(2)bounds",
    "source":"whitepaper",
    "section":"tto",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":10.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_51",
    "content":"# theprobabilitythatmorethankblockswerecreatedinparallelto\n\n(e.g.,[15,19]):\nBinthetimeinterval[t\u2212Dmax,t+Dmax ].\nTheorem5(NakamotoConsensusdoesnotscale). Thesecurity Observethatblockscreatedintheintervals[0,t\u2212Dmax )and\nthresholdofNakamotoConsensusgoesto0asD\u00b7\u03bbgrows.\n(t+Dmax,\u221e),byhonestnodes,belongtoB\u2019spastandfuturesets,\nrespectively.Consequently,inprinciple, |anticone(B)| \u2264 k with\nFinally,wenotethatevenifDmax \u0338\u2265 D,thesystem\u2019ssecurity probabilityof1\u2212\u03b4 atleast.However,anattackercanartificially\ndoes not immediately break apart. Rather, the minimal power increaseB\u2019santiconebycreatingblocksthatdonotreferenceit\nneededtoattackthesystemgoesfrom50%(times(1\u2212\u03b4))to0, andbywithholdinghisblockssothatBcannotreferencethem.\ndeterioratingataratethatdependsontheerrorgapD\u2212Dmax .\nChain growth rate. The second motivation for (1) is potential\nmanipulations by attackers on the increase rate of the blue set.",
    "source":"whitepaper",
    "section":"theprobabilitythatmorethankblockswerecreatedinparallelto",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":54.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_52",
    "content":"# 4 SCALABILITYANDNETWORKDELAYS\n\n",
    "source":"whitepaper",
    "section":"4 SCALABILITYANDNETWORKDELAYS",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_53",
    "content":"# GHOSTDAG does not guarantee that discovering new blocks\n\n4.1 ThepropagationdelayparameterD necessarily increases the size of the blue set. Fortunately, by",
    "source":"whitepaper",
    "section":"GHOSTDAG does not guarantee that discovering new blocks",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":12.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_54",
    "content":"# max\n\nThe scalability of a distributed algorithm is closely tied to the increasing k, we are able guarantee that the adverse effect is\nassumptionsitmakesontheunderlyingnetwork,andspecifically arbitrarily small. Indeed, a worst case analysis carried out in\nonitspropagationdelayD = D(b)whereb istheblock-sizein Lemma9showsthattheoveralldecreaseisatmostbyafactorof\nKB.TherealvalueofDisbothunknownandsensitivetoshifting (cid:16) 1\u2212 2\u00b7C (cid:17) .Thisistheroleoftheright-handsizeterminside(2).\nk+2\u00b7C\nnetworkconditions.Forthisreason,Bitcoinoperatesunderthe Wenoteonecaveathere:theprobability 2\u00b7C doesnotvanish\nassumptionthatDismuchsmallerthan10minutes,andsetsthe\nexponentiallyfastwithk.Tofixthis,atighte",
    "source":"whitepaper",
    "section":"max",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":51.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_55",
    "content":"# alysisoftheeffect (Part 1)\n\naverageblockintervaltimeto10minutes.Whilethisseemslikean\noftheseattacksisneeded;weleavethischallengetofuturework.\noverestimationofthenetwork\u2019spropagationdelayundernormal\nconditions(atleastin2018\u2019sInternetterms),somesafetymargin\n4.3 Trade-offs\nmustbetaken,toaccountforpeculiarnetworkconditionsaswell.\nTheorem 4, and the parameterization of GHOSTDAG in (1), tie\nSimilarly,inPHANTOM(andGHOSTDAG)weassumethatthe\nu is n k k n n o o w w n n t D ot i h s e u p p r p o e t r oc b o o l u . n T d h e e d p b ro y t s o o c m ol e d D oe m s a n x ot = ex D p m li a c x it ( l b y ) e w nc h o ic d h e t b o y ge m th o e d r ify k i , n D g m o a n x e , p \u03bb a , ra a m nd et \u03b4 er . S (e t . r g iv ., in in g cr f e o a r si a ng be \u03bb tt t e o r o p b e t r a fo in rm la a r n g c e e r\nthroughputandmorefrequentblocks)mustbeunderstoodand\nDmax ,rather,itisusedtoparameterizek,aswillbedescribedin\nconsideredagainsttheeffectonallotherparameters.\nthenextsubsection.\nThe use of an a priori known bound Dmax distinguishes Increasedblockcreationrate.Althoughthesecuritythreshold\nGHOSTDAG\u2019s (and PHANTOM\u2019s) security model from that of does not deteriorate as \u03bb is increased, \u03bb cannot be increased\nSPECTRE[18].Whilethesecurityofbothprotocolsdependson indefinitely, or otherwise the network becomes congested. The\ntheassumptionthatthenetwork\u2019spropagationdelayDisupper value of \u03bb should be set such that nodes that are expected to\nbounded by some constant, in SPECTRE the value of such a participate in the system can support such a throughput. For\nconstantneednotbeknownorassumedbytheprotocol,whereas instance,ifnodesarerequiredtomaintainabandwidthofatleast\nGHOSTDAG makes explicit use of this parameter (viak) when 1MBpersecond,andblocksareofsizeb =1MB,thentheblock\norderingtheDAG\u2019sblocks.Thefactthattheorderbetweenany creationrateshouldbesetto\u03bb=1blockspersecond(thisismerely\ntwoblocksbecomesrobustinGHOSTDAG,butnotinSPECTRE, aback-of-the-envelopecalculation,andinpracticeothermessages\nshouldbeascribedtothisaddedassumption;seefurtherdiscussion consumethebandwidthaswell).\ninSection5. Higher security threshold. Theorem 4 states the security\nthresholdintermsof\u03b4.Following(1)wenoticethattighteningthe\n4.2 Theanticonesizeparameterk securitythreshold\u2013bychoosingalower\u03b4 \u2013requiresincreasing\nTheparameterkisdecidedfromtheoutsetandhard-codedinthe k.Alargekleadstoslowconfirmationtimes,aswillbediscussed\nprotocol.Itisdefinedasfollows:\nshortly.9\nk(Dmax,\u03bb,\u03b4):=min (cid:110) k \u02c6 \u2208N: f(k \u02c6 ,Dmax,\u03bb)<\u03b4 (cid:111) (1) L ne a e r d g s er to sa in f c e r t e y a m se a k rg as in w . e S l i l m in ila o r r l d y e , r if t D o m m a a x in i t s ai t n o t b h e e in sa c m re e as s e e d c , u o ri n ty e\nlevel(representedby\u03b4).\nf(k \u02c6 ,Dmax,\u03bb):=max \uf8f1\uf8f4\uf8f4\uf8f2\n\uf8f4\uf8f4 \uf8f3j=\n(cid:213) \u221e\nk \u02c6+1\ne \u22122\u00b7c \u00b7 (2\nc)j ,\nk \u02c6+\n\uf8fc\uf8f4\uf8f4\uf8fd\n\uf8f4\uf8f4 \uf8fe\n, (2)",
    "source":"whitepaper",
    "section":"alysisoftheeffect (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":426.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_56",
    "content":"# c th h a o\n\n",
    "source":"whitepaper",
    "section":"c th h a o",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_57",
    "content":"# t o\n\n",
    "source":"whitepaper",
    "section":"t o",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_58",
    "content":"# t s h e\n\n",
    "source":"whitepaper",
    "section":"t s h e",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_59",
    "content":"# e l\n\n",
    "source":"whitepaper",
    "section":"e l",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_60",
    "content":"# a c\n\n",
    "source":"whitepaper",
    "section":"a c",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_61",
    "content":"# r u\n\n",
    "source":"whitepaper",
    "section":"r u",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_62",
    "content":"# g r\n\n",
    "source":"whitepaper",
    "section":"g r",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_63",
    "content":"# e i\n\n",
    "source":"whitepaper",
    "section":"e i",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_64",
    "content":"# ty D\n\n",
    "source":"whitepaper",
    "section":"ty D",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_65",
    "content":"# o m f\n\n",
    "source":"whitepaper",
    "section":"o m f",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_66",
    "content":"# a B\n\n",
    "source":"whitepaper",
    "section":"a B",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_67",
    "content":"# x i\n\n",
    "source":"whitepaper",
    "section":"x i",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_68",
    "content":"# t i\n\n",
    "source":"whitepaper",
    "section":"t i",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_69",
    "content":"# c n\n\n",
    "source":"whitepaper",
    "section":"c n",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_70",
    "content":"# i o n\n\n",
    "source":"whitepaper",
    "section":"i o n",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_71",
    "content":"# d s\n\n",
    "source":"whitepaper",
    "section":"d s",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_72",
    "content":"# e c r h\n\n",
    "source":"whitepaper",
    "section":"e c r h",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_73",
    "content":"# a o\n\n",
    "source":"whitepaper",
    "section":"a o",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_74",
    "content":"# n r\n\n",
    "source":"whitepaper",
    "section":"n r",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_75",
    "content":"# d m\n\n",
    "source":"whitepaper",
    "section":"d m",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_76",
    "content":"# p a\n\n",
    "source":"whitepaper",
    "section":"p a",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_77",
    "content":"# e in\n\n",
    "source":"whitepaper",
    "section":"e in",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_78",
    "content":"# s n\n\n",
    "source":"whitepaper",
    "section":"s n",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_79",
    "content":"# t n\n\n",
    "source":"whitepaper",
    "section":"t n",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_80",
    "content":"# he t\n\n",
    "source":"whitepaper",
    "section":"he t",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_81",
    "content":"# s e a\n\n",
    "source":"whitepaper",
    "section":"s e a",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_82",
    "content":"# a f\n\n",
    "source":"whitepaper",
    "section":"a f",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_83",
    "content":"# s u\n\n",
    "source":"whitepaper",
    "section":"s u",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_84",
    "content":"# d m\n\n",
    "source":"whitepaper",
    "section":"d m",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_85",
    "content":"# e p\n\n.1 t\n0 i",
    "source":"whitepaper",
    "section":"e p",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":4.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_86",
    "content":"# o R\n\n",
    "source":"whitepaper",
    "section":"o R",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_87",
    "content":"# n e t\n\n",
    "source":"whitepaper",
    "section":"n e t",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_88",
    "content":"# c h\n\n",
    "source":"whitepaper",
    "section":"c h",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_89",
    "content":"# a a l\n\n",
    "source":"whitepaper",
    "section":"a a l",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_90",
    "content":"# t l\n\nwherec := Dmax \u00b7\u03bb. The motivation behind this definition is D \u00b7\u03bb \u226a 1,namely,thatw.h.p.atleastD secondspassbetween\ntwofold. consecutive blocks, so that forks are rare. Thus, Bitcoin\u2019s large\nNaturalanticonesize.First,wewanttodeviseaboundoverthe\nnumberofblockscreatedinparallel.Sincetheblockcreationrate 9Theadvancedreadershouldnoticethatalthoughincreasing\u03bbhasasimilarnegative\nfollowsaPoissonprocess,foranarbitraryblockBcreatedattime effectonk,ithasatthesametimeapositiveeffectonconfirmationtimes,andsoa\nt,k(Dmax,\u03bb,\u03b4)boundsthenumberofadditionalblockscreatedin",
    "source":"whitepaper",
    "section":"t l",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":32.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_91",
    "content":"# tim\n\n",
    "source":"whitepaper",
    "section":"tim",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_92",
    "content":"# fir\n\n",
    "source":"whitepaper",
    "section":"fir",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_93",
    "content":"# compromisethe (Part 1)\n\nthetimeinterval[t\u2212Dmax,t+Dmax ],withprobabilityofatleast securitythresholdoftheirsystem.",
    "source":"whitepaper",
    "section":"compromisethe (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":3.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_94",
    "content":"# compromisethe (Part 2)\n\n--- Page 8 ---\n,, YonatanSompolinsky,ShaiWyborski,andAvivZohar\nsafety margin over D suppresses its throughput severely as it Formally, we argue that GHOSTDAG enjoys the following\nrequires selecting a very low block rate \u03bb = 1\/600 (one block property:Givenapublishedblockb,theprobabilitythatanewly\nper10minutes).ThisisnotthecasewithGHOSTDAG\u2019sDAG,as addedblockinanticone(b)willbeacceptedasablueblockdecays\nthesecurityoftheDAGorderingdoesnotrelyontheassumption exponentially:\nD\u00b7\u03bb\u226a1.Therefore,evenifweoverestimateD,wecanstillallow\nfor very high block creation rates while maintaining the same Proposition6. Ifblocksbandcwerepublishedattimestandt+r,\nlevelofsecurity.Consequently,GHOSTDAGsupportsaverylarge respectively,andc \u2208anticone(b),thentheprobabilitythatcwillever\nthroughput,anddoesnotsufferfromasecurity-scalabilitytradeoff.\nbeconsideredblueisO(e\u2212C\u00b7r)forsomepositiveconstantC.\nThat said, in GHOSTDAG there is still a tradeoff between a\nProof. Lemma9impliesthatthenumberofadversaryblocks\nlargesafetymarginandfastconvergenceoftheprotocol.Agross\nthatareinthebluesetofanhonestnodeandnotinpast(B)grows",
    "source":"whitepaper",
    "section":"compromisethe (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":74.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_95",
    "content":"# ttle\n\nlinearlywithr.LetB\n= future(B)\u2229past(Br )whereBr isthe\nhonesttipofthenodejustbeforer.ThenforanyN andforany",
    "source":"whitepaper",
    "section":"ttle",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":7.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_96",
    "content":"# off\n\nsufficientlylarger itholdsthat|B\n| \u2264N +k.AllblocksinB",
    "source":"whitepaper",
    "section":"off",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":5.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_97",
    "content":"# are\n\ninanticone(C),foranyC \u2208anticone(B)thatwasdiscoveredafter",
    "source":"whitepaper",
    "section":"are",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":2.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_98",
    "content":"# and how applications such as payments can enjoy much faster (Part 1)\n\nconfirmationtimes.\nt+r:indeed,ifB\u2032\u2208B\nsatisfiesB\u2032<CthenB\u2032<B,andifC <B\u2032\nthenitwasdiscoveredbeforet +r.Therefore,ifBr remainsthe\nAnoteontheeffectivethroughput.Toincreasethenumberof honesttipattimet+r,thenCisnotinthebluesetofthehonest\ntransactionsincludedintheDAGpersecond,theprotocoldesigner node,asithasatleast|B\n| >kblueblocksinitsanticone.\ncanincreasetheblockrate\u03bbor\/andtheblocksizeb(whichinturn LetB\u2032beablocksuchthatC \u2208BlueSet(B\u2032),then|BlueSet(B\u2032)\u2229\naffectsDmax = Dmax (b)).However,ifhonestminersincludein B\n| \u2264k,orotherwiseCcannotbeinsideBlueSet(B\u2032).Thisproves\ntheirblockstheverysametransactions,thiswouldnotcontributeto thatforthehonestnodetoconsiderCblue,ablockB\u2032hastowin\nthenumberofuniquetransactionsincludedintheDAG,persecond. a block-race withBr \u2013 up to 3k blocks which it can freeload \u2013\nTherearetwoapproachestofixthis.Thefirstistoobservethat whichstartedatimet thelatestandlasteduptot+r atleast.The\nhonestandrationalminersareactuallyincentivizedtorandomize probabilityofwinningsuchablock-raceisinO(e\u2212C\u00b7r). \u25a1\noverthetransactionsavailabletotheminordertoavoid\u201ccollision\u201d\nandtotherebymaximizetheirownprofit;seemoreonthisin[12]. Infact,followingasimilaranalysistothatdevelopedin[17,18],",
    "source":"whitepaper",
    "section":"and how applications such as payments can enjoy much faster (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":49.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_99",
    "content":"# Thesecondapproachistoshardthetransactionspaceandallow theprobabilityofCbecomingblueis\n\ntheblocktocontaintransactionsfromoneshardonly,inaway\nthatguaranteesthatparallelblockswillnotcollideonthesame (cid:213) \u221e (cid:18) m+N +k\u22121(cid:19) \u00b7\u03b1m\u00b7(1\u2212\u03b1 \u2032)N+k \u00b7 (cid:16) \u03b1 (cid:17)max(N\u2212m,0)\nshard,withhighprobability.Thistechniquewasusedinsomeofthe m=0 m 1\u2212\u03b1\u2032\nworksmentionedinSection7,under\u201cParallelNakamotoChains\u201d.\nwhere1\u2212\u03b1\u2032=(1\u2212\u03b1)\u00b7(1\u2212\u03b4)asderivedinLemma9.Thisimplies,\nBothtechniquescanbedeployedinGHOSTDAG.Consequently,\npractically,thatamerchantwhoreceivedapaymentinablockB,",
    "source":"whitepaper",
    "section":"Thesecondapproachistoshardthetransactionspaceandallow theprobabilityofCbecomingblueis",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":21.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_100",
    "content":"# increasingtheblockrateorblocksizedoesindeedleadtoalinear\n\n",
    "source":"whitepaper",
    "section":"increasingtheblockrateorblocksizedoesindeedleadtoalinear",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_101",
    "content":"# listenstotheblockDAGandseesnoconflictingpaymentinany\n\nincreaseintheeffectivethroughput.\nblockinB\u2019santicone,canacceptthepaymentwhenthelatterterm\nbecomes smaller than\u03f5 (- the error probability allowed by the\n5 CONFIRMATIONTIMES merchant).\nAs in Nakamoto Consensus, the waiting time for transaction Forexample,iftheblockcreationrateissetto\u03bb=1blockper\nconfirmation depends on the assumed attacker size \u03b1, and on second,andtheassumedupperboundonthenetwork\u2019sroundtrip\ntheallowederror\u03f5.ThesecurityanalysisgiveninAppendixA time(2\u00b7D)is7seconds,thenkcansafelybesetto16.Assumingan\nshowsthatwithinconstantexpectedtimethechainofthehonest attackerwith\u03b1 \u22640.25,andanallowederrorof\u03f5 =0.1%(thevalues",
    "source":"whitepaper",
    "section":"listenstotheblockDAGandseesnoconflictingpaymentinany",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":42.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_102",
    "content":"# networkentersintoablockracewithanyhypotheticaloractual oftheseparametersmustbeassumedinNakamotoConsensusas (Part 1)\n\nattackerchain.Itisimpliedthatthewaitingtimefortheordering well),thewaitingtimefortransactionconfirmationwouldbein\nbetweenagivenblockBandotherblocksbecomesrobustatarate theorderof45seconds.Notethatiftheactualnetworkdelayis\nofO (cid:16) log\n(1\/\u03f5) (cid:17) .Thisanalysiswasasymptotic,andweleavethe smallerthanthe7secondsbound\u2013say,below4seconds,asin\n1\u2212\u03b1 Bitcoin\u2019sRelayNetwork[1]\u2013thenthewaitingtimewillremainthe\ntaskoftighteningtheanalysisandimprovingtheconstants(hidden\nsame.ThisdemonstratesthatGHOSTDAGisnotresponsivetothe\nintheO)forfuturework.\nactualnetworkdelay.Forcomparison,underthesameconditions,\nStill,weobservethatinthecaseofpayments,transactionsof\nSPECTRE\u2019swaitingtimewouldbeintheorderof21seconds.Thisis\nhonestuserscanbeconfirmedmuchfaster.Indeed,anhonestuser\nduetoSPECTREnotassuminganyupperboundwithintheprotocol,\nwillnotpublishaconflictingtransaction,andhertransactionwill\nwhichenablesittoberesponsive.\nthereforebecommutativewithallotherpublishedtransactions.\nOfcourse,thepayeedoesnotknowaprioriwhoofthepayersis\n6 IMPLEMENTATION:THEKASPA\nhonest,andwillthuswaituntiltheblockcontainingthetransaction\nis guaranteed (w.h.p.) to precede any new block that might be NETWORK\npublishedbytheattacker.Blocksthatarepublishedintheinterim Kaspa is a cryptocurrency which operates over an open\nwillnotcontainaconflictingtransaction,inthecaseofanhonest source implementation of the GHOSTDAG protocol [2]. This\npayer,andwillthereforenotdelayacceptance. implementationincludesanentirerangeoftoolsusefultomonitor,",
    "source":"whitepaper",
    "section":"networkentersintoablockracewithanyhypotheticaloractual oftheseparametersmustbeassumedinNakamotoConsensusas (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":61.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_103",
    "content":"# networkentersintoablockracewithanyhypotheticaloractual oftheseparametersmustbeassumedinNakamotoConsensusas (Part 2)\n\n--- Page 9 ---",
    "source":"whitepaper",
    "section":"networkentersintoablockracewithanyhypotheticaloractual oftheseparametersmustbeassumedinNakamotoConsensusas (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_104",
    "content":"# PHANTOMGHOSTDAG\n\n",
    "source":"whitepaper",
    "section":"PHANTOMGHOSTDAG",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_105",
    "content":"# AScalableGeneralizationofNakamotoConsensus\n\nNovember10,2021\nTable1:Percentageoftransactionapprovedwithingiven\nperiods of time of the transactions described in fig. 4.\nAlltransactionswereeventuallyconfirmed.Thelargest\nobservedfirstconfirmationtimeis746second.\nWaittime 1s 2s 3s 4s 5s 10s",
    "source":"whitepaper",
    "section":"AScalableGeneralizationofNakamotoConsensus",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":21.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_106",
    "content":"# Approval\n\n5.3% 27.8% 43.6% 53.1% 59.3% 70,4%",
    "source":"whitepaper",
    "section":"Approval",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":6.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_107",
    "content":"# rate\n\nWaittime 30s 1m 2m 5m 10m",
    "source":"whitepaper",
    "section":"rate",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":6.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_108",
    "content":"# Approval\n\n80.7% 86.4% 92.2% 99.5% 99.9%",
    "source":"whitepaper",
    "section":"Approval",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":5.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_109",
    "content":"# rate\n\n",
    "source":"whitepaper",
    "section":"rate",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_110",
    "content":"# 7 RELATEDWORK\n\n",
    "source":"whitepaper",
    "section":"7 RELATEDWORK",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_111",
    "content":"# Many suggestions to improve the scalability of permissionless (Part 1)\n\nFigure 4: A histogram of the elapsed waiting time blockchainshavebeenproposedinrecentyears.Theseproposals\nfor a first confirmation of 458,557 transactions. The fallintotwomaincategories,on-chainscalingandoff-chainscaling.\nhorizontal axis is confirmation time in seconds, the\nOn-chainscaling.Theprotocolsinthiscategorymaydiffer,e.g.,\nverticalaxisisthenumberoftransaction(notethatthe\ninhowfastblocksarecreated,howblocksareorganizedinthe\nverticalaxisislogscaled).\nledger (a chain, a tree, a DAG, etc.), which transactions in the\nledgerareconsideredvalid,andmore.PHANTOMbelongstothis\ntest and analyze the network. Among these tools are a block lineofworks.Previousworksinthisfamilyofprotocolsincludes\nexplorer[4],agraphinspector[3]andaperformancedashboard GHOST[19],whereamainchainofblocksischosenaccording\n[5]whichmonitorsquantitiesofinterestsuchastheglobalhash to a greedy algorithm and not through the longest chain rule;\nrate,transactionthroughputandcombinatorialpropertiesofthe Inclusive[12],whereanychain-selectionruleisextendedtoan\nDAGsuchaswidthandtipcount. orderedDAGandtransactionsoffthemainchainareaddedina\nTheKaspaimplementationalsoincludesfeaturesnotdiscussed consistentmanner;BitcoinNG[7],wheretheledgerconsistsof\ninthecurrentworksuchasdifficultyadjustmentandalgorithmic slowkeyblocks(containingnotransactions)andfastmicroblocks\nsolutionforefficientcomputationofallrequiredquantitiessuchas thatcontaintransactions.ThesolepurposeofkeyblocksinBitcoin\ntheblueanticone. NGistodefinetheminerthatiseligibletocreatemicroblocksin\nUnlikesimpleproofofconceptsimulations,theKaspanetwork thatepochandconfirmthustransactionsatahighrate.\nprovidesevidenceofthefeasibilityofGHOSTDAGinrealworld GHOSTisstillsusceptibletosomeattacks,oneofwhichwas\nsituationswheretheglobalhashratefluctuates,thenetworkminers describedin[11].TheDAGinInclusiveaddsthroughputbutnot\nareorganicallyspread11,nodesarerequiredtosynchronizeand\nsecuritytothemainchain,hencesuffersfromthesamelimitations\nverifyblocksreasonablyfast,andthenetworkhasbeenrunning astheunderlyingmainchainselectionrule.KeyblocksinBitcoin\nforextendedperiodsoftime. NGarestillgeneratedslowly,thusconfirmationtimesremainhigh.\nAtitscurrentstate,thefullyoperationalnetworkeasilyhandles Our work is most similar to the SPECTRE protocol [18].\na throughput of 40 transactions per second, where the average SPECTRE enjoys both high throughput and fast confirmation\nwaitingtimeforasingleconfirmationisoftheorderofseconds.We times.ItusesthestructureoftheDAGasrepresentinganabstract\nstressthatathroughputof40transactionpersecondislargerthan voteregardingtheorderbetweeneachpairofblocks.Onecaveat",
    "source":"whitepaper",
    "section":"Many suggestions to improve the scalability of permissionless (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":127.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_112",
    "content":"# thehighestthroughputeverwitnessedonboththeEthereumand of SPECTRE is that the output of this pairwise ordering may\n\nBitcoinnetworks,whoseconfirmationtimesarelongerbyorders not be extendable to a total order, due to possible Condorcet\nofmagnitude. cycles.AnotherrelatedcaveatisthatSPECTREdoesnotguarantee",
    "source":"whitepaper",
    "section":"thehighestthroughputeverwitnessedonboththeEthereumand of SPECTRE is that the output of this pairwise ordering may",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":14.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_113",
    "content":"# WeemphasizethatthenodesrunningontheKaspanetwork convergence of the ordering between two blocks that were\n\narefullyoperational,andfurnishallservicesrequiredforareal publishedintimeproximitytooneanother.Thisweak liveness\nworldcryptocurrency.Theperformancedataofthenetworkshould propertyisshowedtosufficefortheusecaseofpayments,where",
    "source":"whitepaper",
    "section":"WeemphasizethatthenodesrunningontheKaspanetwork convergence of the ordering between two blocks that were",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":5.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_114",
    "content":"# notbecomparedagainstconsiderablysimplifiedproofofconcept conflicts in two such blocks can only harm a malicious user (Part 1)\n\nsimulations. that published a double spend. PHANTOM solves these issues\nWetestedtheconfirmationtimesofthenetworkbygenerating and provides a linear ordering over the blocks of the DAG. As\natotalof458,557transactionsandmeasuringhowlongbeforeeach such,PHANTOMcansupportconsensusregardinganygeneral\ntransactiongotafirstconfirmation.Theresultsaresummarizedin computation,includinggeneralSmartContracts,whichSPECTRE\nfig.4andtable1. cannothandle.Indeed,inorderforacomputationorcontractto\nbeprocessedcorrectlyandconsistently,thefullorderofevents\n11atthetimeofwriting,atleast30%oftheKaspaminingiscarriedoutbypartiesother\nthantheoriginaldevelopers in the ledger is usually required, and particularly the order of",
    "source":"whitepaper",
    "section":"notbecomparedagainstconsiderablysimplifiedproofofconcept conflicts in two such blocks can only harm a malicious user (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":43.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_115",
    "content":"# notbecomparedagainstconsiderablysimplifiedproofofconcept conflicts in two such blocks can only harm a malicious user (Part 2)\n\n--- Page 10 ---\n,, YonatanSompolinsky,ShaiWyborski,andAvivZohar\ninputs to the contract.12 PHANTOM\u2019s linear ordering does not tightanalysisofitsconfirmationtimes,acomparisonbetweenit\ncomewithoutcost\u2014confirmationtimesaremushslowerthanthose andothergreedyalgorithmsthatapproximatePHANTOM,anda\ninSPECTRE.InSection5wediscusstheconfirmationtimesin securityanalysisoftheoriginalPHANTOMprotocolwhichwasn\u2019t\nPHANTOMcomparedtothoseofSPECTRE,whentheuserdoes providedinthiswork.\nnotpublishavisibledoublespend.\nParallelNakamotoChains.Anotherlineofworkattemptsto",
    "source":"whitepaper",
    "section":"notbecomparedagainstconsiderablysimplifiedproofofconcept conflicts in two such blocks can only harm a malicious user (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":24.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_116",
    "content":"# A GHOSTDAGSCALABILITYPROOF\n\navoidthescalability-securitytradeoffimposedbythelongestchain\nWepresentaproofthattheGHOSTDAGorderconverges,andthat\nrulebydividingtheledgerintokseparateNakamotochains[6,8,\nanattacker(withlessthan50%oftheglobalhashrate)isunableto\n20].Thebasictechniquebehindtheseprotocolsistoassignablock\ncausereorgs.WerestatethetheoremfromSection3:\ntooneofthechainsonlyafteritwassuccessfullymined,usingthe\nproof-of-workrandomnessrepresentedin(thehashof)itsheader.",
    "source":"whitepaper",
    "section":"A GHOSTDAGSCALABILITYPROOF",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":8.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_117",
    "content":"# Thisrandomnessensuresthatanattackercannotchoosewhich (Part 1)\n\nTheorem4(GHOSTDAGscales) Givenablockcreationrate\u03bb>0,\nchaintoconcentrateitsattackon.Onewaytoviewtheseprotocols \u03b4 > 0, and Dmax > 0, if Dmax is equal to or greater than the\nandcomparethemagainstPHANTOM(andGHOSTDAG)isthat network\u2019spropagationdelaydiameterD,thenthesecuritythresholdof\nNakamotoConsensusoperatesundertheassumptionthatD\u00b7\u03bb\u226a1, GHOSTDAG,parameterizedwithk(Dmax,\u03bb,\u03b4),isatleast 1 2 \u00b7(1\u2212\u03b4).\nPHANTOMundertheassumptionthatD\u00b7\u03bb\u226ak,andtheseparallel Assumptionsandnotations.Wefirstremindthereaderthatthe\nchainprotocolsunderD\u00b7\u03bb\/k \u226a1;indeed,bydividingtheprotocol topologyoftheDAGisregardedinourcontextinreversetothe\nintokseparatechains,eachchainisminedatarateof\u03bb\/k,andthis usualconvention,namely,ifthereisapathfromablockBtoablock\ninequalityensuresthateachchainenjoysanegligibleorphanrate CwesaythatCisaparentofB,whereasmostliteratureconcerning\nsimilarlytoNakamotoConsensus. DAGswouldsaythatB isaparent(orpredecessor)ofC.Inour\nProtocolsinthisparadigmmustspecifytheorderoverblocksin contextblocksalwayspointtoolderblocks,sothisanti-convention\ntheledgerofparallelchains.Theperformanceoftheseprotocols isbiologicallyjustifiedwhereastheconventionalterminologyis\ndependsontheirrespectiveorderingrules,andwedifferthetask misleading.",
    "source":"whitepaper",
    "section":"Thisrandomnessensuresthatanattackercannotchoosewhich (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":44.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_118",
    "content":"# ofrigorouslycomparingthemtoGHOSTDAGtothefullversionof Weassumeaworstcasebyzantineattackerwhichsuffersno\n\nthispaper. internal delays or delays from or to honest nodes, and which\ndeviatesfromtheminingprotocolarbitrarily(seedefinition).Still,\nAn attack on a previous variant. The work in [13]\nregardlessofanyattackerinterventioninthenetwork,shecannot\npresents a DAG-based protocol Conflux, which is identical\nto Inclusive-GHOST [12, 19]. In the appendix section of [13]",
    "source":"whitepaper",
    "section":"ofrigorouslycomparingthemtoGHOSTDAGtothefullversionof Weassumeaworstcasebyzantineattackerwhichsuffersno",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":42.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_119",
    "content":"# causemessagesbetweenhonestnodestotakelongerthanDmax to (Part 1)\n\nthereappearsanattackonapreviousversionofPHANTOM.In\npropagate.Inthesequel,toavoidclutter,weuseDinsteadofDmax\ntodenotetheboundonthenetworkdelay(notethatinprevious\nthatversion,thegreedyalgorithminheritedthebluesetS ofthe\nmaximaltip,andaddedblockstoS aslongastheiranticonein\nsectionsDwasusedtodenotetheactualdelay).\nWhendiscussingthehonestnetwork,wefixanarbitraryhonest\nS wasofsizek orless.Thefactthatthegreedyalgorithm\u2013in\ncontrasttovanillaPHANTOM\u2013didnotattemptatenforcingthe nodeu \u2208honest andassumeitspointofview,wherebytermssuch\nk-cluster property on the chosen set of blue blocks was shown\nasthehonestchainshouldbeinterpretedfromu\u2019spointofview.\nin[13]tobeexploitable.Thegreedyalgorithmpresentedinthis\nTothateffect,bythehonest(attacker)tipsattimet wemeanall\nimmediateparentsofthevirtualblockofthehonest(attacker)node\nupdated version of the paper, GHOSTDAG, does enforce the\nk-clusterproperty;weutilizethisfacttoproveitscorrectness.We\nattimet,bythehonest(attacker)chainwemeantheselectedchain\nthanktheauthorsof[13]forhighlightingthissubtlety.\nofthevirtualblock,andbythehonest(attacker)bluesetwemean\nthebluesetofthevirtualblockofthehonest(attacker)node.\nOff-chainscaling.Ourworkisorthogonalandcomplementary",
    "source":"whitepaper",
    "section":"causemessagesbetweenhonestnodestotakelongerthanDmax to (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":47.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_120",
    "content":"# Theattackerdoesnotfollowtheconsensusrulesandinparticular\n\nto off-chain scaling solutions, and can enhance their operation\nmaycreateablockwhichpointsatblockswhicharenottips,and\nby orders-of-magnitude. For instance, when the DAG is used\nwithholdanyblockstheycreate.Hence,weseparatebetweenthe\nto serve channel-settlement transactions of Bitcoin\u2019s Lightning\ntimeablockwascreated(bytheattacker)andbythetimeitwas\nNetwork[16],itallowsforamuchcheaperaccess(duetolarger\ndiscovered(bythearbitraryhonestnodeu).\nsupplyofblocksandcapacity)andmuchfasterprocessingthanif\ntheLNwereoperatingoverachain.\nThehonestscorewH (t)isdefinedasthescoreofthevirtualblock\nofthehonestnodeattimet.TheadvantageofablockBisdefined",
    "source":"whitepaper",
    "section":"Theattackerdoesnotfollowtheconsensusrulesandinparticular",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":35.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_121",
    "content":"# 8 DISCUSSION (Part 1)\n\nasadv(B)=score(B)\u2212wH (t),wheret isthetimeBwascreated.\nTheattackeradvantageadv(t)isthemaximumofadv(B)overall\nInthisworkwehaveintroducedthePHANTOMparadigm,which attackertipsattimet.ForagivenblockB,wedefinetherelative\ngeneralizesoverNakamoto\u2019schainintoaDAG,andwhichimposes advantageadvB (t)tobethemaximumofadv(B)overallattacker\nnoaprioriconstraintoverthesystem\u2019sthroughput,thusavoiding tipsattimet suchthatB isnot intheirselectedchain(or\u2212\u221eif\nthescalability-securitytradeoffimposedbyNakamotoConsensus. therearenone).WesaythatBconvincedthehonestnodeattimet\nWe described a greedy algorithm, GHOSTDAG, which is more ifitwasdiscoveredbeforet\u22122Dandwasintheselectedchainat\npracticaltoimplement,andproveditssecurityrigorously.There timet.\narestillseveralopenresearchquestionsregardingGHOSTDAG:a WeuseB \u2192 C todenotethatC isanimmediateparentofB\n12Contractsthatdonotrequiresuchastrictorderingcanindeedbeservedunder andB \u21d2C toindicatethatitisaselectedparent.WeuseC < B\nSPECTREaswell. todenotethatC \u2208 past(B)andC <\u22c6 B todenoteatC isinthe",
    "source":"whitepaper",
    "section":"8 DISCUSSION (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":48.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_122",
    "content":"# 8 DISCUSSION (Part 2)\n\n--- Page 11 ---",
    "source":"whitepaper",
    "section":"8 DISCUSSION (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_123",
    "content":"# PHANTOMGHOSTDAG\n\n",
    "source":"whitepaper",
    "section":"PHANTOMGHOSTDAG",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_124",
    "content":"# AScalableGeneralizationofNakamotoConsensus (Part 1)\n\nNovember10,2021\nselectedchainofB.WeuseC \u2264BandC \u2264\u22c6Btodenotethesame, Proof. AssumethatablockBwaspublishedthatcausedwH\nwiththepossibilitythatB=C. todecrease.LetB\u2032bethehonestselectedtiprightbeforeB was\nWedefinemanyconstantsthroughouttheproofwiththeproviso published. We must have that B\u2032 \u226e B and that score(B) \u2265\nthattheyonlydepend\"onsystemparameters\",bywhichwemean score(B\u2032),thenthereductioninscoreisatmosttheamountof\nthattheyonlydependon\u03bb,Dandk(andnotont,ontheparticular blocksinanticone(B\u2032)thatthevirtualnodeconsideredbluebefore\nDAGstructureofanynode,etc.). B wasdiscovered,andredafterB wasdiscovered.Inparticular,\nProofStructure.Duetothedefinitionofsecuritythresholdin anysuchblockmusthaveananticonelargerthank.Ifallblocks\nDefinition3,Theorem4reducestothefollowingproposition. arehonestthentheprobabilityofthisisatmost\u03b4;thisfollows\nProposition7(GHOSTDAGsecurity). Foranyt,r,theprobability T fr h o i m sp D r m ov a e x s \u2265 th D et a h n e d or f e ro m m fo k r (D th , e \u03bb, s \u03b4 p ) e m cia o l n c o a to se ni o c f al a l n yi a n t c ta re c a k s e i r n w gi h n ic D h .\nthattheorderingoftwoblockspublishedbeforetimet willchange indefinitelywithholdstheirblocks.\nafter time t +r is O(e\u2212cr), wherec depends only on the system Togeneralizetotheadversarialsetting,weneedtoarguethe\nparameters. mostdamageanattackercancausetothebluescorebywithholding\nIn terms of Section 3, Proposition 7 states that Risku (B,t,r) blocks.AssumethatattimetablockCwasdiscoveredthatreduced\ndecaysexponentiallyfast,ataratewhichdoesnotdependonu thebluescore,andletBbethehonestselectedtiprightbeforeC\nort.ThisimpliesthatRisk(B,t,r)decaysatthesamerate,andin waspublished.IfB <\u22c6Cthenscore(C)>score(B),contradicting\nparticularthattheGHOSTDAGorderingrule(1\u2212\u03b1)-converges. thehypothesis.ItfollowsthatC \u2192Bcanonlyincreasescore(C),so\nThecorrectnessofthisProposition7followsfromthefollowing wemayassumewithoutlossthatC \u0338\u2192B.Itfollowsthatscore(C)\u2265\nproposition: score(B),forelseBwouldhaveremainedthehonestselectedtip\nandthescorecouldnothavedecreased.\na P to d r v \u2212 o B p \u221e ( o t s e ) x i i t p s i o o b n o n e u n 8 n t . d ia A f l r l s o y s m u f m a a s b e t. o t 1 v h 3 e a . t b B ya co M nv a i r n k c o e v d ia th n e p n ro e c tw es o s r o k n a Z tt w im h e ic t h ,t g h o e e n s w be e L r d e e e t fi in n n B e th d b e e s h im t o h n i e l e a n s r t u ly m bl f b u o e e r r C w o , h f t e b h n l e u n B e t b w h l e o as c d k t e s h c e r in e s a e t s h l e e e c i t a n e n d s t c i t c o i o p r n e , e a i n s o d a f t B le m t th o n a s C t t\nThefollowingtwolemmas,whichareofindependentinterest, nB \u2212nC .However,notethatiftheselectedchainofCcontainsless\narepartoftheproofofProposition8.Thefirstlemmastatesthat thank blocks above max(SelectedChain(B)\u2229SelectedChain(C))\nthegrowthrateofthebluescoreofthepublicchainis1\u2212\u03b1,upto thennB \u2265nC (asanyblockinanticone(B)couldbeablueblock,\nafactorarbitrarilycloseto1: uptokblocks),andthescoreactuallydidnotdecrease.\nItfollowsthattheadversarygainsthemostbypublishingk+1\nLemma 9. The expected value ofwH (t +r)\u2212wH (t) is at least",
    "source":"whitepaper",
    "section":"AScalableGeneralizationofNakamotoConsensus (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":451.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_125",
    "content":"# blocksintheanticoneoftheselectedparentsuchthatthemost\n\n(1\u2212\u03b1)(1\u2212\u03b4)r\u03bb.",
    "source":"whitepaper",
    "section":"blocksintheanticoneoftheselectedparentsuchthatthemost",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":1.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_126",
    "content":"# recentpublishedblockhasscoreatleastaslargeasthatofthe\n\nThe next lemma states that the attacker\u2019s advantage can be selectedparent.Thiswillcausethehonestnetworktoswitcha\ncappedwithhighprobability: chain,suchthatalltheblocksintheanticoneoftheoldselected\nparent,exceptthek+1blockspublishedbytheadversary,willbe\nLemma10. Theadvantageadv(t)isupperboundedbyastochastic\nconsideredred(astheyareallintheanticoneofthepublishedk+1",
    "source":"whitepaper",
    "section":"recentpublishedblockhasscoreatleastaslargeasthatofthe",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":17.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_127",
    "content":"# processwhichadmitsastationarydistributionwithanexponentially (Part 1)\n\nblocks,whichareblue).Onaverage,thereareatmost2D\u03bbsuch\ndecayingtail.\nblocks,sothattheadversaryhasmanagedtoreplacek+2D\u03bbblue\nBluesetgrowth.Inthissectionwediscussthenonmonotonicity blockswithk+1blueblocks.\nofthechainweightandproveLemma9. Thisimpliesthatthehighestfactorbywhichtheadversarycan\nInNakamotoConsensusthelongestchainischosen,anditis reducethegrowthofthehonestbluesetis k =1\u2212 2D\u03bb .\nk+2D\u03bb k+2D\u03bb\nthereforeimpossibleforanadversarytoreducethelengthofthe Let\u03b40 betheprobabilitythataparticularhonestblockhasan\nlongestchainbypublishingblocks.Statedotherwise,thescoreof honestanticonelargerthank.Itfollowsthattheexpectedvalue\no ofwH (t)\u2212wH (s)isatleast(1\u2212\u03b1)(1\u2212\u03b40) (cid:16) 1\u2212\n(cid:17) (t\u2212s)\u03bb>\n(1\u2212\u03b1)(1\u2212\u03b4)(t\u2212s)\u03bb,wherethelastinequalityholdsbyequation2\nblocks,thebluescoreofthevirtualnodeactuallydecreases.This\ninthedefinitionofk. \u25a1\nmighthaveanadverseeffectonthegrowthoftheblueset,thatis,of\nthescoreofthehonestnetwork.Thisadverseeffectisboundedbya FreeloadingandBoundedAdvantage.Inthissectionweprove\nconstantfactorof (cid:16) 1\u2212 2D\u03bb (cid:17) whichisalreadybuiltinto\u03b4 inthe Lemma10,byareductiontotheanalysiscarriedin[18].Themain\nk+2D\u03bb\ndefinitionofthesecuritythreshold(1).Thatthisistheappropriate challengeinthisreductionisthattheattackermayusethework\nfactorisexactlythestatementofLemma9,whichwenowprove. donebythehonestnetworktoboostthescoreoftheircompeting\nchain,byincludinghonestblocksinthebluesetofthechaintip.\nLemma 9. The expected value ofwH (t +r)\u2212wH (t) is at least Wecallthisphenomenonfreeloading,moreformally:\n(1\u2212\u03b1)(1\u2212\u03b4)r\u03bb. Definition11. WesaythatC \u2208 A is freeloadingoffB \u2208 H if\n13InthesamesensethatarandomwalkonZwhichisbiasedtotheleftgoesto\u2212\u221e B \u2208BlueSet(C),andC\u2032<\u22c6CimpliesB(cid:60)BlueSet(C\u2032).\nexponentiallyfast.Thatis,ifTisthetransitionoperatorandpisafinitelysupported",
    "source":"whitepaper",
    "section":"processwhichadmitsastationarydistributionwithanexponentially (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":76.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_128",
    "content":"# It turns out that the advantage an attacker can gain by\n\ndistributiononZ,thenforanyN \u2208Zitholdsthat\u2225\u03a0[N,\u221e)TO(N)p\u22251=O(cN)for",
    "source":"whitepaper",
    "section":"It turns out that the advantage an attacker can gain by",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":2.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_129",
    "content":"# freeloading is bound by a constant depending only on system (Part 1)\n\ns p o ro m b e ab c i o l n it s y ta \u03b1 nt < c 1 < \/2 1 ) (whichis 1\u2212 \u03b1 \u03b1 forarandomwalkwhichtransitionsrightwith parameters.",
    "source":"whitepaper",
    "section":"freeloading is bound by a constant depending only on system (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":32.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_130",
    "content":"# freeloading is bound by a constant depending only on system (Part 2)\n\n--- Page 12 ---\n,, YonatanSompolinsky,ShaiWyborski,andAvivZohar\nLemma12(TheFreeloaderBound). IfCisfreeloadingoffBthen thatthestationarydistributionisgovernedbyanexponentwith\nscore(C)\u2264score(B)+4k. base \u03b1 ratherthan \u03b1 .Secondly,theanalysistherein\n(1\u2212\u03b1)(1\u2212\u03b4) (1\u2212\u03b1)\nassumesthatnofreeloadingoccurs.Fortunately,theFreeloader\nProof. FirstnotethatifC \u21d2Bthenscore(C) \u2264score(B)+k,\nBoundguaranteesthatiftheselectedtipattimet wasfreeloading,\nasGHOSTDAGdoesnotaddmorethankblueblockstoC\u2019sblue\nadv(t)isboundedbyaconstant3k.Therefore,byassumingthe\nsetoverthatofitsselectedparentB.Wesubsequentlytreatthecase\nattackeralwaysmanagestosaturatethisconstant,sothattheir\nwhereC \u0338\u21d2B.LetD <\u22c6C bemaximalsuchthatD < B(thisset advantagenevergoesbelow3k,wecanshifttheprocessadv\u2032(t)\nis not empty as it contains the genesis block).Thenscore(B) >\nby3kandanalyzeitasablockrace,utilizingtheresultfrom[18].\nscore(D). We show below that score(C) \u2212score(D) \u2264 3k + 1\nandconcludethatscore(C) \u2264 score(B)+3k.Notethefollowing\nobservations:\nTheMarkovianProcess.Inthissectionweprovetheexistence\n\u2022 score(C)\u2212score(D)\u2264 |BlueSet(C)\\past(D)|, oftheMarkovianprocessdescribedinLemma8.Inordertodo\n\u2022 BlueSet(C)\\past(D)\u2282 D1\u222aD2\u222aD3\u222aD4 where:D1 = so, it is illuminating to first consider how one might prove the\npast(C)\u2229future(B),D2 =past(B)\u2229future(D),andD3 = livenesspropertyofGHOSTDAGinthenon-adversarialsetting.In\npast(C)\u2229anticone(B). thissetting,itiseasiesttodemonstratelivenessbytheemergence\n\u2022 SelectedChain(C)\u2229 future(D) (cid:44) \u2205:thecontraryimplies ofsocalledhourglassblocks.\nthatC \u2192D.However,thatB <Cimpliesthatthereissome\nC \u2192 B\u2032 such that B \u2264 B\u2032. Butscore(B\u2032) \u2265 score(B) > Definition13. AblockBdiscoveredintimetiscalledanhourglass\nscore(D),whichimpliesC \u0338\u21d2D,contradictingD <\u22c6C.\nblockifitistheonlyblockdiscoveredbetweent\u22122Dandt+2D.\nNow, let E1,E2 be the maximal and minimal elements of Lemma 14. In the non-adversarial setting where all miners are\nSelectedChain(C)\u2229future(D)respectively.Ifitdoesnotholdthat honest,ifanhonesthourglassblockwascreatedattimet,thenthe\nC \u21d2E1 thentheremustbeablockbetweenthem,contradicting orderingofblockscreatedbeforet willremainunchangedaftert.\nthemaximalityofE1 .Similarly,E2 \u21d2D.IfD1 intersectspast(E1)\nthen B < E1 , contradicting the minimality ofC. Assume D1 \u2208 Proof. LetBbethehourglassblockcreatedattimet.IfB\u2032was\nD1\u2229future(E1),thenscore(E1) <score(D1)andsinceD1 <C createdbeforet,thenbyhypothesisitwascreatedbeforet\u22122D,so\nwe get thatC \u0338\u21d2 E1 , which is a contradiction. Similarly, if D2 bythedefinitionofDitfollowsthatB\u2032\u2208past(B)(asallminersare\nintersectsfuture(E2)thenthemaximalityofDiscontradicted,and assumedtobehonest).Similarly,ifB\u2032\u2032wascreatedaftert itwas\nifD2 intersectspast(E2)thenE2 \u21d2Discontradicted.HenceD1 \u2282 createdaftert+2Dandisthereforeinfuture(B).Itfollowsthat\nanticone(E1),D2 \u2282anticone(E2)andD3 \u2282anticone(B)whereit B\u2019santiconeisempty,orequivalentlythatB <\u22c6 B\u2032\u2032foranyB\u2032\u2032\nholdsthatE1,E2,B \u2208BlueSet(c).Therefore|D\n\u2229BlueSet(C)| \u2264k createdafterB.Hence,theorderingoverallblocksincreatedbefore\nfori =1,2,3,andsinceBlueSet(C)\u2229(past(B)\u222a{B})\u2282D1\u222aD2\u222a t ispreciselytheorderinginducedbyB,whichisdeterministicand\nD3\u222a{B}itfollowsthat|BlueSet(C)\\past(D)| \u2264 3k+1.Hence doesnotchange. \u25a1\nscore(C)\u2212score(D) \u2264 3k +1,wherebyscore(C) \u2264 score(B)+\nCorollary15. Inthenon-adversarialsettingwhereallminersare\n3k. \u25a1\nhonest,theprobabilitythattheorderingbetweentwoblockscreated\nLemma10 Theadvantageadv(t)isupperboundedbyastochastic beforetimet willchangeattimet+r decaysexponentiallywithr.",
    "source":"whitepaper",
    "section":"freeloading is bound by a constant depending only on system (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":223.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_131",
    "content":"# processwhichadmitsastationarydistributionwithanexponentially (Part 1)\n\nProof. LetB,Cbetwoblockscreatedbeforetimet.Atanypoint\ndecayingtail.\nintimeaftert,theprobabilityoftheeventEt wherethenextblock\nProof. The work in [18] contains an analysis of the willbeanhourglassblockissomepositiveconstantCdepending\npremining process, i.e., the maximal advantage of the onlyonthesystemparameters;moreoever,theeventsEt andEs\nattacker over an honest block, in a block race; formally: areindependentaslongas |s \u2212t| > 2D.Asr grows, |[t,t +r]|\nadv\u2032(t) := max C\u2208[0,t] {future(C)\u2229A\u2212future(C)\u2229H} (the approachesr \u00b7\u03bbexponentiallyfast.Inparticular,asr grows,with\nnotation adv\u2032(t) does not appear therein). In contrast, we are highprobability(i.e.,apartfromaterminO(e\u2212F\u00b7r))there\u2019saset\ninterestedintheprocessadv(t)=wA (t)\u2212wH (t),whichissimilarly ofblocksSofsizeatleastr \u00b7f suchthatanytwoblocksintheset\nbounded:adv(t)=score(C)\u2212score(V)whereCistheselectedtip werecreatedatleast2Dsecondsapart(F issomepositiveinteger,\noftheattackerandV isthevirtualblockofthehonestnode.LetD 0< f <1issomepositiveconstant).Sincetheeventswhereblocks\nsatisfythatD \u2264\u22c6CandD <\u22c6V (suchanelementmustexist,e.g. inS arehourglassblocksaremutuallyindependent,wegetthat\nthegenesiselement).Then theprobabilitythatnoneofthemisanhourglassblockisatmost\nadv(t)=|BlueSet(C)|\u2212|BlueSet(V)|\n(1\u2212c)f\u00b7r. \u25a1\n=|BlueSet(C)\\past(D)|\u2212|BlueSet(V)\\past(D)| Intheadversarialsetting,hourglasseventsarenotenoughto\n\u2264max(cid:8) |BlueSet(C)\\past (cid:0) C \u2032(cid:1)|\u2212|BlueSet(V)\\past (cid:0) C \u2032(cid:1)| (cid:9) securetheordering.Ifthehonestnetworkpostsanhourglassblock\nC\u2032 B,theadversarycould\"undo\"itbypostingablockintheanticone\nTheanalysisofthelasttermissimilartotheanalysisofadv\u2032(t) of B. Honest blocks created after B might include this block in\nwithtwodeviations:First,thegrowthrateofthehonestnetwork\u2019s theirblueset,thusmakingtheorderingofblocksinthepastofB\nbluescoreisnot(1\u2212\u03b1)rather(1\u2212\u03b1)(1\u2212\u03b4)asproveninLemma9. uncertainagain.Overcomingthisrequiresamorespecificevent:we\nThis has no qualitative effect on the analysis, it merely implies requirethatthehonestnetworkcreatedachainofseveralblocks",
    "source":"whitepaper",
    "section":"processwhichadmitsastationarydistributionwithanexponentially (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":132.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_132",
    "content":"# processwhichadmitsastationarydistributionwithanexponentially (Part 2)\n\n--- Page 13 ---",
    "source":"whitepaper",
    "section":"processwhichadmitsastationarydistributionwithanexponentially (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_133",
    "content":"# PHANTOMGHOSTDAG\n\n",
    "source":"whitepaper",
    "section":"PHANTOMGHOSTDAG",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_134",
    "content":"# AScalableGeneralizationofNakamotoConsensus\n\nNovember10,2021\nwhiletheadversaryhasproducednone14.Wecallsuchaneventa Sinceadv(C) \u2264 \u2212(2k\u22121)andnoblockbelowE freeloaded,this\nburst,andtheblocksinthechaintheburstblocks.Wewanttoassure impliesthattheattackerhaswonablockracewithstartingwith\nthattheprobabilitythatthehonestnetworkisneverconvinced advantage\u22121.\nbyablockwhoseselectedchaindoesnotincludeanyoftheburst \u25a1",
    "source":"whitepaper",
    "section":"AScalableGeneralizationofNakamotoConsensus",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":12.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_135",
    "content":"# blocksisboundedfrombelowbysomepositiveconstantdepending\n\nWenowproveProposition8,therebyconcludingtheproofof\nonlyonsystemparameters.Inthefollowinglemma,weprovethat\nTheorem7.",
    "source":"whitepaper",
    "section":"blocksisboundedfrombelowbysomepositiveconstantdepending",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":3.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_136",
    "content":"# theamountofburstblocksrequiredtoachievethisdependsonly (Part 1)\n\nonsystemparametersandonadv(t)wheret isthetimetheburst Proposition8 AssumethatBconvincedthenetworkattimet,\nstarted. thenadvB (t)isboundfromabovebyaMarkovianprocessonZwhich\ngoesto\u2212\u221eexponentiallyfast.\nLemma 16. For any Z, there exists a constant time length s\ndepending only onZ and system parameters, such that for anyt\nProof. LetBt betheeventthatbothDt,Z andadv(t)\u2264Z hold.\nLemma10impliesthattheprobabilityofadv(t)\u2264Z isboundbya\nthereexistsaneventDt,Z which,ifadv(t) \u2264Z,impliesthatthere\nconstantdependingonlyonsystemparameters,whileLemma16\nexists a block B created beforet +s such that for the attacker to\ncreateablockCwhichsatisfiesthatB\u226e\u22c6Candadv(C)\u2265\u22122kthey\nstatesthattheprobabilityofDt,Z dependsonlyonZ.Itisevident\nmustwinablockracestartingwithadvantage\u22121.Furthermore,the\nfromtheconstructionofDt,Z thatitdependsonlyonblockscreated\naftertwhileadv(t)\u2264Zdependsonlyonblockcreatedaftert,hence\nprobabilityofDt,Z isboundedfrombelowbyaconstantdepending\ntheseeventsareindependent,sotheprobabilityoftheirintersection\nonlyonZ andsystemparameters.\nisalsoboundbyaconstant.\nInordertoconstructM weconstructanotherprocessM\u2032 on\nProof. TheeventDt,Z istheeventthatnoblockswerecreated\nZ\u00d7{0,1}wherethe{0,1}partkeepstrackonwhethertheattacker\nduringthefirst2Dseconds,afterwhichthehonestnetworkcreated\nis in the condition described in Lemma 16. This means that as\nZ\u2032+3k+2blocksarrangedinachain,whiletheattackercreated\nadv <\u2212k,theattackerisinablockrace.Misthendefinedasthe\nnone,afterwhichnoblockswerecreatedfor2Dseconds,where",
    "source":"whitepaper",
    "section":"theamountofburstblocksrequiredtoachievethisdependsonly (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":91.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_137",
    "content":"# proj\n\nectionofM\u2032onZ.FromLemma9itfollowsthatthehonest\nZ\u2032=maxZ,k+1.Assumefurthermorethattheentireeventlasted\nchaingrowsatarateof(1\u2212\u03b1)(1\u2212\u03b4)whiletheattackerchaingrows\natmosts = (2Z\u2032+3k+2)\/\u03b1\u03bb+4D seconds(anys > 4D would atrate\u03b1.Let\u03b1\u2032= \u03b1 .Thisrenormalizesthingssuchthatifthe\nwork,butthischoiceofsisreasonableastheprobabilityforsuch",
    "source":"whitepaper",
    "section":"proj",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":14.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_138",
    "content":"# attackerdoesnotfr\n\n",
    "source":"whitepaper",
    "section":"attackerdoesnotfr",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_139",
    "content":"# loadtheadvantageismodeledasawalkon\n\naneventlastinglongerdecreasesexponentiallywithZ).Finally,let\nZwhichtransitionsrightwithprobability\u03b1\u2032.Wedefinetransition\nBthe3k+2fromlastblockcreatedintheevent.Weimmediately\nprobabilitiesofthestate(n,i):\nW no e te ca th ll a t t h t i h s e ev in en de t p a e b n u d r e s n t c a e nd of th D e t, b Z lo a c n k d s D cr t e + a s t , e Z d i d s u t r r i u n e g b t y he de ev si e g n n t . \u2022 If n > Z then the process transitions to (n + 1,i) with\nburstblocks.\nprobability\u03b1\u2032orto(n\u22121,i)withprobability1\u2212\u03b1\u2032\nLetC0 beanattackerblockcreatedaftert+ssuchthatB\u226e\u22c6C0 \u2022 If \u22122k \u2264 n < 3k then the attacker may freeload, we",
    "source":"whitepaper",
    "section":"loadtheadvantageismodeledasawalkon",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":123.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_140",
    "content":"# assumethatitalwaysmanagestodosoandalwaysgains\n\nandtheselectedparentofC0 wascreatedbeforet +s.LetC =\nmax(SelectedChain(C0)\u2229A),thenadv(C) \u2264 Z andinparticular\nthemaximaladvantageof3k,so(n,i)transitionsto(3k,1)\nwithprobability1\nscore(B) > score(C).LetB\u2032beaburstblockcreatedafterB and\nassumethatC \u2208SelectedChain(B\u2032),thisimpliesthatB <\u22c6B\u2032since \u2022 If3k \u2264n <Z thenletptheprobabilityofBt ,theprocess",
    "source":"whitepaper",
    "section":"assumethatitalwaysmanagestodosoandalwaysgains",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":23.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_141",
    "content":"# ifCwasdiscoveredafterBwascreatedthenanyburstblockwould\n\ntransitionsto(n+1,i)withprobability\u03b1\u2032p,to(n\u22121,i)with\nchoosethepreviousburstblock(whichhasscoreatleastscore(B))\nprobability(1\u2212\u03b1\u2032)p,orto(\u2212k\u22121,0)withprobabilityp\noverCasaselectedparent. \u2022 Ifn < \u22122k andi = 1 we also assume that the attacker",
    "source":"whitepaper",
    "section":"ifCwasdiscoveredafterBwascreatedthenanyburstblockwould",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":17.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_142",
    "content":"# manages to steal a block to gain the highest possible\n\n",
    "source":"whitepaper",
    "section":"manages to steal a block to gain the highest possible",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_143",
    "content":"# This implies that all burst blocks created after B are in the (Part 1)\n\nanticone ofC0 . Let B\u2032 be the latest burst block. It follows that\nadvantage,sotheprocessalwaystransitionsto(3k,1)\nscore(C0) \u2264 score(B)+k soscore(B\u2032) \u2265 score(B)+2k +1 \u2265 \u2022 Finally,ifn < \u22122k andi = 0thentheattackerisnotable\nscore(C0)+k+1.Inparticular,adv(C0)\u2264\u2212(2k\u22121).\nto freeload as long asn stays below \u22122k, so the process\nLet E be a block created aftert +s which freeloads off D \u2208\ntransitionsto(n+1,0)withprobability\u03b1\u2032orto(n\u22121,0)\nfuture(c0),butsuchthatnoblockinSelectedChain(E)freeloaded\nwithprobability1\u2212\u03b1\u2032.\noffablockinfutureC0 . Note that the state (\u2212(2k +1),0) transitions to (\u22122k,0) with\nLetE\u2032beanelementofpast(D)\u2229Aofmaximalscore(thissetis probability\u03b1\u2032fromwhichittransitionsto(3k,1)withprobability1.\nnotemptyasitcontainsthegenesisblock).Ifscore(E)\u2212score(E\u2032)> Itistruebydesignthatthisprocessboundstheattackeradvantage\nkthentherearemorethankblocksinBlueSet(E)\\past(D),which fromaboveinthecasewheretheyinsistsnottoincludeBintheir\ncontradictsthatD \u2208BlueSet(C).Hencescore(E)\u2212score(E\u2032)<k. selectedchain(sincealldeviationsfromanyactualprocesswhich\nNotethatscore(E\u2032)>score(E)\u2212k >score(D)\u2212k.So isinducedbyanyattackerstrategyarepositive),andthatMgoes\nto\u2212\u221eexponentiallyfast.\nadv(E \u2032)\u2265score (cid:0) E \u2032(cid:1)\u2212(score(D)+k) \u25a1\n\u2265score (cid:0) E \u2032(cid:1)\u2212score(E)\u2212k \u2265\u22122k",
    "source":"whitepaper",
    "section":"This implies that all burst blocks created after B are in the (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":93.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_144",
    "content":"# REFERENCES (Part 1)\n\n[1] Bitcoin\u2019srelaynetworkstats. http:\/\/bitcoinfibre.org\/stats.html. Accessed:\n14Notethatthisisnotanecessaryconditionforthenetworktoconverge,hencethe 2020-01-20.\nconstantswhichfollowfromtheanalysisarefarfromtight. [2] Kaspagithubrepository.https:\/\/github.com\/kaspanet\/kaspad\/.",
    "source":"whitepaper",
    "section":"REFERENCES (Part 1)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":9.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Phantom_Ghost_Whitepaper_145",
    "content":"# REFERENCES (Part 2)\n\n--- Page 14 ---\n,, YonatanSompolinsky,ShaiWyborski,andAvivZohar\n[3] Kaspagraphinspector(testnet).http:\/\/kgi-testnet.daglabs-dev.com\/. [12] YoadLewenberg,YonatanSompolinsky,andAvivZohar.Inclusiveblockchain\n[4] Kaspakatnipblockexplorer(testnet).http:\/\/testnet.katnip.sh\/. protocols. InInternationalConferenceonFinancialCryptographyandData\n[5] Kaspaperformancedashboard(testnet). http:\/\/kasboard-testnet.daglabs-dev. Security,pages528\u2013547.Springer,2015.\ncom\/. [13] ChenxingLi,PeilunLi,DongZhou,WeiXu,FanLong,andAndrewYao.Scaling\n[6] VivekBagaria,SreeramKannan,DavidTse,GiuliaFanti,andPramodViswanath. nakamotoconsensustothousandsoftransactionspersecond. arXivpreprint\nPrism:Deconstructingtheblockchaintoapproachphysicallimits.InProceedings arXiv:1805.03870,2018.\nofthe2019ACMSIGSACConferenceonComputerandCommunicationsSecurity, [14] RafaelPass,LiorSeeman,andAbhiShelat.Analysisoftheblockchainprotocol\npages585\u2013602,2019. inasynchronousnetworks.IACRCryptologyePrintArchive,2016:454,2016.\n[7] Ittay Eyal, Adem Efe Gencer, Emin G\u00fcn Sirer, and Robbert Van Renesse. [15] Rafael Pass andElaine Shi. Hybrid consensus: Efficient consensus inthe\nBitcoin-ng:Ascalableblockchainprotocol. In13thUSENIXSymposiumon permissionlessmodel,2016.\nNetworkedSystemsDesignandImplementation(NSDI16),pages45\u201359,2016. [16] JosephPoonandThaddeusDryja. Thebitcoinlightningnetwork:Scalable\n[8] MatthiasFitzi,PeterGazi,AggelosKiayias,andAlexanderRussell. Parallel off-chaininstantpayments.TechnicalReport(draft),2015.\nchains:Improvingthroughputandlatencyofblockchainprotocolsviaparallel [17] MeniRosenfeld. Analysisofhashrate-baseddoublespending. arXivpreprint\ncomposition.IACRCryptologyePrintArchive,2018:1119,2018. arXiv:1402.2009,2014.\n[9] JuanGaray,AggelosKiayias,andNikosLeonardos. Thebitcoinbackbone [18] YonatanSompolinsky,YoadLewenberg,andAvivZohar. Spectre:Afastand\nprotocol:Analysisandapplications.InAnnualInternationalConferenceonthe scalablecryptocurrencyprotocol. IACRCryptologyePrintArchive,2016:1159,\nTheoryandApplicationsofCryptographicTechniques,pages281\u2013310.Springer, 2016.\n2015. [19] YonatanSompolinskyandAvivZohar.Securehigh-ratetransactionprocessingin\n[10] MichaelRGareyandDavidSJohnson.Computersandintractability,volume29. bitcoin.InInternationalConferenceonFinancialCryptographyandDataSecurity,\nwhfreemanNewYork,2002. pages507\u2013527.Springer,2015.\n[11] AggelosKiayiasandGiorgosPanagiotakos.Ontrees,chainsandfasttransactions [20] HaifengYu,IvicaNikolic,RuomuHou,andPrateekSaxena.Ohie:Blockchain\nintheblockchain.CryptologyePrintArchive,Report2016\/545,2016. scalingmadesimple.arXivpreprintarXiv:1811.12628,2018.",
    "source":"whitepaper",
    "section":"REFERENCES (Part 2)",
    "url":null,
    "filename":"Phantom_Ghost_Whitepaper",
    "chunk_type":"section_part",
    "word_count":98.0,
    "pdf_pages":14.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Phantom_Ghost_Whitepaper.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_0",
    "content":"# Ethereum White Paper\n\nA NEXT GENERATION SMART CONTRACT & DECENTRALIZED APPLICATION PLATFORM",
    "source":"whitepaper",
    "section":"Ethereum White Paper",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":9.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_1",
    "content":"# By Vitalik Buterin (Part 1)\n\nWhen Satoshi Nakamoto first set the Bitcoin blockchain into motion in January 2009, he was\nsimultaneously introducing two radical and untested concepts. The first is the \"bitcoin\", a decentralized\npeer-to-peer online currency that maintains a value without any backing, intrinsic value or central issuer. So\nfar, the \"bitcoin\" as a currency unit has taken up the bulk of the public attention, both in terms of the political\naspects of a currency without a central bank and its extreme upward and downward volatility in price.\nHowever, there is also another, equally important, part to Satoshi's grand experiment: the concept of a proof of\nwork-based blockchain to allow for public agreement on the order of transactions. Bitcoin as an application can\nbe described as a first-to-file system: if one entity has 50 BTC, and simultaneously sends the same 50 BTC to\nA and to B, only the transaction that gets confirmed first will process. There is no intrinsic way of determining\nfrom two transactions which came earlier, and for decades this stymied the development of decentralized\ndigital currency. Satoshi's blockchain was the first credible decentralized solution. And now, attention is\nrapidly starting to shift toward this second part of Bitcoin's technology, and how the blockchain concept can be\nused for more than just money.\nCommonly cited applications include using on-blockchain digital assets to represent custom currencies and\nfinancial instruments (\"colored coins\"), the ownership of an underlying physical device (\"smart property\"),\nnon-fungible assets such as domain names (\"Namecoin\") as well as more advanced applications such as\ndecentralized exchange, financial derivatives, peer-to-peer gambling and on-blockchain identity and\nreputation systems. Another important area of inquiry is \"smart contracts\" - systems which automatically\nmove digital assets according to arbitrary pre-specified rules. For example, one might have a treasury contract\nof the form \"A can withdraw up to X currency units per day, B can withdraw up to Y per day, A and B together\ncan withdraw anything, and A can shut off B's ability to withdraw\". The logical extension of this is\ndecentralized autonomous organizations (DAOs) - long-term smart contracts that contain the assets and\nencode the bylaws of an entire organization. What Ethereum intends to provide is a blockchain with a built-in\nfully fledged Turing-complete programming language that can be used to create \"contracts\" that can be used\nto encode arbitrary state transition functions, allowing users to create any of the systems described above, as\nwell as many others that we have not yet imagined, simply by writing up the logic in a few lines of code.\nPage 1\nethereum.org",
    "source":"whitepaper",
    "section":"By Vitalik Buterin (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":425.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_2",
    "content":"# By Vitalik Buterin (Part 2)\n\n--- Page 2 ---",
    "source":"whitepaper",
    "section":"By Vitalik Buterin (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_3",
    "content":"# Table of contents\n\n\u25cf History\n\u25cb Bitcoin As A State Transition System\n\u25cb Mining\n\u25cb Merkle Trees\n\u25cb Alternative Blockchain Applications\n\u25cb Scripting\n\u25cf Ethereum\n\u25cb Ethereum Accounts\n\u25cb Messages and Transactions\n\u25cb Ethereum State Transition Function\n\u25cb Code Execution\n\u25cb Blockchain and Mining\n\u25cf Applications\n\u25cb Token Systems\n\u25cb Financial derivatives\n\u25cb Identity and Reputation Systems\n\u25cb Decentralized File Storage\n\u25cb Decentralized Autonomous Organizations\n\u25cb Further Applications\n\u25cf Miscellanea And Concerns\n\u25cb Modified GHOST Implementation\n\u25cb Fees\n\u25cb Computation And Turing-Completeness\n\u25cb Currency And Issuance\n\u25cb Mining Centralization\n\u25cb Scalability\n\u25cf Putting It All Together: Decentralized Applications\n\u25cf Conclusion\n\u25cf References and Further Reading\nPage 2\nethereum.org\n\n--- Page 3 ---\nPage 3\nethereum.org\n\n--- Page 4 ---",
    "source":"whitepaper",
    "section":"Table of contents",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":116.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_4",
    "content":"# History (Part 1)\n\nThe concept of decentralized digital currency, as well as alternative applications like property registries,\nhas been around for decades. The anonymous e-cash protocols of the 1980s and the 1990s, mostly\nreliant on a cryptographic primitive known as Chaumian blinding, provided a currency with a high degree\nof privacy, but the protocols largely failed to gain traction because of their reliance on a centralized\nintermediary. In 1998, Wei Dai's b-money became the first proposal to introduce the idea of creating\nmoney through solving computational puzzles as well as decentralized consensus, but the proposal\nwas scant on details as to how decentralized consensus could actually be implemented. In 2005, Hal\nFinney introduced a concept of \"reusable proofs of work\", a system which uses ideas from b-money\ntogether with Adam Back's computationally difficult Hashcash puzzles to create a concept for a\ncryptocurrency, but once again fell short of the ideal by relying on trusted computing as a backend.\nBecause currency is a first-to-file application, where the order of transactions is often of critical\nimportance, decentralized currencies require a solution to decentralized consensus. The main roadblock\nthat all pre-Bitcoin currency protocols faced is the fact that, while there had been plenty of research on\ncreating secure Byzantine-fault-tolerant multiparty consensus systems for many years, all of the\nprotocols described were solving only half of the problem. The protocols assumed that all participants in\nthe system were known, and produced security margins of the form \"if N parties participate, then the\nsystem can tolerate up to N\/4 malicious actors\". The problem is, however, that in an anonymous setting\nsuch security margins are vulnerable to sybil attacks, where a single attacker creates thousands of\nsimulated nodes on a server or botnet and uses these nodes to unilaterally secure a majority share.",
    "source":"whitepaper",
    "section":"History (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":294.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_5",
    "content":"# The innovation provided by Satoshi is the idea of combining a very simple decentralized consensus\n\nprotocol, based on nodes combining transactions into a \"block\" every ten minutes creating an\never-growing blockchain, with proof of work as a mechanism through which nodes gain the right to\nparticipate in the system. While nodes with a large amount of computational power do have\nproportionately greater influence, coming up with more computational power than the entire network\ncombined is much harder than simulating a million nodes. Despite the Bitcoin blockchain model's\ncrudeness and simplicity, it has proven to be good enough, and would over the next five years become\nthe bedrock of over two hundred currencies and protocols around the world.\nPage 4\nethereum.org\n\n--- Page 5 ---",
    "source":"whitepaper",
    "section":"The innovation provided by Satoshi is the idea of combining a very simple decentralized consensus",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":109.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_6",
    "content":"# Bitcoin As A State Transition System (Part 1)\n\nFrom a technical standpoint, the Bitcoin ledger can be thought of as a state transition system, where there is\na \"state\" consisting of the ownership status of all existing bitcoins and a \"state transition function\" that takes\na state and a transaction and outputs a new state which is the result. In a standard banking system, for\nexample, the state is a balance sheet, a transaction is a request to move $X from A to B, and the state\ntransition function reduces the value in A's account by $X and increases the value in B's account by $X. If A's\naccount has less than $X in the first place, the state transition function returns an error. Hence, one can\nformally define:\nAPPLY(S,TX) \u00ad> S' or ERROR\nIn the banking system defined above:\nAPPLY({ Alice: $50, Bob: $50 },\"send $20 from Alice to Bob\") = { Alice: $30,\nBob: $70 }\nBut:\nAPPLY({ Alice: $50, Bob: $50 },\"send $70 from Alice to Bob\") = ERROR\nThe \"state\" in Bitcoin is the collection of all coins (technically, \"unspent transaction outputs\" or UTXO) that\nhave been minted and not yet spent, with each UTXO having a denomination and an owner (defined by a\n20-byte address which is essentially a cryptographic public key[1]). A transaction contains one or more inputs,",
    "source":"whitepaper",
    "section":"Bitcoin As A State Transition System (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":216.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_7",
    "content":"# with each input containing a reference to an existing UTXO and a cryptographic signature produced by the\n\nprivate key associated with the owner's address, and one or more outputs, with each output containing a new\nUTXO to be added to the state.\nPage 5\nethereum.org\n\n--- Page 6 ---\nThe state transition function APPLY(S,TX) \u00ad> S' can be defined roughly as follows:\n1. For each input in TX:\ni. If the referenced UTXO is not in S, return an error.\nii. If the provided signature does not match the owner of the UTXO, return an error.",
    "source":"whitepaper",
    "section":"with each input containing a reference to an existing UTXO and a cryptographic signature produced by the",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":79.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_8",
    "content":"# 2. If the sum of the denominations of all input UTXO is less than the sum of the denominations of\n\nall output UTXO, return an error.\n3. Return S with all input UTXO removed and all output UTXO added.\nThe first half of the first step prevents transaction senders from spending coins that do not exist, the second\nhalf of the first step prevents transaction senders from spending other people's coins, and the second step\nenforces conservation of value. In order to use this for payment, the protocol is as follows. Suppose Alice wants\nto send 11.7 BTC to Bob. First, Alice will look for a set of available UTXO that she owns that totals up to at least\n11.7 BTC. Realistically, Alice will not be able to get exactly 11.7 BTC; say that the smallest she can get is\n6+4+2=12. She then creates a transaction with those three inputs and two outputs. The first output will be 11.7\nBTC with Bob's address as its owner, and the second output will be the remaining 0.3 BTC \"change\", with the\nowner being Alice herself.",
    "source":"whitepaper",
    "section":"2. If the sum of the denominations of all input UTXO is less than the sum of the denominations of",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":163.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_9",
    "content":"# Mining\n\nIf we had access to a trustworthy centralized service, this system would be trivial to implement; it\ncould simply be coded exactly as described. However, with Bitcoin we are trying to build a\ndecentralized currency system, so we will need to combine the state transition system with a\nconsensus system in order to ensure that everyone agrees on the order of transactions. Bitcoin's",
    "source":"whitepaper",
    "section":"Mining",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":63.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_10",
    "content":"# decentralized consensus process requires nodes in the network to continuously attempt to produce\n\npackages of transactions called \"blocks\". The network is intended to produce roughly one block every\nten minutes, with each block containing a timestamp, a nonce, a reference to (ie. hash of) the\nPage 6\nethereum.org\n\n--- Page 7 ---\nprevious block and a list of all of the transactions that have taken place since the previous block.\nOver time, this creates a persistent, ever-growing, \"blockchain\" that constantly updates to represent\nthe latest state of the Bitcoin ledger.\nThe algorithm for checking if a block is valid, expressed in this paradigm, is as follows:",
    "source":"whitepaper",
    "section":"decentralized consensus process requires nodes in the network to continuously attempt to produce",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":93.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_11",
    "content":"# 1. Check if the previous block referenced by the block exists and is valid (Part 1)\n\n2. Check that the timestamp of the block is greater than that of the previous block[2] and less than 2\nhours into the future.\n3. Check that the proof of work on the block is valid.\n4. Let S[0] be the state at the end of the previous block.\n5. Suppose TX is the block's transaction list with n transactions. For all i in 0...n-1, setS[i+1] =\nAPPLY(S[i],TX[i]) If any application returns an error, exit and return false.\n6. Return true, and register S[n] as the state at the end of this block\nEssentially, each transaction in the block must provide a state transition that is valid. Note that the state is\nnot encoded in the block in any way; it is purely an abstraction to be remembered by the validating node and\ncan only be (securely) computed for any block by starting from the genesis state and sequentially applying\nevery transaction in every block. Additionally, note that the order in which the miner includes transactions into\nthe block matters; if there are two transactions A and B in a block such that B spends a UTXO created by A,\nthen the block will be valid if A comes before B but not otherwise.\nThe interesting part of the block validation algorithm is the concept of \"proof of work\": the condition is that the\nSHA256 hash of every block, treated as a 256-bit number, must be less than a dynamically adjusted target,\nwhich as of the time of this writing is approximately 2190. The purpose of this is to make block creation\ncomputationally \"hard\", thereby preventing sybil attackers from remaking the entire blockchain in their favor.\nBecause SHA256 is designed to be a completely unpredictable pseudorandom function, the only way to create\na valid block is simply trial and error, repeatedly incrementing the nonce and seeing if the new hash matches.\nAt the current target of 2192, this means an average of 264 tries; in general, the target is recalibrated by the\nnetwork every 2016 blocks so that on average a new block is produced by some node in the network every ten\nminutes. In order to compensate miners for this computational work, the miner of every block is entitled to\ninclude a transaction giving themselves 25 BTC out of nowhere. Additionally, if any transaction has a higher\ntotal denomination in its inputs than in its outputs, the difference also goes to the miner as a \"transaction\nfee\". Incidentally, this is also the only mechanism by which BTC are issued; the genesis state contained no\ncoins at all.\nPage 7\nethereum.org",
    "source":"whitepaper",
    "section":"1. Check if the previous block referenced by the block exists and is valid (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":431.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_12",
    "content":"# 1. Check if the previous block referenced by the block exists and is valid (Part 2)\n\n--- Page 8 ---\nIn order to better understand the purpose of mining, let us examine what happens in the event of a malicious\nattacker. Since Bitcoin's underlying cryptography is known to be secure, the attacker will target the one part of\nthe Bitcoin system that is not protected by cryptography directly: the order of transactions. The attacker's\nstrategy is simple:\n1. Send 100 BTC to a merchant in exchange for some product (preferably a rapid-delivery digital\ngood)",
    "source":"whitepaper",
    "section":"1. Check if the previous block referenced by the block exists and is valid (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":78.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_13",
    "content":"# 2. Wait for the delivery of the product (Part 1)\n\n3. Produce another transaction sending the same 100 BTC to himself\n4. Try to convince the network that his transaction to himself was the one that came first.\nOnce step (1) has taken place, after a few minutes some miner will include the transaction in a block, say\nblock number 270000. After about one hour, five more blocks will have been added to the chain after that block,\nwith each of those blocks indirectly pointing to the transaction and thus \"confirming\" it. At this point, the\nmerchant will accept the payment as finalized and deliver the product; since we are assuming this is a digital\ngood, delivery is instant. Now, the attacker creates another transaction sending the 100 BTC to himself. If the\nattacker simply releases it into the wild, the transaction will not be processed; miners will attempt to run\nAPPLY(S,TX) and notice that TX consumes a UTXO which is no longer in the state. So instead, the attacker\ncreates a \"fork\" of the blockchain, starting by mining another version of block 270000 pointing to the same\nblock 269999 as a parent but with the new transaction in place of the old one. Because the block data is\ndifferent, this requires redoing the proof of work. Furthermore, the attacker's new version of block 270000 has a\ndifferent hash, so the original blocks 270001 to 270005 do not \"point\" to it; thus, the original chain and the\nattacker's new chain are completely separate. The rule is that in a fork the longest blockchain (ie. the one\nbacked by the largest quantity of proof of work) is taken to be the truth, and so legitimate miners will work on\nthe 270005 chain while the attacker alone is working on the 270000 chain. In order for the attacker to make\nhis blockchain the longest, he would need to have more computational power than the rest of the network\ncombined in order to catch up (hence, \"51% attack\").\nPage 8\nethereum.org",
    "source":"whitepaper",
    "section":"2. Wait for the delivery of the product (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":328.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_14",
    "content":"# 2. Wait for the delivery of the product (Part 2)\n\n--- Page 9 ---",
    "source":"whitepaper",
    "section":"2. Wait for the delivery of the product (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_15",
    "content":"# Merkle Trees (Part 1)\n\nLeft: it suffices to present only a small number of nodes in a Merkle tree to give a proof of the validity of a branch.\nRight: any attempt to change any part of the Merkle tree will eventually lead to an inconsistency somewhere up the\nchain.\nAn important scalability feature of Bitcoin is that the block is stored in a multi-level data structure. The \"hash\"\nof a block is actually only the hash of the block header, a roughly 200-byte piece of data that contains the\ntimestamp, nonce, previous block hash and the root hash of a data structure called the Merkle tree storing all\ntransactions in the block.\nA Merkle tree is a type of binary tree, composed of a set of nodes with a large number of leaf nodes at the\nbottom of the tree containing the underlying data, a set of intermediate nodes where each node is the hash of\nits two children, and finally a single root node, also formed from the hash of its two children, representing the\n\"top\" of the tree. The purpose of the Merkle tree is to allow the data in a block to be delivered piecemeal: a node\ncan download only the header of a block from one source, the small part of the tree relevant to them from\nPage 9\nethereum.org",
    "source":"whitepaper",
    "section":"Merkle Trees (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":221.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_16",
    "content":"# Merkle Trees (Part 2)\n\n--- Page 10 ---\nanother source, and still be assured that all of the data is correct. The reason why this works is that hashes\npropagate upward: if a malicious user attempts to swap in a fake transaction into the bottom of a Merkle tree,\nthis change will cause a change in the node above, and then a change in the node above that, finally\nchanging the root of the tree and therefore the hash of the block, causing the protocol to register it as a\ncompletely different block (almost certainly with an invalid proof of work).\nThe Merkle tree protocol is arguably essential to long-term sustainability. A \"full node\" in the Bitcoin network,\none that stores and processes the entirety of every block, takes up about 15 GB of disk space in the Bitcoin\nnetwork as of April 2014, and is growing by over a gigabyte per month. Currently, this is viable for some desktop\ncomputers and not phones, and later on in the future only businesses and hobbyists will be able to participate.\nA protocol known as \"simplified payment verification\" (SPV) allows for another class of nodes to exist, called\n\"light nodes\", which download the block headers, verify the proof of work on the block headers, and then\ndownload only the \"branches\" associated with transactions that are relevant to them. This allows light nodes\nto determine with a strong guarantee of security what the status of any Bitcoin transaction, and their current\nbalance, is while downloading only a very small portion of the entire blockchain.",
    "source":"whitepaper",
    "section":"Merkle Trees (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":257.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_17",
    "content":"# Alternative Blockchain Applications (Part 1)\n\nThe idea of taking the underlying blockchain idea and applying it to other concepts also has a long history. In\n2005, Nick Szabo came out with the concept of \"secure property titles with owner authority\", a document\ndescribing how \"new advances in replicated database technology\" will allow for a blockchain-based system for\nstoring a registry of who owns what land, creating an elaborate framework including concepts such as\nhomesteading, adverse possession and Georgian land tax. However, there was unfortunately no effective\nreplicated database system available at the time, and so the protocol was never implemented in practice.\nAfter 2009, however, once Bitcoin's decentralized consensus was developed a number of alternative\napplications rapidly began to emerge:\n\u25cf Namecoin - created in 2010, Namecoin is best described as a decentralized name registration\ndatabase. In decentralized protocols like Tor, Bitcoin and BitMessage, there needs to be some way\nof identifying accounts so that other people can interact with them, but in all existing solutions the",
    "source":"whitepaper",
    "section":"Alternative Blockchain Applications (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":162.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_18",
    "content":"# only kind of identifier available is a pseudorandom hash (Part 1)\n\nlike1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy. Ideally, one would like to be able to have an\naccount with a name like \"george\". However, the problem is that if one person can create an\naccount named \"george\" then someone else can use the same process to register \"george\" for\nthemselves as well and impersonate them. The only solution is a first-to-file paradigm, where the\nfirst registrant succeeds and the second fails - a problem perfectly suited for the Bitcoin consensus\nprotocol. Namecoin is the oldest, and most successful, implementation of a name registration\nsystem using such an idea.\n\u25cf Colored coins - the purpose of colored coins is to serve as a protocol to allow people to create their\nown digital currencies - or, in the important trivial case of a currency with one unit, digital tokens,\nPage 10\nethereum.org",
    "source":"whitepaper",
    "section":"only kind of identifier available is a pseudorandom hash (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":134.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_19",
    "content":"# only kind of identifier available is a pseudorandom hash (Part 2)\n\n--- Page 11 ---\non the Bitcoin blockchain. In the colored coins protocol, one \"issues\" a new currency by publicly\nassigning a color to a specific Bitcoin UTXO, and the protocol recursively defines the color of other\nUTXO to be the same as the color of the inputs that the transaction creating them spent (some\nspecial rules apply in the case of mixed-color inputs). This allows users to maintain wallets\ncontaining only UTXO of a specific color and send them around much like regular bitcoins,\nbacktracking through the blockchain to determine the color of any UTXO that they receive.\n\u25cf Metacoins - the idea behind a metacoin is to have a protocol that lives on top of Bitcoin, using\nBitcoin transactions to store metacoin transactions but having a different state transition function,\nAPPLY'. Because the metacoin protocol cannot prevent invalid metacoin transactions from\nappearing in the Bitcoin blockchain, a rule is added that if APPLY'(S,TX) returns an error, the\nprotocol defaults to APPLY'(S,TX) = S. This provides an easy mechanism for creating an arbitrary\ncryptocurrency protocol, potentially with advanced features that cannot be implemented inside of\nBitcoin itself, but with a very low development cost since the complexities of mining and networking\nare already handled by the Bitcoin protocol.\nThus, in general, there are two approaches toward building a consensus protocol: building an independent\nnetwork, and building a protocol on top of Bitcoin. The former approach, while reasonably successful in the\ncase of applications like Namecoin, is difficult to implement; each individual implementation needs to\nbootstrap an independent blockchain, as well as building and testing all of the necessary state transition and\nnetworking code. Additionally, we predict that the set of applications for decentralized consensus technology",
    "source":"whitepaper",
    "section":"only kind of identifier available is a pseudorandom hash (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":286.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_20",
    "content":"# will follow a power law distribution where the vast majority of applications would be too small to warrant their (Part 1)\n\nown blockchain, and we note that there exist large classes of decentralized applications, particularly\ndecentralized autonomous organizations, that need to interact with each other.\nThe Bitcoin-based approach, on the other hand, has the flaw that it does not inherit the simplified payment\nverification features of Bitcoin. SPV works for Bitcoin because it can use blockchain depth as a proxy for\nvalidity; at some point, once the ancestors of a transaction go far enough back, it is safe to say that they were\nlegitimately part of the state. Blockchain-based meta-protocols, on the other hand, cannot force the blockchain\nnot to include transactions that are not valid within the context of their own protocols. Hence, a fully secure\nSPV meta-protocol implementation would need to backward scan all the way to the beginning of the Bitcoin\nblockchain to determine whether or not certain transactions are valid. Currently, all \"light\" implementations of\nBitcoin-based meta-protocols rely on a trusted server to provide the data, arguably a highly suboptimal result\nespecially when one of the primary purposes of a cryptocurrency is to eliminate the need for trust.",
    "source":"whitepaper",
    "section":"will follow a power law distribution where the vast majority of applications would be too small to warrant their (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":181.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_21",
    "content":"# Scripting (Part 1)\n\nEven without any extensions, the Bitcoin protocol actually does facilitate a weak version of a concept of \"smart\ncontracts\". UTXO in Bitcoin can be owned not just by a public key, but also by a more complicated script\nexpressed in a simple stack-based programming language. In this paradigm, a transaction spending that\nUTXO must provide data that satisfies the script. Indeed, even the basic public key ownership mechanism is\nPage 11\nethereum.org",
    "source":"whitepaper",
    "section":"Scripting (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":72.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_22",
    "content":"# Scripting (Part 2)\n\n--- Page 12 ---\nimplemented via a script: the script takes an elliptic curve signature as input, verifies it against the\ntransaction and the address that owns the UTXO, and returns 1 if the verification is successful and 0\notherwise. Other, more complicated, scripts exist for various additional use cases. For example, one can\nconstruct a script that requires signatures from two out of a given three private keys to validate (\"multisig\"), a\nsetup useful for corporate accounts, secure savings accounts and some merchant escrow situations. Scripts\ncan also be used to pay bounties for solutions to computational problems, and one can even construct a script\nthat says something like \"this Bitcoin UTXO is yours if you can provide an SPV proof that you sent a Dogecoin\ntransaction of this denomination to me\", essentially allowing decentralized cross-cryptocurrency exchange.\nHowever, the scripting language as implemented in Bitcoin has several important limitations:\n\u25cf Lack of Turing-completeness - that is to say, while there is a large subset of computation\nthat the Bitcoin scripting language supports, it does not nearly support everything. The main\ncategory that is missing is loops. This is done to avoid infinite loops during transaction verification;\ntheoretically it is a surmountable obstacle for script programmers, since any loop can be simulated\nby simply repeating the underlying code many times with an if statement, but it does lead to scripts\nthat are very space-inefficient. For example, implementing an alternative elliptic curve signature\nalgorithm would likely require 256 repeated multiplication rounds all individually included in the\ncode.\n\u25cf Value-blindness - there is no way for a UTXO script to provide fine-grained control over the\namount that can be withdrawn. For example, one powerful use case of an oracle contract would be a\nhedging contract, where A and B put in $1000 worth of BTC and after 30 days the script sends $1000\nworth of BTC to A and the rest to B. This would require an oracle to determine the value of 1 BTC in\nUSD, but even then it is a massive improvement in terms of trust and infrastructure requirement over\nthe fully centralized solutions that are available now. However, because UTXO are all-or-nothing, the",
    "source":"whitepaper",
    "section":"Scripting (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":365.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_23",
    "content":"# only way to achieve this is through the very inefficient hack of having many UTXO of varying (Part 1)\n\ndenominations (eg. one UTXO of 2k for every k up to 30) and having the oracle pick which UTXO to\nsend to A and which to B.\n\u25cf Lack of state - UTXO can either be spent or unspent; there is no opportunity for multi-stage\ncontracts or scripts which keep any other internal state beyond that. This makes it hard to make\nmulti-stage options contracts, decentralized exchange offers or two-stage cryptographic commitment\nprotocols (necessary for secure computational bounties). It also means that UTXO can only be used\nto build simple, one-off contracts and not more complex \"stateful\" contracts such as decentralized\norganizations, and makes meta-protocols difficult to implement. Binary state combined with\nvalue-blindness also mean that another important application, withdrawal limits, is impossible.\n\u25cf Blockchain-blindness - UTXO are blind to blockchain data such as the nonce and previous\nhash. This severely limits applications in gambling, and several other categories, by depriving the\nscripting language of a potentially valuable source of randomness.\nPage 12\nethereum.org",
    "source":"whitepaper",
    "section":"only way to achieve this is through the very inefficient hack of having many UTXO of varying (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":164.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_24",
    "content":"# only way to achieve this is through the very inefficient hack of having many UTXO of varying (Part 2)\n\n--- Page 13 ---\nThus, we see three approaches to building advanced applications on top of cryptocurrency: building a new\nblockchain, using scripting on top of Bitcoin, and building a meta-protocol on top of Bitcoin. Building a new\nblockchain allows for unlimited freedom in building a feature set, but at the cost of development time and\nbootstrapping effort. Using scripting is easy to implement and standardize, but is very limited in its\ncapabilities, and meta-protocols, while easy, suffer from faults in scalability. With Ethereum, we intend to build\na generalized framework that can provide the advantages of all three paradigms at the same time.",
    "source":"whitepaper",
    "section":"only way to achieve this is through the very inefficient hack of having many UTXO of varying (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":104.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_25",
    "content":"# Ethereum\n\nThe intent of Ethereum is to merge together and improve upon the concepts of scripting, altcoins and on-chain\nmeta-protocols, and allow developers to create arbitrary consensus-based applications that have the\nscalability, standardization, feature-completeness, ease of development and interoperability offered by these\ndifferent paradigms all at the same time. Ethereum does this by building what is essentially the ultimate\nabstract foundational layer: a blockchain with a built-in Turing-complete programming language, allowing",
    "source":"whitepaper",
    "section":"Ethereum",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":70.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_26",
    "content":"# anyone to write smart contracts and decentralized applications where they can create their own arbitrary\n\nrules for ownership, transaction formats and state transition functions. A bare-bones version of Namecoin can\nbe written in two lines of code, and other protocols like currencies and reputation systems can be built in under\ntwenty. Smart contracts, cryptographic \"boxes\" that contain value and only unlock it if certain conditions are\nmet, can also be built on top of our platform, with vastly more power than that offered by Bitcoin scripting\nbecause of the added powers of Turing-completeness, value-awareness, blockchain-awareness and state.",
    "source":"whitepaper",
    "section":"anyone to write smart contracts and decentralized applications where they can create their own arbitrary",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":82.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_27",
    "content":"# Ethereum Accounts (Part 1)\n\nIn Ethereum, the state is made up of objects called \"accounts\", with each account having a 20-byte address\nand state transitions being direct transfers of value and information between accounts. An Ethereum account\ncontains four fields:\n\u25cf The nonce, a counter used to make sure each transaction can only be processed once\n\u25cf The account's current ether balance\n\u25cf The account's contract code, if present\n\u25cf The account's storage (empty by default)\n\"Ether\" is the main internal crypto-fuel of Ethereum, and is used to pay transaction fees. In general, there are\ntwo types of accounts: externally owned accounts, controlled by private keys, and contract accounts, controlled\nby their contract code. An externally owned account has no code, and one can send messages from an\nexternally owned account by creating and signing a transaction; in a contract account, every time the\nPage 13\nethereum.org",
    "source":"whitepaper",
    "section":"Ethereum Accounts (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":143.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_28",
    "content":"# Ethereum Accounts (Part 2)\n\n--- Page 14 ---\ncontract account receives a message its code activates, allowing it to read and write to internal storage and\nsend other messages or create contracts in turn.",
    "source":"whitepaper",
    "section":"Ethereum Accounts (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":30.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_29",
    "content":"# Messages and Transactions (Part 1)\n\n\"Messages\" in Ethereum are somewhat similar to \u201ctransactions\u201d in Bitcoin, but with three important\ndifferences. First, an Ethereum message can be created either by an external entity or a contract, whereas a\nBitcoin transaction can only be created externally. Second, there is an explicit option for Ethereum messages\nto contain data. Finally, the recipient of an Ethereum message, if it is a contract account, has the option to\nreturn a response; this means that Ethereum messages also encompass the concept of functions.\nThe term \"transaction\" is used in Ethereum to refer to the signed data package that stores a message to be\nsent from an externally owned account. Transactions contain the recipient of the message, a signature\nidentifying the sender, the amount of ether and the data to send, as well as two values called STARTGAS and\nGASPRICE. In order to prevent exponential blowup and infinite loops in code, each transaction is required to set\na limit to how many computational steps of code execution it can spawn, including both the initial message\nand any additional messages that get spawned during execution. STARTGAS is this limit, and GASPRICE is\nthe fee to pay to the miner per computational step. If transaction execution \"runs out of gas\", all state changes\nrevert - except for the payment of the fees, and if transaction execution halts with some gas remaining then\nthe remaining portion of the fees is refunded to the sender. There is also a separate transaction type, and\ncorresponding message type, for creating a contract; the address of a contract is calculated based on the\nhash of the account nonce and transaction data.\nAn important consequence of the message mechanism is the \"first class citizen\" property of Ethereum - the\nidea that contracts have equivalent powers to external accounts, including the ability to send message and\ncreate other contracts. This allows contracts to simultaneously serve many different roles: for example, one\nmight have a member of a decentralized organization (a contract) be an escrow account (another contract)\nbetween an paranoid individual employing custom quantum-proof Lamport signatures (a third contract) and\na co-signing entity which itself uses an account with five keys for security (a fourth contract). The strength of",
    "source":"whitepaper",
    "section":"Messages and Transactions (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":368.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_30",
    "content":"# the Ethereum platform is that the decentralized organization and the escrow contract do not need to care\n\nabout what kind of account each party to the contract is.\nPage 14\nethereum.org\n\n--- Page 15 ---",
    "source":"whitepaper",
    "section":"the Ethereum platform is that the decentralized organization and the escrow contract do not need to care",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":18.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_31",
    "content":"# Ethereum State Transition Function (Part 1)\n\nThe Ethereum state transition function, APPLY(S,TX) -> S' can be defined as follows:\n1. Check if the transaction is well-formed (ie. has the right number of values), the signature is valid,\nand the nonce matches the nonce in the sender's account. If not, return an error.\n2. Calculate the transaction fee as STARTGAS * GASPRICE, and determine the sending address from\nthe signature. Subtract the fee from the sender's account balance and increment the sender's\nnonce. If there is not enough balance to spend, return an error.\n3. Initialize GAS = STARTGAS, and take off a certain quantity of gas per byte to pay for the bytes in\nthe transaction.\n4. Transfer the transaction value from the sender's account to the receiving account. If the receiving\naccount does not yet exist, create it. If the receiving account is a contract, run the contract's code\neither to completion or until the execution runs out of gas.\n5. If the value transfer failed because the sender did not have enough money, or the code execution\nran out of gas, revert all state changes except the payment of the fees, and add the fees to the\nminer's account.\n6. Otherwise, refund the fees for all remaining gas to the sender, and send the fees paid for gas\nconsumed to the miner.\nPage 15\nethereum.org",
    "source":"whitepaper",
    "section":"Ethereum State Transition Function (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":221.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_32",
    "content":"# Ethereum State Transition Function (Part 2)\n\n--- Page 16 ---\nFor example, suppose that the contract's code is:\nif !contract.storage[msg.data[0]]:\ncontract.storage[msg.data[0]] = msg.data[1]\nNote that in reality the contract code is written in the low-level EVM code; this example is written in Serpent,\nour high-level language, for clarity, and can be compiled down to EVM code. Suppose that the contract's\nstorage starts off empty, and a transaction is sent with 10 ether value, 2000 gas, 0.001 ether gasprice, and\ntwo data fields: [ 2, 'CHARLIE' ][3]. The process for the state transition function in this case is as follows:\n1. Check that the transaction is valid and well formed.\n2. Check that the transaction sender has at least 2000 * 0.001 = 2 ether. If it is, then subtract 2 ether\nfrom the sender's account.\n3. Initialize gas = 2000; assuming the transaction is 170 bytes long and the byte-fee is 5, subtract\n850 so that there is 1150 gas left.\n4. Subtract 10 more ether from the sender's account, and add it to the contract's account.\n5. Run the code. In this case, this is simple: it checks if the contract's storage at index 2 is used,\nnotices that it is not, and so it sets the storage at index 2 to the value CHARLIE. Suppose this takes\n187 gas, so the remaining amount of gas is 1150 - 187 = 963\n6. Add 963 * 0.001 = 0.963 ether back to the sender's account, and return the resulting state.\nIf there was no contract at the receiving end of the transaction, then the total transaction fee would simply be\nequal to the provided GASPRICE multiplied by the length of the transaction in bytes, and the data sent\nalongside the transaction would be irrelevant. Additionally, note that contract-initiated messages can assign\na gas limit to the computation that they spawn, and if the sub-computation runs out of gas it gets reverted\nonly to the point of the message call. Hence, just like transactions, contracts can secure their limited\ncomputational resources by setting strict limits on the sub-computations that they spawn.\nPage 16\nethereum.org",
    "source":"whitepaper",
    "section":"Ethereum State Transition Function (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":348.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_33",
    "content":"# Ethereum State Transition Function (Part 3)\n\n--- Page 17 ---",
    "source":"whitepaper",
    "section":"Ethereum State Transition Function (Part 3)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_34",
    "content":"# Code Execution (Part 1)\n\nThe code in Ethereum contracts is written in a low-level, stack-based bytecode language, referred to as\n\"Ethereum virtual machine code\" or \"EVM code\". The code consists of a series of bytes, where each byte\nrepresents an operation. In general, code execution is an infinite loop that consists of repeatedly carrying out\nthe operation at the current program counter (which begins at zero) and then incrementing the program\ncounter by one, until the end of the code is reached or an error or STOP or RETURN instruction is detected. The\noperations have access to three types of space in which to store data:\n\u25cf The stack, a last-in-first-out container to which 32-byte values can be pushed and popped\n\u25cf Memory, an infinitely expandable byte array\n\u25cf The contract's long-term storage, a key\/value store where keys and values are both 32\nbytes. Unlike stack and memory, which reset after computation ends, storage persists for the long\nterm.\nThe code can also access the value, sender and data of the incoming message, as well as block header data,\nand the code can also return a byte array of data as an output.\nThe formal execution model of EVM code is surprisingly simple. While the Ethereum virtual machine is\nrunning, its full computational state can be defined by the tuple (block_state, transaction, message, code,\nmemory, stack, pc, gas), where block_state is the global state containing all accounts and includes balances\nand storage. Every round of execution, the current instruction is found by taking the pc-th byte of code, and\neach instruction has its own definition in terms of how it affects the tuple. For example, ADD pops two items off\nthe stack and pushes their sum, reduces gas by 1 and increments pc by 1, and SSTORE pushes the top two\nitems off the stack and inserts the second item into the contract's storage at the index specified by the first\nitem, as well as reducing gas by up to 200 and incrementing pc by 1. Although there are many ways to\noptimize Ethereum via just-in-time compilation, a basic implementation of Ethereum can be done in a few\nhundred lines of code.\nPage 17\nethereum.org",
    "source":"whitepaper",
    "section":"Code Execution (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":361.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_35",
    "content":"# Code Execution (Part 2)\n\n--- Page 18 ---",
    "source":"whitepaper",
    "section":"Code Execution (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_36",
    "content":"# Blockchain and Mining\n\nThe Ethereum blockchain is in many ways similar to the Bitcoin blockchain, although it does have some\ndifferences. The main difference between Ethereum and Bitcoin with regard to the blockchain architecture is\nthat, unlike Bitcoin, Ethereum blocks contain a copy of both the transaction list and the most recent state.\nAside from that, two other values, the block number and the difficulty, are also stored in the block. The block\nvalidation algorithm in Ethereum is as follows:\n1. Check if the previous block referenced exists and is valid.",
    "source":"whitepaper",
    "section":"Blockchain and Mining",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":88.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_37",
    "content":"# 2. Check that the timestamp of the block is greater than that of the referenced previous block and (Part 1)\n\nless than 15 minutes into the future\n3. Check that the block number, difficulty, transaction root, uncle root and gas limit (various low-level\nEthereum-specific concepts) are valid.\n4. Check that the proof of work on the block is valid.\n5. Let S[0] be the STATE_ROOT of the previous block.\n6. Let TX be the block's transaction list, with n transactions. For all in in 0...n-1, setS[i+1] =\nAPPLY(S[i],TX[i]). If any applications returns an error, or if the total gas consumed in the block up\nuntil this point exceeds the GASLIMIT, return an error.\n7. Let S_FINAL be S[n], but adding the block reward paid to the miner.\n8. Check if S_FINAL is the same as the STATE_ROOT. If it is, the block is valid; otherwise, it is not valid.\nPage 18\nethereum.org",
    "source":"whitepaper",
    "section":"2. Check that the timestamp of the block is greater than that of the referenced previous block and (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":132.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_38",
    "content":"# 2. Check that the timestamp of the block is greater than that of the referenced previous block and (Part 2)\n\n--- Page 19 ---\nThe approach may seem highly inefficient at first glance, because it needs to store the entire state with each\nblock, but in reality efficiency should be comparable to that of Bitcoin. The reason is that the state is stored in\nthe tree structure, and after every block only a small part of the tree needs to be changed. Thus, in general,\nbetween two adjacent blocks the vast majority of the tree should be the same, and therefore the data can be\nstored once and referenced twice using pointers (ie. hashes of subtrees). A special kind of tree known as a\n\"Patricia tree\" is used to accomplish this, including a modification to the Merkle tree concept that allows for\nnodes to be inserted and deleted, and not just changed, efficiently. Additionally, because all of the state\ninformation is part of the last block, there is no need to store the entire blockchain history - a strategy which, if\nit could be applied to Bitcoin, can be calculated to provide 5-20x savings in space.",
    "source":"whitepaper",
    "section":"2. Check that the timestamp of the block is greater than that of the referenced previous block and (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":176.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_39",
    "content":"# Applications\n\nIn general, there are three types of applications on top of Ethereum. The first category is financial applications,\nproviding users with more powerful ways of managing and entering into contracts using their money. This\nincludes sub-currencies, financial derivatives, hedging contracts, savings wallets, wills, and ultimately even\nsome classes of full-scale employment contracts. The second category is semi-financial applications, where\nmoney is involved but there is also a heavy non-monetary side to what is being done; a perfect example is\nself-enforcing bounties for solutions to computational problems. Finally, there are applications such as online\nvoting and decentralized governance that are not financial at all.",
    "source":"whitepaper",
    "section":"Applications",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":103.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_40",
    "content":"# Token Systems (Part 1)\n\nOn-blockchain token systems have many applications ranging from sub-currencies representing assets such\nas USD or gold to company stocks, individual tokens representing smart property, secure unforgeable coupons,\nand even token systems with no ties to conventional value at all, used as point systems for incentivization.\nToken systems are surprisingly easy to implement in Ethereum. The key point to understand is that all a\ncurrency, or token systen, fundamentally is is a database with one operation: subtract X units from A and give\nX units to B, with the proviso that (i) X had at least X units before the transaction and (2) the transaction is\napproved by A. All that it takes to implement a token system is to implement this logic into a contract.\nPage 19\nethereum.org",
    "source":"whitepaper",
    "section":"Token Systems (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":128.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_41",
    "content":"# Token Systems (Part 2)\n\n--- Page 20 ---\nThe basic code for implementing a token system in Serpent looks as follows:\nfrom = msg.sender\nto = msg.data[0]\nvalue = msg.data[1]\nif contract.storage[from] >= value:\ncontract.storage[from] = contract.storage[from] \u00ad value\ncontract.storage[to] = contract.storage[to] + value\nThis is essentially a literal implementation of the \"banking system\" state transition function described further\nabove in this document. A few extra lines of code need to be added to provide for the initial step of distributing\nthe currency units in the first place and a few other edge cases, and ideally a function would be added to let\nother contracts query for the balance of an address. But that's all there is to it. Theoretically, Ethereum-based\ntoken systems acting as sub-currencies can potentially include another important feature that on-chain\nBitcoin-based meta-currencies lack: the ability to pay transaction fees directly in that currency. The way this",
    "source":"whitepaper",
    "section":"Token Systems (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":146.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_42",
    "content":"# would be implemented is that the contract would maintain an ether balance with which it would refund ether (Part 1)\n\nused to pay fees to the sender, and it would refill this balance by collecting the internal currency units that it\ntakes in fees and reselling them in a constant running auction. Users would thus need to \"activate\" their\naccounts with ether, but once the ether is there it would be reusable because the contract would refund it each\ntime.\nFinancial derivatives and Stable-Value Currencies\nFinancial derivatives are the most common application of a \"smart contract\", and one of the simplest to\nimplement in code. The main challenge in implementing financial contracts is that the majority of them\nrequire reference to an external price ticker; for example, a very desirable application is a smart contract that\nhedges against the volatility of ether (or another cryptocurrency) with respect to the US dollar, but doing this\nrequires the contract to know what the value of ETH\/USD is. The simplest way to do this is through a \"data\nfeed\" contract maintained by a specific party (eg. NASDAQ) designed so that that party has the ability to\nupdate the contract as needed, and providing an interface that allows other contracts to send a message to\nthat contract and get back a response that provides the price.\nGiven that critical ingredient, the hedging contract would look as follows:\n1. Wait for party A to input 1000 ether.\n2. Wait for party B to input 1000 ether.\n3. Record the USD value of 1000 ether, calculated by querying the data feed contract, in storage, say this\nis $x.\n4. After 30 days, allow A or B to \"ping\" the contract in order to send $x worth of ether (calculated by\nquerying the data feed contract again to get the new price) to A and the rest to B.\nPage 20\nethereum.org",
    "source":"whitepaper",
    "section":"would be implemented is that the contract would maintain an ether balance with which it would refund ether (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":295.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_43",
    "content":"# would be implemented is that the contract would maintain an ether balance with which it would refund ether (Part 2)\n\n--- Page 21 ---\nSuch a contract would have significant potential in crypto-commerce. One of the main problems cited about\ncryptocurrency is the fact that it's volatile; although many users and merchants may want the security and\nconvenience of dealing with cryptographic assets, they many not wish to face that prospect of losing 23% of\nthe value of their funds in a single day. Up until now, the most commonly proposed solution has been\nissuer-backed assets; the idea is that an issuer creates a sub-currency in which they have the right to issue\nand revoke units, and provide one unit of the currency to anyone who provides them (offline) with one unit of a\nspecified underlying asset (eg. gold, USD). The issuer then promises to provide one unit of the underlying\nasset to anyone who sends back one unit of the crypto-asset. This mechanism allows any non-cryptographic\nasset to be \"uplifted\" into a cryptographic asset, provided that the issuer can be trusted.\nIn practice, however, issuers are not always trustworthy, and in some cases the banking infrastructure is too\nweak, or too hostile, for such services to exist. Financial derivatives provide an alternative. Here, instead of a\nsingle issuer providing the funds to back up an asset, a decentralized market of speculators, betting that the\nprice of a cryptographic reference asset will go up, plays that role. Unlike issuers, speculators have no option to\ndefault on their side of the bargain because the hedging contract holds their funds in escrow. Note that this\napproach is not fully decentralized, because a trusted source is still needed to provide the price ticker,",
    "source":"whitepaper",
    "section":"would be implemented is that the contract would maintain an ether balance with which it would refund ether (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":270.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_44",
    "content":"# although arguably even still this is a massive improvement in terms of reducing infrastructure requirements\n\n(unlike being an issuer, issuing a price feed requires no licenses and can likely be categorized as free speech)\nand reducing the potential for fraud.\nPage 21\nethereum.org\n\n--- Page 22 ---",
    "source":"whitepaper",
    "section":"although arguably even still this is a massive improvement in terms of reducing infrastructure requirements",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":32.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_45",
    "content":"# Identity and Reputation Systems (Part 1)\n\nThe earliest alternative cryptocurrency of all, Namecoin, attempted to use a Bitcoin-like blockchain to provide a\nname registration system, where users can register their names in a public database alongside other data.\nThe major cited use case is for a DNS system, mapping domain names like \"bitcoin.org\" (or, in Namecoin's\ncase, \"bitcoin.bit\") to an IP address. Other use cases include email authentication and potentially more\nadvanced reputation systems. Here is the basic contract to provide a Namecoin-like name registration system\non Ethereum:\nif !contract.storage[tx.data[0]]:\ncontract.storage[tx.data[0]] = tx.data[1]\nThe contract is very simple; all it is is a database inside the Ethereum network that can be added to, but not\nmodified or removed from. Anyone can register a name with some value, and that registration then sticks\nforever. A more sophisticated name registration contract will also have a \"function clause\" allowing other\ncontracts to query it, as well as a mechanism for the \"owner\" (ie. the first registerer) of a name to change the\ndata or transfer ownership. One can even add reputation and web-of-trust functionality on top.",
    "source":"whitepaper",
    "section":"Identity and Reputation Systems (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":177.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_46",
    "content":"# Decentralized File Storage (Part 1)\n\nOver the past few years, there have emerged a number of popular online file storage startups, the most\nprominent being Dropbox, seeking to allow users to upload a backup of their hard drive and have the service\nstore the backup and allow the user to access it in exchange for a monthly fee. However, at this point the file\nstorage market is at times relatively inefficient; a cursory look at various existing solutions shows that,\nparticularly at the \"uncanny valley\" 20-200 GB level at which neither free quotas nor enterprise-level discounts\nkick in, monthly prices for mainstream file storage costs are such that you are paying for more than the cost of\nthe entire hard drive in a single month. Ethereum contracts can allow for the development of a decentralized\nfile storage ecosystem, where individual users can earn small quantities of money by renting out their own\nhard drives and unused space can be used to further drive down the costs of file storage.\nThe key underpinning piece of such a device would be what we have termed the \"decentralized Dropbox\ncontract\". This contract works as follows. First, one splits the desired data up into blocks, encrypting each block\nfor privacy, and builds a Merkle tree out of it. One then makes a contract with the rule that, every N blocks, the\ncontract would pick a random index in the Merkle tree (using the previous block hash, accessible from\ncontract code, as a source of randomness), and give X ether to the first entity to supply a transaction with a\nPage 22\nethereum.org",
    "source":"whitepaper",
    "section":"Decentralized File Storage (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":263.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_47",
    "content":"# Decentralized File Storage (Part 2)\n\n--- Page 23 ---\nsimplified payment verification-like proof of ownership of the block at that particular index in the tree. When a\nuser wants to re-download their file, they can use a micropayment channel protocol (eg. pay 1 szabo per 32\nkilobytes) to recover the file; the most fee-efficient approach is for the payer not to publish the transaction until\nthe end, instead replacing the transaction with a slightly more lucrative one with the same nonce after every\n32 kilobytes.\nAn important feature of the protocol is that, although it may seem like one is trusting many random nodes not\nto decide to forget the file, one can reduce that risk down to near-zero by splitting the file into many pieces via\nsecret sharing, and watching the contracts to see each piece is still in some node's possession. If a contract is\nstill paying out money, that provides a cryptographic proof that someone out there is still storing the file.",
    "source":"whitepaper",
    "section":"Decentralized File Storage (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":160.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_48",
    "content":"# Decentralized Autonomous Organizations (Part 1)\n\nThe general concept of a \"decentralized organization\" is that of a virtual entity that has a certain set of\nmembers or shareholders which, perhaps with a 67% majority, have the right to spend the entity's funds and\nmodify its code. The members would collectively decide on how the organization should allocate its funds.\nMethods for allocating a DAO's funds could range from bounties, salaries to even more exotic mechanisms\nsuch as an internal currency to reward work. This essentially replicates the legal trappings of a traditional\ncompany or nonprofit but using only cryptographic blockchain technology for enforcement. So far much of the\ntalk around DAOs has been around the \"capitalist\" model of a \"decentralized autonomous corporation\" (DAC)\nwith dividend-receiving shareholders and tradable shares; an alternative, perhaps described as a\n\"decentralized autonomous community\", would have all members have an equal share in the decision\nmaking and require 67% of existing members to agree to add or remove a member. The requirement that one\nperson can only have one membership would then need to be enforced collectively by the group.\nA general outline for how to code a DO is as follows. The simplest design is simply a piece of self-modifying\ncode that changes if two thirds of members agree on a change. Although code is theoretically immutable, one\ncan easily get around this and have de-facto mutability by having chunks of the code in separate contracts,\nand having the address of which contracts to call stored in the modifiable storage. In a simple\nimplementation of such a DAO contract, there would be three transaction types, distinguished by the data\nprovided in the transaction:\n\u25cf [0,i,K,V] to register a proposal with index i to change the address at storage index K to",
    "source":"whitepaper",
    "section":"Decentralized Autonomous Organizations (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":290.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_49",
    "content":"# value V (Part 1)\n\n\u25cf [0,i] to register a vote in favor of proposal i\n\u25cf [2,i] to finalize proposal i if enough votes have been made\nThe contract would then have clauses for each of these. It would maintain a record of all open storage\nchanges, along with a list of who voted for them. It would also have a list of all members. When any storage\nPage 23\nethereum.org",
    "source":"whitepaper",
    "section":"value V (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":67.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_50",
    "content":"# value V (Part 2)\n\n--- Page 24 ---\nchange gets to two thirds of members voting for it, a finalizing transaction could execute the change. A more\nsophisticated skeleton would also have built-in voting ability for features like sending a transaction, adding\nmembers and removing members, and may even provide for Liquid Democracy-style vote delegation (ie.\nanyone can assign someone to vote for them, and assignment is transitive so if A assigns B and B assigns C\nthen C determines A's vote). This design would allow the DO to grow organically as a decentralized\ncommunity, allowing people to eventually delegate the task of filtering out who is a member to specialists,\nalthough unlike in the \"current system\" specialists can easily pop in and out of existence over time as\nindividual community members change their alignments.\nAn alternative model is for a decentralized corporation, where any account can have zero or more shares, and\ntwo thirds of the shares are required to make a decision. A complete skeleton would involve asset\nmanagement functionality, the ability to make an offer to buy or sell shares, and the ability to accept offers\n(preferably with an order-matching mechanism inside the contract). Delegation would also exist Liquid\nDemocracy-style, generalizing the concept of a \"board of directors\".\nIn the future, more advanced mechanisms for organizational governance may be implemented; it is at this\npoint that a decentralized organization (DO) can start to be described as a decentralized autonomous\norganization (DAO). The difference between a DO and a DAO is fuzzy, but the general dividing line is whether\nthe governance is generally carried out via a political-like process or an \u201cautomatic\u201d process; a good intuitive\ntest is the \u201cno common language\u201d criterion: can the organization still function if no two members spoke the\nsame language? Clearly, a simple traditional shareholder-style corporation would fail, whereas something like\nthe Bitcoin protocol would be much more likely to succeed. Robin Hanson\u2019s futarchy, a mechanism for\norganizational governance via prediction markets, is a good example of what truly \u201cautonomous\u201d governance\nmight look like. Note that one should not necessarily assume that all DAOs are superior to all DOs; automation",
    "source":"whitepaper",
    "section":"value V (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":354.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_51",
    "content":"# is simply a paradigm that is likely to have have very large benefits in certain particular places and may not be\n\npractical in others, and many semi-DAOs are also likely to exist.",
    "source":"whitepaper",
    "section":"is simply a paradigm that is likely to have have very large benefits in certain particular places and may not be",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":11.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_52",
    "content":"# Further Applications (Part 1)\n\n1. Savings wallets. Suppose that Alice wants to keep her funds safe, but is worried that she will lose or\nsomeone will hack her private key. She puts ether into a contract with Bob, a bank, as follows:\n\u25cf Alice alone can withdraw a maximum of 1% of the funds per day.\n\u25cf Bob alone can withdraw a maximum of 1% of the funds per day, but Alice has the ability to make a\ntransaction with her key shutting off this ability.\n\u25cf Alice and Bob together can withdraw anything.\nNormally, 1% per day is enough for Alice, and if Alice wants to withdraw more she can contact Bob for help. If\nAlice's key gets hacked, she runs to Bob to move the funds to a new contract. If she loses her key, Bob will get\nthe funds out eventually. If Bob turns out to be malicious, then she can turn off his ability to withdraw.\nPage 24\nethereum.org",
    "source":"whitepaper",
    "section":"Further Applications (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":159.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_53",
    "content":"# Further Applications (Part 2)\n\n--- Page 25 ---\n2. Crop insurance. One can easily make a financial derivatives contract but using a data feed of the weather\ninstead of any price index. If a farmer in Iowa purchases a derivative that pays out inversely based on the\nprecipitation in Iowa, then if there is a drought, the farmer will automatically receive money and if there is\nenough rain the farmer will be happy because their crops would do well.\n3. A decentralized data feed. For financial contracts for difference, it may actually be possible to decentralize\nthe data feed via a protocol called \"SchellingCoin\". SchellingCoin basically works as follows: N parties all put\ninto the system the value of a given datum (eg. the ETH\/USD price), the values are sorted, and everyone\nbetween the 25th and 75th percentile gets one token as a reward. Everyone has the incentive to provide the\nanswer that everyone else will provide, and the only value that a large number of players can realistically\nagree on is the obvious default: the truth. This creates a decentralized protocol that can theoretically provide\nany number of values, including the ETH\/USD price, the temperature in Berlin or even the result of a particular\nhard computation.\n4. Smart multi-signature escrow. Bitcoin allows multisignature transaction contracts where, for example,\nthree out of a given five keys can spend the funds. Ethereum allows for more granularity; for example, four out\nof five can spend everything, three out of five can spend up to 10% per day, and two out of five can spend up to\n0.5% per day. Additionally, Ethereum multisig is asynchronous - two parties can register their signatures on\nthe blockchain at different times and the last signature will automatically send the transaction.\n5. Cloud computing. The EVM technology can also be used to create a verifiable computing environment,",
    "source":"whitepaper",
    "section":"Further Applications (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":306.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_54",
    "content":"# allowing users to ask others to carry out computations and then optionally ask for proofs that computations at (Part 1)\n\ncertain randomly selected checkpoints were done correctly. This allows for the creation of a cloud computing\nmarket where any user can participate with their desktop, laptop or specialized server, and spot-checking\ntogether with security deposits can be used to ensure that the system is trustworthy (ie. nodes cannot\nprofitably cheat). Although such a system may not be suitable for all tasks; tasks that require a high level of\ninter-process communication, for example, cannot easily be done on a large cloud of nodes. Other tasks,\nhowever, are much easier to parallelize; projects like SETI@home, folding@home and genetic algorithms can\neasily be implemented on top of such a platform.\n6. Peer-to-peer gambling. Any number of peer-to-peer gambling protocols, such as Frank Stajano and\nRichard Clayton's Cyberdice, can be implemented on the Ethereum blockchain. The simplest gambling\nprotocol is actually simply a contract for difference on the next block hash, and more advanced protocols can\nbe built up from there, creating gambling services with near-zero fees that have no ability to cheat.\n7. Prediction markets. Provided an oracle or SchellingCoin, prediction markets are also easy to implement,",
    "source":"whitepaper",
    "section":"allowing users to ask others to carry out computations and then optionally ask for proofs that computations at (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":184.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_55",
    "content":"# and prediction markets together with SchellingCoin may prove to be the first mainstream application of\n\nfutarchy as a governance protocol for decentralized organizations.\n8. On-chain decentralized marketplaces, using the identity and reputation system as a base.\nPage 25\nethereum.org\n\n--- Page 26 ---",
    "source":"whitepaper",
    "section":"and prediction markets together with SchellingCoin may prove to be the first mainstream application of",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":28.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_56",
    "content":"# Miscellanea And Concerns\n\n",
    "source":"whitepaper",
    "section":"Miscellanea And Concerns",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_57",
    "content":"# Modified GHOST Implementation (Part 1)\n\nThe \"Greedy Heaviest Observed Subtree\" (GHOST) protocol is an innovation first introduced by Yonatan\nSompolinsky and Aviv Zohar in December 2013. The motivation behind GHOST is that blockchains with fast\nconfirmation times currently suffer from reduced security due to a high stale rate - because blocks take a\ncertain time to propagate through the network, if miner A mines a block and then miner B happens to mine\nanother block before miner A's block propagates to B, miner B's block will end up wasted and will not contribute\nto network security. Furthermore, there is a centralization issue: if miner A is a mining pool with 30%\nhashpower and B has 10% hashpower, A will have a risk of producing a stale block 70% of the time (since the\nother 30% of the time A produced the last block and so will get mining data immediately) whereas B will have\na risk of producing a stale block 90% of the time. Thus, if the block interval is short enough for the stale rate to\nbe high, A will be substantially more efficient simply by virtue of its size. With these two effects combined,",
    "source":"whitepaper",
    "section":"Modified GHOST Implementation (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":192.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_58",
    "content":"# blockchains which produce blocks quickly are very likely to lead to one mining pool having a large enough (Part 1)\n\npercentage of the network hashpower to have de facto control over the mining process.\nAs described by Sompolinsky and Zohar, GHOST solves the first issue of network security loss by including\nstale blocks in the calculation of which chain is the \"longest\"; that is to say, not just the parent and further\nancestors of a block, but also the stale children of the block's ancestors (in Ethereum jargon, \"uncles\") are\nadded to the calculation of which block has the largest total proof of work backing it. To solve the second issue\nof centralization bias, we go beyond the protocol described by Sompolinsky and Zohar, and also allow stales to\nbe registered into the main chain to receive a block reward: a stale block receives 93.75% of its base reward,\nand the nephew that includes the stale block receives the remaining 6.25%. Transaction fees, however, are not\nawarded to uncles.\nEthereum implements a simplified version of GHOST which only goes down five levels. Specifically, a stale\nblock can only be included as an uncle by the 2nd to 5th generation child of its parent, and not any block with\na more distant relation (eg. 6th generation child of a parent, or 3rd generation child of a grandparent). This\nwas done for several reasons. First, unlimited GHOST would include too many complications into the\ncalculation of which uncles for a given block are valid. Second, unlimited GHOST with compensation as used",
    "source":"whitepaper",
    "section":"blockchains which produce blocks quickly are very likely to lead to one mining pool having a large enough (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":239.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_59",
    "content":"# in Ethereum removes the incentive for a miner to mine on the main chain and not the chain of a public\n\nattacker. Finally, calculations show that five-level GHOST with incentivization is over 95% efficient even with a\n15s block time, and miners with 25% hashpower show centralization gains of less than 3%.\nPage 26\nethereum.org\n\n--- Page 27 ---",
    "source":"whitepaper",
    "section":"in Ethereum removes the incentive for a miner to mine on the main chain and not the chain of a public",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":38.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_60",
    "content":"# Fees\n\n",
    "source":"whitepaper",
    "section":"Fees",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_61",
    "content":"# Because every transaction published into the blockchain imposes on the network the cost of needing to (Part 1)\n\ndownload and verify it, there is a need for some regulatory mechanism, typically involving transaction fees, to\nprevent abuse. The default approach, used in Bitcoin, is to have purely voluntary fees, relying on miners to act\nas the gatekeepers and set dynamic minimums. This approach has been received very favorably in the\nBitcoin community particularly because it is \"market-based\", allowing supply and demand between miners\nand transaction senders determine the price. The problem with this line of reasoning is, however, that\ntransaction processing is not a market; although it is intuitively attractive to construe transaction processing\nas a service that the miner is offering to the sender, in reality every transaction that a miner includes will need\nto be processed by every node in the network, so the vast majority of the cost of transaction processing is borne\nby third parties and not the miner that is making the decision of whether or not to include it. Hence,\ntragedy-of-the-commons problems are very likely to occur.\nHowever, as it turns out this flaw in the market-based mechanism, when given a particular inaccurate\nsimplifying assumption, magically cancels itself out. The argument is as follows. Suppose that:\n1. A transaction leads to k operations, offering the reward kR to any miner that includes it where R is\nset by the sender and k and R are (roughly) visible to the miner beforehand.\n2. An operation has a processing cost of C to any node (ie. all nodes have equal efficiency)\n3. There are N mining nodes, each with exactly equal processing power (ie. 1\/N of total)\n4. No non-mining full nodes exist.\nA miner would be willing to process a transaction if the expected reward is greater than the cost. Thus, the\nexpected reward is kR\/N since the miner has a 1\/N chance of processing the next block, and the processing\ncost for the miner is simply kC. Hence, miners will include transactions where kR\/N > kC, or R > NC. Note that R\nis the per-operation fee provided by the sender, and is thus a lower bound on the benefit that the sender derives\nfrom the transaction, and NC is the cost to the entire network together of processing an operation. Hence,",
    "source":"whitepaper",
    "section":"Because every transaction published into the blockchain imposes on the network the cost of needing to (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":370.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_62",
    "content":"# miners have the incentive to include only those transactions for which the total utilitarian benefit exceeds the\n\ncost.\nHowever, there are several important deviations from those assumptions in reality:\n1. The miner does pay a higher cost to process the transaction than the other verifying nodes, since",
    "source":"whitepaper",
    "section":"miners have the incentive to include only those transactions for which the total utilitarian benefit exceeds the",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":30.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_63",
    "content":"# the extra verification time delays block propagation and thus increases the chance the block will (Part 1)\n\nbecome a stale.\n2. There do exist non-mining full nodes.\nPage 27\nethereum.org",
    "source":"whitepaper",
    "section":"the extra verification time delays block propagation and thus increases the chance the block will (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":13.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_64",
    "content":"# the extra verification time delays block propagation and thus increases the chance the block will (Part 2)\n\n--- Page 28 ---\n3. The mining power distribution may end up radically inegalitarian in practice.\n4. Speculators, political enemies and crazies whose utility function includes causing harm to the\nnetwork do exist, and they can cleverly set up contracts whose cost is much lower than the cost\npaid by other verifying nodes.\nPoint 1 above provides a tendency for the miner to include fewer transactions, and point 2 increases NC;\nhence, these two effects at least partially cancel each other out. Points 3 and 4 are the major issue; to solve\nthem we simply institute a floating cap: no block can have more operations than BLK_LIMIT_FACTOR times the\nlong-term exponential moving average. Specifically:\nblk.oplimit = floor((blk.parent.oplimit * (EMAFACTOR - 1) + floor(parent.opcount * BLK_LIMIT_FACTOR)) \/\nEMA_FACTOR)\nBLK_LIMIT_FACTOR and EMA_FACTOR are constants that will be set to 65536 and 1.5 for the time being, but\nwill likely be changed after further analysis.\nComputation And Turing-Completeness\nAn important note is that the Ethereum virtual machine is Turing-complete; this means that EVM code can\nencode any computation that can be conceivably carried out, including infinite loops. EVM code allows looping\nin two ways. First, there is a JUMP instruction that allows the program to jump back to a previous spot in the\ncode, and a JUMPI instruction to do conditional jumping, allowing for statements like while x < 27: x = x * 2.\nSecond, contracts can call other contracts, potentially allowing for looping through recursion. This naturally\nleads to a problem: can malicious users essentially shut miners and full nodes down by forcing them to enter\ninto an infinite loop? The issue arises because of a problem in computer science known as the halting problem:\nthere is no way to tell, in the general case, whether or not a given program will ever halt.\nAs described in the state transition section, our solution works by requiring a transaction to set a maximum\nnumber of computational steps that it is allowed to take, and if execution takes longer computation is reverted\nbut fees are still paid. Messages work in the same way. To show the motivation behind our solution, consider\nthe following examples:\n\u25cf An attacker creates a contract which runs an infinite loop, and then sends a transaction\nactivating that loop to the miner. The miner will process the transaction, running the infinite loop,\nand wait for it to run out of gas. Even though the execution runs out of gas and stops halfway\nthrough, the transaction is still valid and the miner still claims the fee from the attacker for each\ncomputational step.\n\u25cf An attacker creates a very long infinite loop with the intent of forcing the miner to keep",
    "source":"whitepaper",
    "section":"the extra verification time delays block propagation and thus increases the chance the block will (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":451.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_65",
    "content":"# computing for such a long time that by the time computation finishes a few more blocks will have\n\ncome out and it will not be possible for the miner to include the transaction to claim the fee. However,\nPage 28\nethereum.org\n\n--- Page 29 ---",
    "source":"whitepaper",
    "section":"computing for such a long time that by the time computation finishes a few more blocks will have",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":27.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_66",
    "content":"# the attacker will be required to submit a value for STARTGAS limiting the number of computational (Part 1)\n\nsteps that execution can take, so the miner will know ahead of time that the computation will take an\nexcessively large number of steps.\n\u25cf An attacker sees a contract with code of some form like send(A,contract.storage[A]);\ncontract.storage[A] = 0, and sends a transaction with just enough gas to run the first step but not the\nsecond (ie. making a withdrawal but not letting the balance go down). The contract author does not\nneed to worry about protecting against such attacks, because if execution stops halfway through the\nchanges get reverted.\n\u25cf A financial contract works by taking the median of nine proprietary data feeds in order to\nminimize risk. An attacker takes over one of the data feeds, which is designed to be modifiable via\nthe variable-address-call mechanism described in the section on DAOs, and converts it to run an\ninfinite loop, thereby attempting to force any attempts to claim funds from the financial contract to\nrun out of gas. However, the financial contract can set a gas limit on the message to prevent this\nproblem.\nThe alternative to Turing-completeness is Turing-incompleteness, where JUMP and JUMPI do not exist and\nonly one copy of each contract is allowed to exist in the call stack at any given time. With this system, the fee\nsystem described and the uncertainties around the effectiveness of our solution might not be necessary, as\nthe cost of executing a contract would be bounded above by its size. Additionally, Turing-incompleteness is not\neven that big a limitation; out of all the contract examples we have conceived internally, so far only one\nrequired a loop, and even that loop could be removed by making 26 repetitions of a one-line piece of code.\nGiven the serious implications of Turing-completeness, and the limited benefit, why not simply have a\nTuring-incomplete language? In reality, however, Turing-incompleteness is far from a neat solution to the\nproblem. To see why, consider the following contracts:\nC0: call(C1)\u037e call(C1)\u037e\nC1: call(C2)\u037e call(C2)\u037e\nC2: call(C3)\u037e call(C3)\u037e\n...\nC49: call(C50)\u037e call(C50)\u037e\nC50: (run one step of a program and record the change in storage)\nNow, send a transaction to A. Thus, in 51 transactions, we have a contract that takes up 250 computational\nsteps. Miners could try to detect such logic bombs ahead of time by maintaining a value alongside each\ncontract specifying the maximum number of computational steps that it can take, and calculating this for\ncontracts calling other contracts recursively, but that would require miners to forbid contracts that create\nother contracts (since the creation and execution of all 50 contracts above could easily be rolled into a single\ncontract). Another problematic point is that the address field of a message is a variable, so in general it may\nnot even be possible to tell which other contracts a given contract will call ahead of time. Hence, all in all, we\nhave a surprising conclusion: Turing-completeness is surprisingly easy to manage, and the lack of\nPage 29\nethereum.org",
    "source":"whitepaper",
    "section":"the attacker will be required to submit a value for STARTGAS limiting the number of computational (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":495.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_67",
    "content":"# the attacker will be required to submit a value for STARTGAS limiting the number of computational (Part 2)\n\n--- Page 30 ---\nTuring-completeness is equally surprisingly difficult to manage unless the exact same controls are in place -\nbut in that case why not just let the protocol be Turing-complete?",
    "source":"whitepaper",
    "section":"the attacker will be required to submit a value for STARTGAS limiting the number of computational (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":32.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_68",
    "content":"# Currency And Issuance\n\nThe Ethereum network includes its own built-in currency, ether, which serves the dual purpose of providing a\nprimary liquidity layer to allow for efficient exchange between various types of digital assets and, more\nimportantly, of providing a mechanism for paying transaction fees. For convenience and to avoid future\nargument (see the current mBTC\/uBTC\/satoshi debate in Bitcoin), the denominations will be pre-labelled:\n\u25cf 1: wei\n\u25cf 10^12: szabo\n\u25cf 10^15: finney\n\u25cf 10^18: ether\nThis should be taken as an expanded version of the concept of \"dollars\" and \"cents\" or \"BTC\" and \"satoshi\". In the near future, we expect \"ether\" to be\nused for ordinary transactions, \"finney\" for microtransactions and \"szabo\" and \"wei\" for technical discussions around fees and protocol\nimplementation.\nThe issuance model will be as follows:\n\u25cf Ether will be released in a currency sale at the price of 1337-2000 ether per BTC, a",
    "source":"whitepaper",
    "section":"Currency And Issuance",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":145.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_69",
    "content":"# mechanism intended to fund the Ethereum organization and pay for development that has been\n\nused with success by a number of other cryptographic platforms. Earlier buyers will benefit from larger\ndiscounts. The BTC received from the sale will be used entirely to pay salaries and bounties to\ndevelopers, researchers and projects in the cryptocurrency ecosystem.\n\u25cf 0.099x the total amount sold will be allocated to early contributors who participated in\ndevelopment before BTC funding or certainty of funding was available, and another 0.099x will be\nallocated to long-term research projects.\n\u25cf 0.26x the total amount sold will be allocated to miners per year forever after that point.\nPage 30\nethereum.org\n\n--- Page 31 ---",
    "source":"whitepaper",
    "section":"mechanism intended to fund the Ethereum organization and pay for development that has been",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":100.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_70",
    "content":"# Issuance Breakdown\n\n",
    "source":"whitepaper",
    "section":"Issuance Breakdown",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_71",
    "content":"# The permanent linear supply growth model reduces the risk of what some see as excessive wealth\n\nconcentration in Bitcoin, and gives individuals living in present and future eras a fair chance to acquire\ncurrency units, while at the same time discouraging depreciation of ether because the \"supply growth rate\" as\na percentage still tends to zero over time. We also theorize that because coins are always lost over time due to\ncarelessness, death, etc, and coin loss can be modeled as a percentage of the total supply per year, that the",
    "source":"whitepaper",
    "section":"The permanent linear supply growth model reduces the risk of what some see as excessive wealth",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":75.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_72",
    "content":"# total currency supply in circulation will in fact eventually stabilize at a value equal to the annual issuance\n\ndivided by the loss rate (eg. at a loss rate of 1%, once the supply reaches 26X then 0.26X will be mined and\n0.26X lost every year, creating an equilibrium).\nGroup At launch After 1 year After 5 years\nCurrency units 1.198X 1.458X 2.498X\nPurchasers 83.5% 68.6% 40.0%\nEarly contributor distribution 8.26% 6.79% 3.96%\nLong-term endowment 8.26% 6.79% 3.96%\nMiners 0% 17.8% 52.0%\nDespite the linear currency issuance, just like with Bitcoin over time the supply growth rate nevertheless tends\nto zero.\nPage 31\nethereum.org\n\n--- Page 32 ---",
    "source":"whitepaper",
    "section":"total currency supply in circulation will in fact eventually stabilize at a value equal to the annual issuance",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":89.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_73",
    "content":"# Mining Centralization (Part 1)\n\nThe Bitcoin mining algorithm basically works by having miners compute SHA256 on slightly modified\nversions of the block header millions of times over and over again, until eventually one node comes up with a\nversion whose hash is less than the target (currently around 2190). However, this mining algorithm is\nvulnerable to two forms of centralization. First, the mining ecosystem has come to be dominated by ASICs\n(application-specific integrated circuits), computer chips designed for, and therefore thousands of times more\nefficient at, the specific task of Bitcoin mining. This means that Bitcoin mining is no longer a highly\ndecentralized and egalitarian pursuit, requiring millions of dollars of capital to effectively participate in.\nSecond, most Bitcoin miners do not actually perform block validation locally; instead, they rely on a\ncentralized mining pool to provide the block headers. This problem is arguably worse: as of the time of this\nwriting, the top two mining pools indirectly control roughly 50% of processing power in the Bitcoin network,",
    "source":"whitepaper",
    "section":"Mining Centralization (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":164.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_74",
    "content":"# although this is mitigated by the fact that miners can switch to other mining pools if a pool or coalition\n\nattempts a 51% attack.",
    "source":"whitepaper",
    "section":"although this is mitigated by the fact that miners can switch to other mining pools if a pool or coalition",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":4.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_75",
    "content":"# The current intent at Ethereum is to use a mining algorithm based on randomly generating a unique hash (Part 1)\n\nfunction for every 1000 nonces, using a sufficiently broad range of computation to remove the benefit of\nspecialized hardware. Such a strategy will certainly not reduce the gain of centralization to zero, but it does\nnot need to. Note that each individual user, on their private laptop or desktop, can perform a certain quantity of\nmining activity almost for free, paying only electricity costs, but after the point of 100% CPU utilization of their\ncomputer additional mining will require them to pay for both electricity and hardware. ASIC mining companies\nneed to pay for electricity and hardware starting from the first hash. Hence, if the centralization gain can be\nkept to below this ratio, (E + H) \/ E, then even if ASICs are made there will still be room for ordinary miners.\nAdditionally, we intend to design the mining algorithm so that mining requires access to the entire\nblockchain, forcing miners to store the entire blockchain and at least be capable of verifying every transaction.\nThis removes the need for centralized mining pools; although mining pools can still serve the legitimate role\nof evening out the randomness of reward distribution, this function can be served equally well by peer-to-peer\npools with no central control. It additionally helps fight centralization, by increasing the number of full nodes in",
    "source":"whitepaper",
    "section":"The current intent at Ethereum is to use a mining algorithm based on randomly generating a unique hash (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":218.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_76",
    "content":"# the network so that the network remains reasonably decentralized even if most ordinary users prefer light\n\nclients.\nPage 32\nethereum.org\n\n--- Page 33 ---",
    "source":"whitepaper",
    "section":"the network so that the network remains reasonably decentralized even if most ordinary users prefer light",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":8.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_77",
    "content":"# Scalability (Part 1)\n\nOne common concern about Ethereum is the issue of scalability. Like Bitcoin, Ethereum suffers from the flaw\nthat every transaction needs to be processed by every node in the network. With Bitcoin, the size of the current\nblockchain rests at about 20 GB, growing by about 1 MB per hour. If the Bitcoin network were to process Visa's\n2000 transactions per second, it would grow by 1 MB per three seconds (1 GB per hour, 8 TB per year).\nEthereum is likely to suffer a similar growth pattern, worsened by the fact that there will be many applications\non top of the Ethereum blockchain instead of just a currency as is the case with Bitcoin, but ameliorated by the\nfact that Ethereum full nodes need to store just the state instead of the entire blockchain history.\nThe problem with such a large blockchain size is centralization risk. If the blockchain size increases to, say,\n100 TB, then the likely scenario would be that only a very small number of large businesses would run full\nnodes, with all regular users using light SPV nodes. In such a situation, there arises the potential concern that\nthe full nodes could band together and all agree to cheat in some profitable fashion (eg. change the block\nreward, give themselves BTC). Light nodes would have no way of detecting this immediately. Of course, at\nleast one honest full node would likely exist, and after a few hours information about the fraud would trickle out\nthrough channels like Reddit, but at that point it would be too late: it would be up to the ordinary users to\norganize an effort to blacklist the given blocks, a massive and likely infeasible coordination problem on a\nsimilar scale as that of pulling off a successful 51% attack. In the case of Bitcoin, this is currently a problem,\nbut there exists a blockchain modification suggested by Peter Todd which will alleviate this issue.\nIn the near term, Ethereum will use two additional strategies to cope with this problem. First, because of the\nblockchain-based mining algorithms, at least every miner will be forced to be a full node, creating a lower\nbound on the number of full nodes. Second and more importantly, however, we will include an intermediate\nstate tree root in the blockchain after processing each transaction. Even if block validation is centralized, as\nlong as one honest verifying node exists, the centralization problem can be circumvented via a verification\nprotocol. If a miner publishes an invalid block, that block must either be badly formatted, or the state S[n] is\nincorrect. Since S[0] is known to be correct, there must be some first state S[i] that is incorrect where S[i-1] is\ncorrect. The verifying node would provide the index i, along with a \"proof of invalidity\" consisting of the subset\nof Patricia tree nodes needing to process APPLY(S[i-1],TX[i]) -> S[i]. Nodes would be able to use those nodes to\nrun that part of the computation, and see that the S[i] generated does not match the S[i] provided.\nAnother, more sophisticated, attack would involve the malicious miners publishing incomplete blocks, so the\nfull information does not even exist to determine whether or not blocks are valid. The solution to this is a\nchallenge-response protocol: verification nodes issue \"challenges\" in the form of target transaction indices,\nand upon receiving a node a light node treats the block as untrusted until another node, whether the miner or\nanother verifier, provides a subset of Patricia nodes as a proof of validity.\nPage 33\nethereum.org",
    "source":"whitepaper",
    "section":"Scalability (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":591.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_78",
    "content":"# Scalability (Part 2)\n\n--- Page 34 ---\nPutting It All Together: Decentralized Applications",
    "source":"whitepaper",
    "section":"Scalability (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":10.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_79",
    "content":"# The contract mechanism described above allows anyone to build what is essentially a command line (Part 1)\n\napplication run on a virtual machine that is executed by consensus across the entire network, allowing it to\nmodify a globally accessible state as its \u201chard drive\u201d. However, for most people, the command line interface\nthat is the transaction sending mechanism is not sufficiently user-friendly to make decentralization an\nattractive mainstream alternative. To this end, a complete \u201cdecentralized application\u201d should consist of both\nlow-level business-logic components, whether implemented entirely on Ethereum, using a combination of\nEthereum and other systems (eg. a P2P messaging layer, one of which is currently planned to be put into the\nEthereum clients) or other systems entirely, and high-level graphical user interface components. The\nEthereum client\u2019s design is to serve as a web browser, but include support for a \u201ceth\u201d Javascript API object,\nwhich specialized web pages viewed in the client will be able to use to interact with the Ethereum blockchain.\nFrom the point of view of the \u201ctraditional\u201d web, these web pages are entirely static content, since the blockchain",
    "source":"whitepaper",
    "section":"The contract mechanism described above allows anyone to build what is essentially a command line (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":165.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_80",
    "content":"# and other decentralized protocols will serve as a complete replacement for the server for the purpose of\n\nhandling user-initiated requests. Eventually, decentralized protocols, hopefully themselves in some fashion\nusing Ethereum, may be used to store the web pages themselves.",
    "source":"whitepaper",
    "section":"and other decentralized protocols will serve as a complete replacement for the server for the purpose of",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":22.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_81",
    "content":"# Conclusion (Part 1)\n\nThe Ethereum protocol was originally conceived as an upgraded version of a cryptocurrency, providing\nadvanced features such as on-blockchain escrow, withdrawal limits and financial contracts, gambling\nmarkets and the like via a highly generalized programming language. The Ethereum protocol would not\n\"support\" any of the applications directly, but the existence of a Turing-complete programming language\nmeans that arbitrary contracts can theoretically be created for any transaction type or application. What is\nmore interesting about Ethereum, however, is that the Ethereum protocol moves far beyond just currency.\nProtocols and decentralized applications around decentralized file storage, decentralized computation and\ndecentralized prediction markets, among dozens of other such concepts, have the potential to substantially\nincrease the efficiency of the computational industry, and provide a massive boost to other peer-to-peer\nprotocols by adding for the first time an economic layer. Finally, there is also a substantial array of\napplications that have nothing to do with money at all.",
    "source":"whitepaper",
    "section":"Conclusion (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":154.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_82",
    "content":"# The concept of an arbitrary state transition function as implemented by the Ethereum protocol provides for a\n\nplatform with unique potential; rather than being a closed-ended, single-purpose protocol intended for a\nspecific array of applications in data storage, gambling or finance, Ethereum is open-ended by design, and we\nbelieve that it is extremely well-suited to serving as a foundational layer for a very large number of both\nfinancial and non-financial protocols in the years to come.\nPage 34\nethereum.org\n\n--- Page 35 ---",
    "source":"whitepaper",
    "section":"The concept of an arbitrary state transition function as implemented by the Ethereum protocol provides for a",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":66.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_83",
    "content":"# Notes and Further Reading\n\n",
    "source":"whitepaper",
    "section":"Notes and Further Reading",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_84",
    "content":"# Notes\n\n",
    "source":"whitepaper",
    "section":"Notes",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_85",
    "content":"# 1. A sophisticated reader may notice that in fact a Bitcoin address is the hash of the elliptic curve\n\npublic key, and not the public key itself. However, it is in fact perfectly legitimate cryptographic terminology to\nrefer to the pubkey hash as a public key itself. This is because Bitcoin's cryptography can be considered to be a\ncustom digital signature algorithm, where the public key consists of the hash of the ECC pubkey, the signature\nconsists of the ECC pubkey concatenated with the ECC signature, and the verification algorithm involves",
    "source":"whitepaper",
    "section":"1. A sophisticated reader may notice that in fact a Bitcoin address is the hash of the elliptic curve",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":72.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_86",
    "content":"# checking the ECC pubkey in the signature against the ECC pubkey hash provided as a public key and then\n\nverifying the ECC signature against the ECC pubkey.\n2. Technically, the median of the 11 previous blocks.\n3. Internally, 2 and \"CHARLIE\" are both numbers, with the latter being in big-endian base 256\nrepresentation. Numbers can be at least 0 and at most 2^256-1.",
    "source":"whitepaper",
    "section":"checking the ECC pubkey in the signature against the ECC pubkey hash provided as a public key and then",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"complete_section",
    "word_count":44.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_87",
    "content":"# Further Reading (Part 1)\n\n1. Intrinsic value: https:\/\/tinyurl.com\/BitcoinMag-IntrinsicValue\n2. Smart property: https:\/\/en.bitcoin.it\/wiki\/Smart_Property\n3. Smart contracts: https:\/\/en.bitcoin.it\/wiki\/Contracts\n4. B-money: http:\/\/www.weidai.com\/bmoney.txt\n5. Reusable proofs of work: http:\/\/www.finney.org\/~hal\/rpow\/\n6. Secure property titles with owner authority: http:\/\/szabo.best.vwh.net\/securetitle.html\n7. Bitcoin whitepaper: http:\/\/bitcoin.org\/bitcoin.pdf\n8. Namecoin: https:\/\/namecoin.org\/\n9. Zooko's triangle: http:\/\/en.wikipedia.org\/wiki\/Zooko's_triangle\n10. Colored coins whitepaper: https:\/\/tinyurl.com\/coloredcoin-whitepaper\n11. Mastercoin whitepaper: https:\/\/github.com\/mastercoin-MSC\/spec\n12. Decentralized autonomous corporations, Bitcoin Magazine: https:\/\/tinyurl.com\/Bootstrapping-DACs\n13. Simplified payment verification:https:\/\/en.bitcoin.it\/wiki\/Scalability#Simplifiedpaymentverification\n14. Merkle trees: http:\/\/en.wikipedia.org\/wiki\/Merkle_tree\n15. Patricia trees: http:\/\/en.wikipedia.org\/wiki\/Patricia_tree\n16. GHOST: http:\/\/www.cs.huji.ac.il\/~avivz\/pubs\/13\/btc_scalability_full.pdf\n17. StorJ and Autonomous Agents, Jeff Garzik: https:\/\/tinyurl.com\/storj-agents\n18. Mike Hearn on Smart Property at Turing Festival: http:\/\/www.youtube.com\/watch?v=Pu4PAMFPo5Y\nPage 35\nethereum.org",
    "source":"whitepaper",
    "section":"Further Reading (Part 1)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":92.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin_88",
    "content":"# Further Reading (Part 2)\n\n--- Page 36 ---\n19. Ethereum RLP: https:\/\/github.com\/ethereum\/wiki\/wiki\/%5BEnglish%5D-RLP\n20. Ethereum Merkle Patricia trees: https:\/\/github.com\/ethereum\/wiki\/wiki\/%5BEnglish%5D-Patricia-Tree\n21. Peter Todd on Merkle sum trees:http:\/\/sourceforge.net\/p\/bitcoin\/mailman\/message\/31709140\/\nPage 36\nethereum.org",
    "source":"whitepaper",
    "section":"Further Reading (Part 2)",
    "url":null,
    "filename":"Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin",
    "chunk_type":"section_part",
    "word_count":24.0,
    "pdf_pages":36.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/Ethereum_white_paper-a_next_generation_smart_contract_and_decentralized_application_platform-vitalik-buterin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_0",
    "content":"# Satoshi Nakamoto\n\nsatoshin@gmx.com\nwww.bitcoin.org\nAbstract. A purely peer-to-peer version of electronic cash would allow online",
    "source":"whitepaper",
    "section":"Satoshi Nakamoto",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":13.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_1",
    "content":"# payments to be sent directly from one party to another without going through a\n\nfinancial institution. Digital signatures provide part of the solution, but the main\nbenefits are lost if a trusted third party is still required to prevent double-spending.\nWe propose a solution to the double-spending problem using a peer-to-peer network.",
    "source":"whitepaper",
    "section":"payments to be sent directly from one party to another without going through a",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":38.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_2",
    "content":"# The network timestamps transactions by hashing them into an ongoing chain of\n\nhash-based proof-of-work, forming a record that cannot be changed without redoing\nthe proof-of-work. The longest chain not only serves as proof of the sequence of\nevents witnessed, but proof that it came from the largest pool of CPU power. As",
    "source":"whitepaper",
    "section":"The network timestamps transactions by hashing them into an ongoing chain of",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":40.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_3",
    "content":"# long as a majority of CPU power is controlled by nodes that are not cooperating to\n\nattack the network, they'll generate the longest chain and outpace attackers. The\nnetwork itself requires minimal structure. Messages are broadcast on a best effort\nbasis, and nodes can leave and rejoin the network at will, accepting the longest\nproof-of-work chain as proof of what happened while they were gone.",
    "source":"whitepaper",
    "section":"long as a majority of CPU power is controlled by nodes that are not cooperating to",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":49.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_4",
    "content":"# 1. Introduction\n\n",
    "source":"whitepaper",
    "section":"1. Introduction",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_5",
    "content":"# Commerce on the Internet has come to rely almost exclusively on financial institutions serving as (Part 1)\n\ntrusted third parties to process electronic payments. While the system works well enough for\nmost transactions, it still suffers from the inherent weaknesses of the trust based model.\nCompletely non-reversible transactions are not really possible, since financial institutions cannot\navoid mediating disputes. The cost of mediation increases transaction costs, limiting the\nminimum practical transaction size and cutting off the possibility for small casual transactions,\nand there is a broader cost in the loss of ability to make non-reversible payments for nonreversible services. With the possibility of reversal, the need for trust spreads. Merchants must\nbe wary of their customers, hassling them for more information than they would otherwise need.\nA certain percentage of fraud is accepted as unavoidable. These costs and payment uncertainties\ncan be avoided in person by using physical currency, but no mechanism exists to make payments\nover a communications channel without a trusted party.\nWhat is needed is an electronic payment system based on cryptographic proof instead of trust,",
    "source":"whitepaper",
    "section":"Commerce on the Internet has come to rely almost exclusively on financial institutions serving as (Part 1)",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"section_part",
    "word_count":162.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_6",
    "content":"# allowing any two willing parties to transact directly with each other without the need for a trusted\n\nthird party. Transactions that are computationally impractical to reverse would protect sellers\nfrom fraud, and routine escrow mechanisms could easily be implemented to protect buyers. In\nthis paper, we propose a solution to the double-spending problem using a peer-to-peer distributed\ntimestamp server to generate computational proof of the chronological order of transactions. The",
    "source":"whitepaper",
    "section":"allowing any two willing parties to transact directly with each other without the need for a trusted",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":53.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_7",
    "content":"# system is secure as long as honest nodes collectively control more CPU power than any\n\ncooperating group of attacker nodes.\n\n--- Page 2 ---",
    "source":"whitepaper",
    "section":"system is secure as long as honest nodes collectively control more CPU power than any",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":9.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_8",
    "content":"# 2. Transactions\n\nWe define an electronic coin as a chain of digital signatures. Each owner transfers the coin to the",
    "source":"whitepaper",
    "section":"2. Transactions",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":18.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_9",
    "content":"# next by digitally signing a hash of the previous transaction and the public key of the next owner\n\nand adding these to the end of the coin. A payee can verify the signatures to verify the chain of\nownership.",
    "source":"whitepaper",
    "section":"next by digitally signing a hash of the previous transaction and the public key of the next owner",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":21.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_10",
    "content":"# Transaction Transaction Transaction\n\nOwner 1's Owner 2's Owner 3's",
    "source":"whitepaper",
    "section":"Transaction Transaction Transaction",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":6.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_11",
    "content":"# Public Key Public Key Public Key\n\n",
    "source":"whitepaper",
    "section":"Public Key Public Key Public Key",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_12",
    "content":"# Hash Hash Hash\n\n",
    "source":"whitepaper",
    "section":"Hash Hash Hash",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_13",
    "content":"# Verify Verify\n\nOwner 0's Owner 1's Owner 2's",
    "source":"whitepaper",
    "section":"Verify Verify",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":6.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_14",
    "content":"# Signature Signature Signature\n\n",
    "source":"whitepaper",
    "section":"Signature Signature Signature",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_15",
    "content":"# Sign Sign\n\nOwner 1's Owner 2's Owner 3's",
    "source":"whitepaper",
    "section":"Sign Sign",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":6.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_16",
    "content":"# Private Key Private Key Private Key\n\nThe problem of course is the payee can't verify that one of the owners did not double-spend\nthe coin. A common solution is to introduce a trusted central authority, or mint, that checks every\ntransaction for double spending. After each transaction, the coin must be returned to the mint to\nissue a new coin, and only coins issued directly from the mint are trusted not to be double-spent.",
    "source":"whitepaper",
    "section":"Private Key Private Key Private Key",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":68.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_17",
    "content":"# The problem with this solution is that the fate of the entire money system depends on the\n\ncompany running the mint, with every transaction having to go through them, just like a bank.",
    "source":"whitepaper",
    "section":"The problem with this solution is that the fate of the entire money system depends on the",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":16.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_18",
    "content":"# We need a way for the payee to know that the previous owners did not sign any earlier\n\ntransactions. For our purposes, the earliest transaction is the one that counts, so we don't care\nabout later attempts to double-spend. The only way to confirm the absence of a transaction is to\nbe aware of all transactions. In the mint based model, the mint was aware of all transactions and\ndecided which arrived first. To accomplish this without a trusted party, transactions must be\npublicly announced [1], and we need a system for participants to agree on a single history of the\norder in which they were received. The payee needs proof that at the time of each transaction, the\nmajority of nodes agreed it was the first received.",
    "source":"whitepaper",
    "section":"We need a way for the payee to know that the previous owners did not sign any earlier",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":110.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_19",
    "content":"# 3. Timestamp Server\n\nThe solution we propose begins with a timestamp server. A timestamp server works by taking a\nhash of a block of items to be timestamped and widely publishing the hash, such as in a\nnewspaper or Usenet post [2-5]. The timestamp proves that the data must have existed at the\ntime, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in\nits hash, forming a chain, with each additional timestamp reinforcing the ones before it.",
    "source":"whitepaper",
    "section":"3. Timestamp Server",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":80.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_20",
    "content":"# Hash Hash\n\n",
    "source":"whitepaper",
    "section":"Hash Hash",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_21",
    "content":"# Block Block\n\nItem Item ... Item Item ...\n\n--- Page 3 ---\n4. Proof-of-Work\nTo implement a distributed timestamp server on a peer-to-peer basis, we will need to use a proofof-work system similar to Adam Back's Hashcash [6], rather than newspaper or Usenet posts.\nThe proof-of-work involves scanning for a value that when hashed, such as with SHA-256, the\nhash begins with a number of zero bits. The average work required is exponential in the number\nof zero bits required and can be verified by executing a single hash.\nFor our timestamp network, we implement the proof-of-work by incrementing a nonce in the\nblock until a value is found that gives the block's hash the required zero bits. Once the CPU\neffort has been expended to make it satisfy the proof-of-work, the block cannot be changed\nwithout redoing the work. As later blocks are chained after it, the work to change the block\nwould include redoing all the blocks after it.",
    "source":"whitepaper",
    "section":"Block Block",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":159.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_22",
    "content":"# Block Block\n\n",
    "source":"whitepaper",
    "section":"Block Block",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_23",
    "content":"# Prev Hash Nonce Prev Hash Nonce (Part 1)\n\nTx Tx ... Tx Tx ...\nThe proof-of-work also solves the problem of determining representation in majority decision\nmaking. If the majority were based on one-IP-address-one-vote, it could be subverted by anyone\nable to allocate many IPs. Proof-of-work is essentially one-CPU-one-vote. The majority\ndecision is represented by the longest chain, which has the greatest proof-of-work effort invested\nin it. If a majority of CPU power is controlled by honest nodes, the honest chain will grow the\nfastest and outpace any competing chains. To modify a past block, an attacker would have to\nredo the proof-of-work of the block and all blocks after it and then catch up with and surpass the\nwork of the honest nodes. We will show later that the probability of a slower attacker catching up\ndiminishes exponentially as subsequent blocks are added.\nTo compensate for increasing hardware speed and varying interest in running nodes over time,\nthe proof-of-work difficulty is determined by a moving average targeting an average number of\nblocks per hour. If they're generated too fast, the difficulty increases.",
    "source":"whitepaper",
    "section":"Prev Hash Nonce Prev Hash Nonce (Part 1)",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"section_part",
    "word_count":175.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_24",
    "content":"# 5. Network\n\nThe steps to run the network are as follows:\n1) New transactions are broadcast to all nodes.\n2) Each node collects new transactions into a block.\n3) Each node works on finding a difficult proof-of-work for its block.\n4) When a node finds a proof-of-work, it broadcasts the block to all nodes.\n5) Nodes accept the block only if all transactions in it are valid and not already spent.\n6) Nodes express their acceptance of the block by working on creating the next block in the\nchain, using the hash of the accepted block as the previous hash.",
    "source":"whitepaper",
    "section":"5. Network",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":98.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_25",
    "content":"# Nodes always consider the longest chain to be the correct one and will keep working on\n\nextending it. If two nodes broadcast different versions of the next block simultaneously, some\nnodes may receive one or the other first. In that case, they work on the first one they received,\nbut save the other branch in case it becomes longer. The tie will be broken when the next proofof-work is found and one branch becomes longer; the nodes that were working on the other\nbranch will then switch to the longer one.\n\n--- Page 4 ---\nNew transaction broadcasts do not necessarily need to reach all nodes. As long as they reach\nmany nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped\nmessages. If a node does not receive a block, it will request it when it receives the next block and\nrealizes it missed one.",
    "source":"whitepaper",
    "section":"Nodes always consider the longest chain to be the correct one and will keep working on",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":136.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_26",
    "content":"# 6. Incentive\n\nBy convention, the first transaction in a block is a special transaction that starts a new coin owned\nby the creator of the block. This adds an incentive for nodes to support the network, and provides\na way to initially distribute coins into circulation, since there is no central authority to issue them.",
    "source":"whitepaper",
    "section":"6. Incentive",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":53.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_27",
    "content":"# The steady addition of a constant of amount of new coins is analogous to gold miners expending\n\nresources to add gold to circulation. In our case, it is CPU time and electricity that is expended.\nThe incentive can also be funded with transaction fees. If the output value of a transaction is\nless than its input value, the difference is a transaction fee that is added to the incentive value of\nthe block containing the transaction. Once a predetermined number of coins have entered\ncirculation, the incentive can transition entirely to transaction fees and be completely inflation\nfree.\nThe incentive may help encourage nodes to stay honest. If a greedy attacker is able to\nassemble more CPU power than all the honest nodes, he would have to choose between using it\nto defraud people by stealing back his payments, or using it to generate new coins. He ought to\nfind it more profitable to play by the rules, such rules that favour him with more new coins than\neveryone else combined, than to undermine the system and the validity of his own wealth.",
    "source":"whitepaper",
    "section":"The steady addition of a constant of amount of new coins is analogous to gold miners expending",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":166.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_28",
    "content":"# 7. Reclaiming Disk Space\n\nOnce the latest transaction in a coin is buried under enough blocks, the spent transactions before\nit can be discarded to save disk space. To facilitate this without breaking the block's hash,\ntransactions are hashed in a Merkle Tree [7][2][5], with only the root included in the block's hash.\nOld blocks can then be compacted by stubbing off branches of the tree. The interior hashes do\nnot need to be stored.",
    "source":"whitepaper",
    "section":"7. Reclaiming Disk Space",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":71.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_29",
    "content":"# Block Block\n\nBlock Header (Block Hash) Block Header (Block Hash)",
    "source":"whitepaper",
    "section":"Block Block",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":8.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_30",
    "content":"# Prev Hash Nonce Prev Hash Nonce\n\n",
    "source":"whitepaper",
    "section":"Prev Hash Nonce Prev Hash Nonce",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_31",
    "content":"# Root Hash Root Hash\n\nHash01 Hash23 Hash01 Hash23\nHash0 Hash1 Hash2 Hash3 Hash2 Hash3\nTx0 Tx1 Tx2 Tx3 Tx3\nTransactions Hashed in a Merkle Tree After Pruning Tx0-2 from the Block\nA block header with no transactions would be about 80 bytes. If we suppose blocks are\ngenerated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year. With computer systems\ntypically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of\n1.2GB per year, storage should not be a problem even if the block headers must be kept in\nmemory.\n\n--- Page 5 ---",
    "source":"whitepaper",
    "section":"Root Hash Root Hash",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":101.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_32",
    "content":"# 8. Simplified Payment Verification\n\nIt is possible to verify payments without running a full network node. A user only needs to keep\na copy of the block headers of the longest proof-of-work chain, which he can get by querying\nnetwork nodes until he's convinced he has the longest chain, and obtain the Merkle branch\nlinking the transaction to the block it's timestamped in. He can't check the transaction for\nhimself, but by linking it to a place in the chain, he can see that a network node has accepted it,\nand blocks added after it further confirm the network has accepted it.\nLongest Proof-of-Work Chain",
    "source":"whitepaper",
    "section":"8. Simplified Payment Verification",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":101.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_33",
    "content":"# Block Header Block Header Block Header\n\n",
    "source":"whitepaper",
    "section":"Block Header Block Header Block Header",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_34",
    "content":"# Prev Hash Nonce Prev Hash Nonce Prev Hash Nonce\n\n",
    "source":"whitepaper",
    "section":"Prev Hash Nonce Prev Hash Nonce Prev Hash Nonce",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_35",
    "content":"# Merkle Root Merkle Root Merkle Root\n\nHash01 Hash23\nMerkle Branch for Tx3\nHash2 Hash3\nTx3\nAs such, the verification is reliable as long as honest nodes control the network, but is more\nvulnerable if the network is overpowered by an attacker. While network nodes can verify\ntransactions for themselves, the simplified method can be fooled by an attacker's fabricated\ntransactions for as long as the attacker can continue to overpower the network. One strategy to",
    "source":"whitepaper",
    "section":"Merkle Root Merkle Root Merkle Root",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":69.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_36",
    "content":"# protect against this would be to accept alerts from network nodes when they detect an invalid\n\nblock, prompting the user's software to download the full block and alerted transactions to\nconfirm the inconsistency. Businesses that receive frequent payments will probably still want to\nrun their own nodes for more independent security and quicker verification.",
    "source":"whitepaper",
    "section":"protect against this would be to accept alerts from network nodes when they detect an invalid",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":38.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_37",
    "content":"# 9. Combining and Splitting Value\n\nAlthough it would be possible to handle coins individually, it would be unwieldy to make a\nseparate transaction for every cent in a transfer. To allow value to be split and combined,\ntransactions contain multiple inputs and outputs. Normally there will be either a single input\nfrom a larger previous transaction or multiple inputs combining smaller amounts, and at most two\noutputs: one for the payment, and one returning the change, if any, back to the sender.",
    "source":"whitepaper",
    "section":"9. Combining and Splitting Value",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":77.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_38",
    "content":"# Transaction\n\n",
    "source":"whitepaper",
    "section":"Transaction",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_39",
    "content":"# In Out\n\nIn ...\n...\nIt should be noted that fan-out, where a transaction depends on several transactions, and those\ntransactions depend on many more, is not a problem here. There is never the need to extract a\ncomplete standalone copy of a transaction's history.\n\n--- Page 6 ---",
    "source":"whitepaper",
    "section":"In Out",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":47.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_40",
    "content":"# 10. Privacy\n\n",
    "source":"whitepaper",
    "section":"10. Privacy",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_41",
    "content":"# The traditional banking model achieves a level of privacy by limiting access to information to the\n\nparties involved and the trusted third party. The necessity to announce all transactions publicly\nprecludes this method, but privacy can still be maintained by breaking the flow of information in\nanother place: by keeping public keys anonymous. The public can see that someone is sending\nan amount to someone else, but without information linking the transaction to anyone. This is\nsimilar to the level of information released by stock exchanges, where the time and size of\nindividual trades, the \"tape\", is made public, but without telling who the parties were.",
    "source":"whitepaper",
    "section":"The traditional banking model achieves a level of privacy by limiting access to information to the",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":90.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_42",
    "content":"# Traditional Privacy Model\n\n",
    "source":"whitepaper",
    "section":"Traditional Privacy Model",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_43",
    "content":"# Identities Transactions Trusted Counterparty Public\n\n",
    "source":"whitepaper",
    "section":"Identities Transactions Trusted Counterparty Public",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_44",
    "content":"# Third Party\n\n",
    "source":"whitepaper",
    "section":"Third Party",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_45",
    "content":"# New Privacy Model\n\n",
    "source":"whitepaper",
    "section":"New Privacy Model",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_46",
    "content":"# Identities Transactions Public\n\nAs an additional firewall, a new key pair should be used for each transaction to keep them\nfrom being linked to a common owner. Some linking is still unavoidable with multi-input\ntransactions, which necessarily reveal that their inputs were owned by the same owner. The risk\nis that if the owner of a key is revealed, linking could reveal other transactions that belonged to\nthe same owner.",
    "source":"whitepaper",
    "section":"Identities Transactions Public",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":67.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_47",
    "content":"# 11. Calculations\n\n",
    "source":"whitepaper",
    "section":"11. Calculations",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_48",
    "content":"# We consider the scenario of an attacker trying to generate an alternate chain faster than the honest\n\nchain. Even if this is accomplished, it does not throw the system open to arbitrary changes, such\nas creating value out of thin air or taking money that never belonged to the attacker. Nodes are\nnot going to accept an invalid transaction as payment, and honest nodes will never accept a block\ncontaining them. An attacker can only try to change one of his own transactions to take back\nmoney he recently spent.",
    "source":"whitepaper",
    "section":"We consider the scenario of an attacker trying to generate an alternate chain faster than the honest",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":73.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_49",
    "content":"# The race between the honest chain and an attacker chain can be characterized as a Binomial (Part 1)\n\nRandom Walk. The success event is the honest chain being extended by one block, increasing its\nlead by +1, and the failure event is the attacker's chain being extended by one block, reducing the\ngap by -1.\nThe probability of an attacker catching up from a given deficit is analogous to a Gambler's\nRuin problem. Suppose a gambler with unlimited credit starts at a deficit and plays potentially an\ninfinite number of trials to try to reach breakeven. We can calculate the probability he ever\nreaches breakeven, or that an attacker ever catches up with the honest chain, as follows [8]:\np = probability an honest node finds the next block\nq = probability the attacker finds the next block\nq = probability the attacker will ever catch up from z blocks behind\n{ 1 if p\u2264q}\nq =\nz \ue09eq\/p\ue09fz if p\ue085q",
    "source":"whitepaper",
    "section":"The race between the honest chain and an attacker chain can be characterized as a Binomial (Part 1)",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"section_part",
    "word_count":143.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_50",
    "content":"# The race between the honest chain and an attacker chain can be characterized as a Binomial (Part 2)\n\n--- Page 7 ---\nGiven our assumption that p > q, the probability drops exponentially as the number of blocks the\nattacker has to catch up with increases. With the odds against him, if he doesn't make a lucky\nlunge forward early on, his chances become vanishingly small as he falls further behind.",
    "source":"whitepaper",
    "section":"The race between the honest chain and an attacker chain can be characterized as a Binomial (Part 2)",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"section_part",
    "word_count":53.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_51",
    "content":"# We now consider how long the recipient of a new transaction needs to wait before being\n\nsufficiently certain the sender can't change the transaction. We assume the sender is an attacker\nwho wants to make the recipient believe he paid him for a while, then switch it to pay back to\nhimself after some time has passed. The receiver will be alerted when that happens, but the\nsender hopes it will be too late.",
    "source":"whitepaper",
    "section":"We now consider how long the recipient of a new transaction needs to wait before being",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":58.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_52",
    "content":"# The receiver generates a new key pair and gives the public key to the sender shortly before\n\nsigning. This prevents the sender from preparing a chain of blocks ahead of time by working on\nit continuously until he is lucky enough to get far enough ahead, then executing the transaction at\nthat moment. Once the transaction is sent, the dishonest sender starts working in secret on a\nparallel chain containing an alternate version of his transaction.",
    "source":"whitepaper",
    "section":"The receiver generates a new key pair and gives the public key to the sender shortly before",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":59.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_53",
    "content":"# The recipient waits until the transaction has been added to a block and z blocks have been (Part 1)\n\nlinked after it. He doesn't know the exact amount of progress the attacker has made, but\nassuming the honest blocks took the average expected time per block, the attacker's potential\nprogress will be a Poisson distribution with expected value:\n\ue0c1=z\nTo get the probability the attacker could still catch up now, we multiply the Poisson density for\neach amount of progress he could have made by the probability he could catch up from that point:\n\u221e \ue0c1ke\u2212\ue0c1 { \ue09eq\/p\ue09f\ue09ez\u2212k\ue09f if k\u2264z }\n\u2211 \u22c5\nk! 1 if k\ue085z\nk=0\nRearranging to avoid summing the infinite tail of the distribution...\nz \ue0c1ke\u2212\ue0c1\n1\u2212\u2211 \ue09e 1\u2212\ue09eq\/p\ue09f\ue09ez\u2212k\ue09f\ue09f\nk=0\nConverting to C code...\n#include <math.h>\ndouble AttackerSuccessProbability(double q, int z)\ndouble p = 1.0 - q;\ndouble lambda = z * (q \/ p);\ndouble sum = 1.0;\nint i, k;\nfor (k = 0; k <= z; k++)\ndouble poisson = exp(-lambda);\nfor (i = 1; i <= k; i++)\npoisson *= lambda \/ i;\nsum -= poisson * (1 - pow(q \/ p, z - k));\nreturn sum;",
    "source":"whitepaper",
    "section":"The recipient waits until the transaction has been added to a block and z blocks have been (Part 1)",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"section_part",
    "word_count":176.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_54",
    "content":"# The recipient waits until the transaction has been added to a block and z blocks have been (Part 2)\n\n--- Page 8 ---\nRunning some results, we can see the probability drop off exponentially with z.\nq=0.1\nz=0 P=1.0000000\nz=1 P=0.2045873\nz=2 P=0.0509779\nz=3 P=0.0131722\nz=4 P=0.0034552\nz=5 P=0.0009137\nz=6 P=0.0002428\nz=7 P=0.0000647\nz=8 P=0.0000173\nz=9 P=0.0000046\nz=10 P=0.0000012\nq=0.3\nz=0 P=1.0000000\nz=5 P=0.1773523\nz=10 P=0.0416605\nz=15 P=0.0101008\nz=20 P=0.0024804\nz=25 P=0.0006132\nz=30 P=0.0001522\nz=35 P=0.0000379\nz=40 P=0.0000095\nz=45 P=0.0000024\nz=50 P=0.0000006\nSolving for P less than 0.1%...\nP < 0.001\nq=0.10 z=5\nq=0.15 z=8\nq=0.20 z=11\nq=0.25 z=15\nq=0.30 z=24\nq=0.35 z=41\nq=0.40 z=89\nq=0.45 z=340",
    "source":"whitepaper",
    "section":"The recipient waits until the transaction has been added to a block and z blocks have been (Part 2)",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"section_part",
    "word_count":88.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_55",
    "content":"# 12. Conclusion\n\nWe have proposed a system for electronic transactions without relying on trust. We started with\nthe usual framework of coins made from digital signatures, which provides strong control of\nownership, but is incomplete without a way to prevent double-spending. To solve this, we\nproposed a peer-to-peer network using proof-of-work to record a public history of transactions",
    "source":"whitepaper",
    "section":"12. Conclusion",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":56.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_56",
    "content":"# that quickly becomes computationally impractical for an attacker to change if honest nodes\n\ncontrol a majority of CPU power. The network is robust in its unstructured simplicity. Nodes\nwork all at once with little coordination. They do not need to be identified, since messages are\nnot routed to any particular place and only need to be delivered on a best effort basis. Nodes can\nleave and rejoin the network at will, accepting the proof-of-work chain as proof of what\nhappened while they were gone. They vote with their CPU power, expressing their acceptance of",
    "source":"whitepaper",
    "section":"that quickly becomes computationally impractical for an attacker to change if honest nodes",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":81.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_57",
    "content":"# valid blocks by working on extending them and rejecting invalid blocks by refusing to work on\n\nthem. Any needed rules and incentives can be enforced with this consensus mechanism.\n\n--- Page 9 ---",
    "source":"whitepaper",
    "section":"valid blocks by working on extending them and rejecting invalid blocks by refusing to work on",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"complete_section",
    "word_count":17.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_bitcoin_58",
    "content":"# References (Part 1)\n\n[1] W. Dai, \"b-money,\" http:\/\/www.weidai.com\/bmoney.txt, 1998.\n[2] H. Massias, X.S. Avila, and J.-J. Quisquater, \"Design of a secure timestamping service with minimal\ntrust requirements,\" In 20th Symposium on Information Theory in the Benelux, May 1999.\n[3] S. Haber, W.S. Stornetta, \"How to time-stamp a digital document,\" In Journal of Cryptology, vol 3, no\n2, pages 99-111, 1991.\n[4] D. Bayer, S. Haber, W.S. Stornetta, \"Improving the efficiency and reliability of digital time-stamping,\"\nIn Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993.\n[5] S. Haber, W.S. Stornetta, \"Secure names for bit-strings,\" In Proceedings of the 4th ACM Conference\non Computer and Communications Security, pages 28-35, April 1997.\n[6] A. Back, \"Hashcash - a denial of service counter-measure,\"\nhttp:\/\/www.hashcash.org\/papers\/hashcash.pdf, 2002.\n[7] R.C. Merkle, \"Protocols for public key cryptosystems,\" In Proc. 1980 Symposium on Security and\nPrivacy, IEEE Computer Society, pages 122-133, April 1980.\n[8] W. Feller, \"An introduction to probability theory and its applications,\" 1957.",
    "source":"whitepaper",
    "section":"References (Part 1)",
    "url":null,
    "filename":"bitcoin",
    "chunk_type":"section_part",
    "word_count":157.0,
    "pdf_pages":9.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/bitcoin.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_0",
    "content":"# Mining in Logarithmic Space\n\nAggelos Kiayias1, Nikos Leonardos2, and Dionysis Zindros2\n1 University of Edinburgh, IOHK",
    "source":"whitepaper",
    "section":"Mining in Logarithmic Space",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":12.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_1",
    "content":"# 2 University of Athens\n\nAbstract. Blockchains maintain two types of data: Application data\nand consensus data. Towards long-term blockchain scalability, both of\nthesemustbepruned.Whilealargebodyofliteraturehasexploredthe\npruning of application data (UTXOs, account balances, and contract\nstate), little has been said about the permanent pruning of consensus\ndata (block headers). We present a protocol which allows pruning the\nblockchainbygarbagecollectingoldblocksastheybecomeunnecessary.",
    "source":"whitepaper",
    "section":"2 University of Athens",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":51.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_2",
    "content":"# These blocks can simply be discarded and are no longer stored by any\n\nminer. We show that all miners can be light miners with no harm to\nsecurity. Our protocol is based on the notion of superblocks, blocks that\nhaveachievedanunusuallyhighdi\ufb00iculty.Weleveragethemtorepresent\nunderlyingproof-of-workwithouteverillustratingit,storingit,ortransmittingit.Afterourpruningisapplied,thestorageandcommunication\nrequirements for consensus data is reduced exponentially.\nWedevelopnewprobabilisticmathematicalmethodstoanalyzeourprotocol in the random oracle model. We prove our protocol is both secure",
    "source":"whitepaper",
    "section":"These blocks can simply be discarded and are no longer stored by any",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":48.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_3",
    "content":"# and succinct under an uninterrupted honest majority assumption for\n\n1\/3 adversaries. Our protocol is the first to achieve always secure, always succinct, and online Non-Interactive Proofs of Proof-of-Work, all\nnecessarycomponentsforalogarithmicspaceminingscheme.Ourwork",
    "source":"whitepaper",
    "section":"and succinct under an uninterrupted honest majority assumption for",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":21.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_4",
    "content":"# has applications beyond mining and also constitutes an improvement in\n\nstate-of-the-art superlight clients and cross-chain bridges.",
    "source":"whitepaper",
    "section":"has applications beyond mining and also constitutes an improvement in",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":6.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_5",
    "content":"# 1 Introduction\n\nWill blockchain [39] systems handle the whole world\u2019s economic data for\nthe centuries to come? While such lofty visions are often ubiquitous in\nthe cryptocurrency space, it is a practical reality that today\u2019s blockchain\ntechnology simply does not scale [2]. One aspect of scalability di\ufb00iculty",
    "source":"whitepaper",
    "section":"1 Introduction",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":45.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_6",
    "content":"# stems from the data required to be stored and sent over the network\n\n",
    "source":"whitepaper",
    "section":"stems from the data required to be stored and sent over the network",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_7",
    "content":"# when blockchain nodes synchronize with each other or bootstrap from\n\nthe network for the first time.\nThese data contains two pieces of information: First, the application data. This includes transactions, account balances, and smart contract [12,45] state evolution, and everything else that is included in the\n\n--- Page 2 ---\nblock data itself. Secondly, the consensus data. This includes consensuscritical information such as proof-of-work [18] (or proof-of-stake) and",
    "source":"whitepaper",
    "section":"when blockchain nodes synchronize with each other or bootstrap from",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":58.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_8",
    "content":"# nonces required to discover the longest chain among a sea of shorter\n\nforks \u2014 everything that is part of the block header. Nodes also need to",
    "source":"whitepaper",
    "section":"nonces required to discover the longest chain among a sea of shorter",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":14.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_9",
    "content":"# reachconsensusontheapplicationdataandensureitfollowstheprotocol (Part 1)\n\nrules for validity, but the application data is not what makes consensus\nhappen. While application data can grow (or shrink) depending on the\nimplementation, consensus data grows unboundedly at a constant linear\nrate in time. For example, in Bitcoin, while items can be added or removed from the UTXO [8], the number of block headers that need to be\nstored and communicated to newly bootstrapping nodes grows at a constant rate of 1 block header per 10 minutes in expectation [16]. Similarly,\nin Ethereum, while smart contracts can be added or destroyed [24], and\nsmart contract state variables added or removed, block headers still grow\nat a constant rate of 1 block header per 12.5 seconds in expectation.\nIn the present paper, we focus on proof-of-work chains and consensus data (i.e., block headers) in particular. We put forth a mechanism to\npermanentlyprune theconsensusdatainawaythatmaintainstheblockchain\u2019s security, without introducing any additional assumptions beyond\nhonest computational majority. Our protocol compresses the amount of\nconsensus data that needs to be stored and exchanged by nodes from linear to polylogarithmic \u2014 an exponential improvement. These reductions\naffect full nodes and miners alike, and, to our knowledge, are the first\nof their kind. Our protocol is the first to suggest that nodes need not\nhold onto chains at all; instead, full nodes and miners collectively only\nhold a small sample of blocks. The rest of the blocks are lost for ever,\nunless maintained by archival nodes, and are not necessary for achieving\nconsensus or bootstrapping new nodes. We note here that our proposed\nscheme is not a sharding-based solution. All the miners of our protocol\nwill store the same data. Sharding solutions can be composed with our\nsolution in a per-shard basis to achieve even better scalability.\nToachievethesereductionssecurely,wedevelopamathematicalframework for the analysis of blockchain systems under suppression attacks in\nwhich an adversary attempts to silence the generation of selected blocks.\nFor our system to workcorrectly,it is imperativethat the adversaryfaces\ndi\ufb00iculty in suppressing our high-value sample blocks, which we call superblocks. These represent the compression of proof-of-work. We prove\nthat, in the random oracle model [6], these blocks cannot be silenced by\nany minority mining adversary. Our framework is an extension built on",
    "source":"whitepaper",
    "section":"reachconsensusontheapplicationdataandensureitfollowstheprotocol (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":364.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_10",
    "content":"# reachconsensusontheapplicationdataandensureitfollowstheprotocol (Part 2)\n\n--- Page 3 ---\ntop of the blockchain backbone model [20,21] and can be independently\nuseful for analyzing other protocols.\nOur contributions. In summary, our contributions in this paper are as\nfollows:",
    "source":"whitepaper",
    "section":"reachconsensusontheapplicationdataandensureitfollowstheprotocol (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":32.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_11",
    "content":"# 1. We put forth a mechanism which provides exponential improvements\n\n",
    "source":"whitepaper",
    "section":"1. We put forth a mechanism which provides exponential improvements",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_12",
    "content":"# in the consensus data stored and exchanged between full nodes and\n\nminers in proof-of-work settings. Our protocol requires the storage\nand exchange of only polylogarithmic data, even when a new miner is\nbootstrapping from genesis.",
    "source":"whitepaper",
    "section":"in the consensus data stored and exchanged between full nodes and",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":24.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_13",
    "content":"# 2. We develop a mathematical framework for the analysis of suppression\n\nattacks,andanalyzethesecurityofourprotocoltherein.Ourprotocol\nis secure under honest majority assumptions (a 1\/3 adversary) in the\nrandom oracle model.\nRelatedwork.Ourworkfocusesoncompressingconsensusdata,i.e.,the\nproof-of-work headers exchanged and stored. There has been significant\nwork in compressing application data in a way that maintains consensus.",
    "source":"whitepaper",
    "section":"2. We develop a mathematical framework for the analysis of suppression",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":36.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_14",
    "content":"# Such examples include moving transactions and smart contract execution\n\noff-chain in Layer 2 constructions such as payment channels [3,4,30,42]\nand networks, rollups of the optimistic [44] or zero-knowledge [7] kind,\nand sidechains [28,33,41,41]. Other systems allow (quite successfully)\ncompressingmultipletransactionsintofewerorsmaller,suchasinthecase\nof EDRAX [14], bulletproofs [9], or Mimblewimble [40]. These systems do\nnot compress consensus state; all proof-of-work headers must still be sent\nand stored, even though the actual application data is reduced. Any longterm scalability solution must include a compression of both application\ndataandconsensusdata.Ourprotocolcanbecomposed withanyofthese.",
    "source":"whitepaper",
    "section":"Such examples include moving transactions and smart contract execution",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":75.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_15",
    "content":"# Similartechniquestoourconsensuscompressiontechniqueshavebeen (Part 1)\n\npreviously used to create superlight clients, wallets that can quickly synchronizewiththerestofthenetwork.Suchtechniquesincludesuperblockbased [29,38] NIPoPoWs [27,31,32,48] and FlyClient NIPoPoWs [10].\nHowever, these still require that miners maintain the whole blockchain\nso that they can help light clients synchronize. They cannot be readily\nadapted to logarithmic space mining scenarios. Specifically, superblock\nNIPoPoWs in their previous form cannot be both always secure and always succinct, while FlyClient NIPoPoWs cannot be built on top of previous NIPoPoWs in an online fashion. All of these properties are required\nfor logarithmic space mining. Our protocol is heavily inspired by these\nprotocolsandthecoreideaisbasedonsuperblockNIPoPoWs,albeitwith",
    "source":"whitepaper",
    "section":"Similartechniquestoourconsensuscompressiontechniqueshavebeen (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":94.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_16",
    "content":"# Similartechniquestoourconsensuscompressiontechniqueshavebeen (Part 2)\n\n--- Page 4 ---\ncritical changes that ensure security, succinctness, and the proofs being\nonline.\nLastly,CODA[36]hasbeensuggestedtocompressbothconsensusand\napplication data together, but the mechanism requires a trusted setup,\nhas no treatment of security loss due to zero-knowledge recursivity, and\nmay prove impractical in terms of proof sizes or generation times.\nStructure. We present our construction in stages. First, we discuss how\nan existing miner can compress their full state. Next, we discuss how\na newly booting miner can bootstrap from genesis using only the compressed state. Subsequently, we show how a miner with only the compressed state can mine new blocks, giving rise to both light and full miners. Finally, we assemble our complete protocol, in which all miners are\nlight miners. These constructions are accompanied by high-level security",
    "source":"whitepaper",
    "section":"Similartechniquestoourconsensuscompressiontechniqueshavebeen (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":127.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_17",
    "content":"# arguments and building an intuitive understanding of why the protocol\n\nworks. After the full construction has been presented, the formal security\nanalysis in the random oracle and backbone model follows. This analysis\npart is also where our mathematical framework for the treatment of suppression attacks is put forth. We conclude by discussing the limitations\nand shortcomings of our protocol.",
    "source":"whitepaper",
    "section":"arguments and building an intuitive understanding of why the protocol",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":49.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_18",
    "content":"# 2 Consensus and Application Data\n\nBlockchain systems maintain certain application state. This state can be\nused to, for example, determine who owns how much money. There are\ntwo primary ways of representing ownership in today\u2019s blockchains: A\nUTXO-based system, in which the application state is comprised of the\nunspent transaction outputs that remain available for spending; and an\naccounts-based system, in which the application state is comprised of\naccounts and their balances. The first one is used primarily by Bitcoin,\nwhile the second one is used by Ethereum.",
    "source":"whitepaper",
    "section":"2 Consensus and Application Data",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":83.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_19",
    "content":"# The application state evolves over time when transactions are applied\n\nto it. A transaction is a state evolution operator applied on the application state. Given a previous application state and a transaction, a new\napplication state can be computed. Each block in the chain contains multiple transactions in a particular order. As such, a block is itself a state\nevolution operator which applies multiple transactions in order. By applyingablocktoapreviousapplicationstate,anewapplicationstatecan\nbe computed.",
    "source":"whitepaper",
    "section":"The application state evolves over time when transactions are applied",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":61.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_20",
    "content":"# Therearetwoschoolsofthoughtregardingwhatshouldbestoredina\n\nblock. In the first school of thought, only transactions (deltas) are stored.\n\n--- Page 5 ---",
    "source":"whitepaper",
    "section":"Therearetwoschoolsofthoughtregardingwhatshouldbestoredina",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":16.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_21",
    "content":"# The application state at the end of the blockchain can be computed by\n\nstarting at the genesis application state (an empty application state) and\ntraversing the blockchain, applying the state evolution described by each\nblock, in order, and arriving at the final application state. This is what\nBitcoin does. The other school of thought stores both transactions and\nthe state after these transactions have been applied, a so-called snapshot.\nIn such systems, if one holds the longest chain, the application state at\ntheendofthechaindoesnotneedtobecomputedbyapplyinganydeltas.\nInstead, a block near the end of the chain can simply be inspected and\nthe application state within it extracted.",
    "source":"whitepaper",
    "section":"The application state at the end of the blockchain can be computed by",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":90.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_22",
    "content":"# It is possible to apply either school of thought to either application\n\nstatemodel.BitcoinonlykeepsonlydeltasforaUTXO-basedapplication\nstate. However, nothing prevents Bitcoin from committing to the newly\ncomputed UTXO in every block [13,17,35], and in fact some Bitcoin\nforks have already done so. On the other hand, Ethereum keeps both\ndeltas and snapshots in blocks. While the snapshots are not necessary,\nthey are helpful. For the rest of this paper, we assume a proof-of-work\nblockchain in which each block commits to an application state snapshot.\nThe exact application state format (UTXO, accounts, or something else)\nis irrelevant for our purposes.\nIn both schools of thought, it is imperative that the validity of the\napplication data (deltas or snapshots) is verified before a block can be\naccepted as valid. For example, in a snapshotted system, miners must",
    "source":"whitepaper",
    "section":"It is possible to apply either school of thought to either application",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":120.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_23",
    "content":"# check that the snapshot committed to a block was obtained by applying\n\nthe transactions to the previous snapshot.\nBlocks in chains store the application data \u2014 transactions and snapshots \u2014 in their body. This data is organized into an authenticated data\nstructure,suchasaMerkleTree[37],andplacedintoablockheader,which\ncontains the consensus data. The consensus data consist of the commitment xtotheapplicationdata;aproof-of-worknoncectr;andareference\ns to the previous block. It may also contain additional metadata such as\ntimestamps. These data are hashed together using a hash function H to\nobtain the blockid H(ctr\u2225x\u2225s), which is used as the reference s \u2032 in the\nnext block.",
    "source":"whitepaper",
    "section":"check that the snapshot committed to a block was obtained by applying",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":83.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_24",
    "content":"# Let us now discuss how a bootstrapping node can synchronize with\n\nthe rest of the network. A bootstrapping node is a node holding only the\ngenesis block and booting for the first time. A wallet node is interested\nin the current application state that concerns it. For example, it is interested to learn which UTXOs it owns, or how much money is in its own\naccounts. The custodial history of how these assets came to belong to it\n\n--- Page 6 ---\nis irrelevant [17], beyond archival purposes, as long as it can be sure that",
    "source":"whitepaper",
    "section":"Let us now discuss how a bootstrapping node can synchronize with",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":85.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_25",
    "content":"# the assets it holds correspond to the correct application state based on\n\nthe history that took place. Inspecting or having access to this history\nitself is not important for consensus purposes. As such, this node can\nsynchronize with the rest of the network using the SPV method [39]: It",
    "source":"whitepaper",
    "section":"the assets it holds correspond to the correct application state based on",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":37.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_26",
    "content":"# downloads only the block headers to determine which chain is the longest\n\none. It then inspects a block near the end of the chain and extracts the\nbalance from the Merkle tree leaf for its own accounts, or for its UTXOs.\nThis is su\ufb00icient to know the assets that it owns. In case some nodes are\ninterested in the history of the blockchain, this history can be maintained\nby special archival nodes or block explorers, but are not necessary for the\nmaintenance of the security of the network.\nA miner bootstrapping their node can function in a similar manner:\nDownload only the block headers to determine the longest chain, then",
    "source":"whitepaper",
    "section":"downloads only the block headers to determine which chain is the longest",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":98.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_27",
    "content":"# inspect a block near the end of the chain to obtain the application state\n\nsnapshot. Contrary to a wallet node, the miner must obtain the whole",
    "source":"whitepaper",
    "section":"inspect a block near the end of the chain to obtain the application state",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":12.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_28",
    "content":"# application state so that it can validate new pending transactions as they\n\narrive.Assuch,theminerdownloadstheheaders forthewholechain,and\nthe full blocks only for blocks near the end of the chain.\nTo be more precise, after the longest chain has been determined by\ncomparing block header chain lengths, the kth block from the end is inspected,itsapplicationstatesnapshotisextracted,andthedeltasinnext\nk blocks are applied. This is necessary because an adversary can place incorrect snapshots in the most recent k blocks of a blockchain (folklore\nwisdom suggests k = 6 for Bitcoin). While that blockchain will look valid\nand long to someone verifying only headers, it will have snapshots corresponding to an incorrect application of deltas. However, the adversary\ncannot modify blocks prior to that, due to the Common Prefix [21] property of blockchains.",
    "source":"whitepaper",
    "section":"application state so that it can validate new pending transactions as they",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":112.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_29",
    "content":"# Note here that the miner does not need to verify the veracity of all\n\nhistorical transactions: If we assume that the majority of the computational power was honest for the duration of history, this ensures that, at\nall times during the execution, the longest chain represented the correct\nhistory of the world (with the exception of up to k blocks towards the\nend). Under the honest majority assumption, this scheme is as secure as\nfull mining (but see the Discussion section at the end for a more nuanced take on this argument under temporary dishonest majority). This",
    "source":"whitepaper",
    "section":"Note here that the miner does not need to verify the veracity of all",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":83.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_30",
    "content":"# is contrary to schemes such as SPV mining in which no snapshots are (Part 1)\n\navailable.",
    "source":"whitepaper",
    "section":"is contrary to schemes such as SPV mining in which no snapshots are (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":1.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_31",
    "content":"# is contrary to schemes such as SPV mining in which no snapshots are (Part 2)\n\n--- Page 7 ---\nApplicationdatacangroworshrink.UTXOscanbecreatedordeleted,\naccounts and smart contracts can be created, updated and destroyed.\nStatevariableswithinsmartcontractscanalsobeconstructedordestructed. How the application data grows is application-dependent. Typically,\nthe application data will increase as the execution continues. There are\nseveral attempts to optimize the size of these data [3,4,7,14,30,42,44].\nIn this paper, we do not focus on these.\nInstead,wefocusonthesizeoftheconsensus data,thatofblockheaders H(ctr\u2225x\u2225s). Contrary to the application data, these data increase\nat a constant linear rate, as block headers are added to the chain. No\nmatter if channels or rollups are used, block headers must keep getting\nadded to the chain. Fortunately, the headers are small. Nevertheless, no\nmatter how much pruning is done on the application layer, the consensus\ndata will keep growing. A system designed to survive for the centuries to\ncome must provision for the scalability of this ever-growing part. Even",
    "source":"whitepaper",
    "section":"is contrary to schemes such as SPV mining in which no snapshots are (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":138.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_32",
    "content":"# the solutions above that only download block headers do not tackle that\n\nproblem. The aim of this paper is to explore whether this part can be\npruned. As we will see, it is possible to reduce the consensus data and\nneither store nor communicate all block headers.",
    "source":"whitepaper",
    "section":"the solutions above that only download block headers do not tackle that",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":35.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_33",
    "content":"# A visualization of the comparison between application and consensus\n\ndata is shown in Figure 1. The consensus data (horizontal) grows at an\nexpected constant rate in time. The application data (vertical) may grow\n(or shrink) depending on the application, and optimizations or pruning\nmethods can be applied on top of them.\ntxs \u03b4",
    "source":"whitepaper",
    "section":"A visualization of the comparison between application and consensus",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":44.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_34",
    "content":"# application data\n\n",
    "source":"whitepaper",
    "section":"application data",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_35",
    "content":"# snapshots\n\n",
    "source":"whitepaper",
    "section":"snapshots",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_36",
    "content":"# block headers\n\n",
    "source":"whitepaper",
    "section":"block headers",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_37",
    "content":"# consensus data\n\n",
    "source":"whitepaper",
    "section":"consensus data",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_38",
    "content":"# time t\n\nFig.1.Acomparisonofconsensusdata(growinghorizontallywithtime)andapplication data (growing or shrinking vertically depending on the application).\n\n--- Page 8 ---",
    "source":"whitepaper",
    "section":"time t",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":14.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_39",
    "content":"# A comparison of our paper against previous works is illustrated in\n\nTable 1. In all of these protocols, we have a node (the prover) that maintains all the necessary state to help a newly booting node (the verifier or\nclient) synchronize with the rest of the network. We compare the storage\nrequirementsfortheprover,aswellasthecommunicationcomplexityduring bootstrapping. We are also interested in whether, after synchronizing\nwith the rest of the network, the verifier can function as a fully-fledged\nminer on its own.\nIn this table, n denotes the number of blocks in the chain, \u03b4 is the size\nof the transactions in a single block (which may vary with time), a is the\nsize of the snapshot or application state (which may also very with time),\nc is the size of a block header, and k is the common prefix parameter, the\nnumber of blocks required for stability (c.f., [26]). BTC Full indicates the",
    "source":"whitepaper",
    "section":"A comparison of our paper against previous works is illustrated in",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":139.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_40",
    "content":"# fullbitcoinminerthatsynchronizesbydownloadingallblockheadersand (Part 1)\n\ntransactions n(c+\u03b4). BTC SPV is a wallet-only client that downloads\nonly block headers and a single transaction, but requires the prover (the\nnode that serves it this data) to store the full history, as there are no\nsnapshots available. Ethereum is a blockchain which uses block headers\nto synchronize, but makes use of snapshots. Here, the prover can prune\nblock contents, but not block headers (the nc term remains). For the last\nk blocks, the transaction data of total size k\u03b4 are also needed to verify the veracity of the tip of the chain; for the kth block from the end,\nonly a snapshot of size a is needed. The client can start mining on top\nof these snapshots (after the k\u03b4 transaction data have been applied to\nthe snapshot of size a). Note that a \u2264 n\u03b4 and k \u2264 n, and so (asymptotically) n(c+\u03b4) \u2265 nc+k\u03b4 +a. Superblock and FlyClient NIPoPoWs\nallow a full node to function as a prover, only sending consensus data\npolylogarithmic in n, provided snapshots are available, but the receiving\nverifier cannot function as a miner or a prover for others. In this work,\nwe present a protocol in which the verifier and prover are identical. The\nprover is only required to store polylogarithmic consensus data, and communication complexity is also polylogarithmic. This is indicated by the\nterm polylog(n)c. The term ka, the application data, remains unaffected\nand its pruning is orthogonal to this work.",
    "source":"whitepaper",
    "section":"fullbitcoinminerthatsynchronizesbydownloadingallblockheadersand (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":241.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_41",
    "content":"# 3 State Compression\n\n",
    "source":"whitepaper",
    "section":"3 State Compression",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_42",
    "content":"# How can a newly booting miner synchronize with the rest of the network\n\nif block headers have been pruned? It seems impossible to do so securely.\nAt first glance, the newly booting miner will be lost in a sea of appli8\n\n--- Page 9 ---\nProposalStorage Communication Can mine?\nBTC Full n(c+\u03b4) n(c+\u03b4) yes",
    "source":"whitepaper",
    "section":"How can a newly booting miner synchronize with the rest of the network",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":41.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_43",
    "content":"# BTC SPV nc nc no\n\nEthereum nc+k\u03b4+a nc+k\u03b4+a yes\nSuperblock NIPoPoWs nc+k\u03b4+apolylog(n)c+k\u03b4+a no\nFlyClient NIPoPoWs nc+k\u03b4+apolylog(n)c+k\u03b4+a no\nThis work polylog(n)c+k\u03b4+apolylog(n)c+k\u03b4+a yes\nTable 1. A comparison of our results and previous work. n: the number of blocks in\nthechain;\u03b4:sizeoftransactionsinablock;c:blockheadersize;a:sizeofsnapshot;k:",
    "source":"whitepaper",
    "section":"BTC SPV nc nc no",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":33.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_44",
    "content":"# common prefix parameter\n\ncation snapshots and blockchain tips, without any ability to discern the\napplication snapshot corresponding to the longest chain.\nWeapproachthisproblembycompressing theconsensusdata.Among\nall the block headers that would be maintained by a traditional blockchain protocol, we only keep a small sample of block headers that are\nof interest. Most of the block headers headers will be pruned. The small",
    "source":"whitepaper",
    "section":"common prefix parameter",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":57.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_45",
    "content":"# sample of block headers that remains will be polylogarithmic in size and\n\nused as evidence that work took place throughout history. These sample block headers will be stored by our miners, and will also be sent to\nnew bootstrapping miners when they boot. No other block headers will\nbe stored or communicated beyond these carefully chosen samples. The\nsamples will be chosen to be the same for all miners. As such, some block\nheaders will survive throughout the network, while others will be gone\nfor ever. Once we describe which block headers to keep and which ones to\nthrow away, the construction of our prover will be complete. The rest of",
    "source":"whitepaper",
    "section":"sample of block headers that remains will be polylogarithmic in size and",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":99.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_46",
    "content":"# the work will be to construct a verifier that can distinguish between honest and adversarial application state claims by examining these samples\n\nand, of course, proving that this operation is secure.",
    "source":"whitepaper",
    "section":"the work will be to construct a verifier that can distinguish between honest and adversarial application state claims by examining these samples",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":9.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_47",
    "content":"# Let us begin by discussing which samples among all block headers\n\nwill be maintained by first presenting our compression algorithm: The\ncode that can take in a full chain and perform the sampling. These block",
    "source":"whitepaper",
    "section":"Let us begin by discussing which samples among all block headers",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":24.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_48",
    "content":"# header samples will be the only ones that survive in our final protocol (Part 1)\n\ndesign. The compression algorithm takes in a full chain and produces the\ndesired samples, but will not form part of our final protocol. In the final\nprotocol,nofullchainistobefound.However,thecompressionalgorithm\nwill prove educational in understanding the final protocol (and can also\nbe used, once, to transition a full miner into a light miner). We will also\nreuse our compression algorithm in the final light miner construction,\ndespite no full chains ever appearing.",
    "source":"whitepaper",
    "section":"header samples will be the only ones that survive in our final protocol (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":69.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_49",
    "content":"# header samples will be the only ones that survive in our final protocol (Part 2)\n\n--- Page 10 ---\nWesampleblockheadersbasedontheirachievedproof-of-work.Recall\nthatablockmustsatisfytheproof-of-workequationH(ctr\u2225x\u2225s) \u2264 T for\nsome constant3 mining target T. Some blocks satisfy this equation much\nbetter than others and in particular may achieve H(ctr\u2225x\u2225s) \u2264 T for\nsome \u00b5 \u2208 N. Following previous literature [27,29,31], we call these \u00b5superblocks and \u00b5 the level of a block. We model our hash function H as\na random oracle with \u03ba bits of output, and hence the distribution of \u00b5\nsuperblocks, although stochastic, will be quite controlled. In particular,\nevery block is a 0-superblock, about half the blocks in the chain will be\n1-superblocks, about a quarter will be 2-superblocks, and in general, the\nprobability that a valid block is a \u00b5-superblock will be 1 . By definition,\nevery block of level \u00b5 > 0 is also a block of level \u00b5\u22121, and all the levels\nbelow down to 0. The genesis block is, by convention, of infinite level. As\nthe number of blocks per level drops exponentially as the level increases,\nthe number of different levels will be approximately log|C|, where |C|\ndenotes the size of the underlying blockchain [29].\nThe intuition for our construction is as follows. Superblocks of increasing level become rarer and rarer. As such, superblocks can be used",
    "source":"whitepaper",
    "section":"header samples will be the only ones that survive in our final protocol (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":205.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_50",
    "content":"# toillustratethatsomework hasoccurredinablockchainwithoutactually (Part 1)\n\ndelivering every block header. Consider a client that sees 13 superblocks\nof level 10. That client can readily deduce that approximately 210 blocks\nmust have appeared around each of these 13 superblocks. Otherwise, how\nwasitpossibletominetheseblocksatthisveryhighdi\ufb00iculty?Theclient\ncan be sure that a total of about 13\u00b7210 blocks must have been mined,\neven though the client cannot observe these blocks directly (and, to be\nfair, if these blocks were mined by an adversary, they may have never\nbeen broadcast to the network at all).\nWhile the client may see a series of blocks at a certain level, it cannot be sure that these were mined in the order they are presented. An\nadversary presenting 13 superblocks of level 10 may reorder them arbitrarily.Forthisreason,thesamewaywemaintainprevidpointersbetween\nblocks of level 0 in legacy blockchains, we need to maintain pointers between blocks at every level, and these pointers need to be placed within\ntheproof-of-worksoastobecomeimmutable(assuch,ourprotocolisnot\nbackwards-compatible with existing blockchains, but see the Discussion\nsectionforanoteonthis).Aswecannotpredictthelevelofablockbefore\nmining it, we will include log|C| pointers at every block: For each level \u00b5,\na pointer to the most for recent preceding block of level at least \u00b5. This\n3 Throughout this paper we will assume the target T is constant; some notes around\na variable target T appear in the Discussion section towards the end.",
    "source":"whitepaper",
    "section":"toillustratethatsomework hasoccurredinablockchainwithoutactually (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":211.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_51",
    "content":"# toillustratethatsomework hasoccurredinablockchainwithoutactually (Part 2)\n\n--- Page 11 ---\nis not very different from a skiplist [43] and is akin to the construction\nof KLS [29]. There are e\ufb00icient ways of storing such pointers [27]. This\ninterlinked blockchain is illustrated in Figure 2.\nFig.2. The interlinked blockchain. Each superblock is drawn taller according to its\nlevel. A new block links to all previous blocks that have not been overshadowed by\nhigher levels in the meantime.\n3 3\n2 2\n1 1 1 1\n0 0 0 0 0 0 0\nOur sampling will be performed by only keeping su\ufb00iciently high-level\nsuperblocksandthrowingawayblocksoflowlevels.Wewillkeepveryhigh\nlevels (so, very few blocks) near genesis and far back in history. As we\nget closer to the present, we will start including more and more samples,\nand so the threshold in our superblock level will decrease. Near the tip\n(the most recent block) of the blockchain, we will eventually get down to\nlevel 0 and keep all blocks.\nThe samples that we keep will evolve as the blockchain grows. A sample that was once selected for inclusion may be thrown away later. However, any sample that is thrown away at some point will never again be\nneeded in the future. This property, of ensuring that the sampling is safe\nand that no samples discarded will be needed again in the future, is the\nonline property of our protocol. It will eventually allow us to build a\nprotocol where no full chain is needed, anywhere.\nOur algorithm is parametrized by a security (or, inversely, compression) parameter m and the common prefix parameter k (these can be\nunified by conservatively setting m = 3k). Given a chain C that we wish\nto compress, first, we keep the most recent k blocks aside, and let us call\nthem \u03c7. These are unstable and will need to always be stored. Besides,",
    "source":"whitepaper",
    "section":"toillustratethatsomework hasoccurredinablockchainwithoutactually (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":304.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_52",
    "content":"# any miner that wishes to synchronize with us will need to look at them to (Part 1)\n\narrive at a valid snapshot. For the next part, we only consider the stable\npart of the chain. For our sampling process, we begin by the highest level",
    "source":"whitepaper",
    "section":"any miner that wishes to synchronize with us will need to look at them to (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":28.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_53",
    "content":"# any miner that wishes to synchronize with us will need to look at them to (Part 2)\n\n--- Page 12 ---\n\u2113 that has at least 2m blocks in it. We will include this level in earnest:\nAll \u2113-superblocks will be included in our sampling. For every level below\n\u2113, we will include at least the 2m most recently generated blocks of that\nlevel, but occassionally more. To consider whether to include more blocks\nthan 2m blocks in a level \u00b5, we look at the mth most recent block b in\nthe level \u00b5+1 immediately above. We include all \u00b5-superblocks that are\nmore recent than block b. Let us make this description more precise by\nwriting it out in pseudocode.\nNotation.Wewillneedsomenotationtodescribeourchain compression\nalgorithm. Let C denote an interlinked chain of blocks and C[i] denote its\nith (zero-based) element. We denote by C[i:j] the blocks from the ith\n(inclusive) to the jth block (exclusive). Skipping i means taking the chain\nfrom the beginning, and skipping j means taking the chain to the end.\nIf i and j are replaced by blocks A and Z instead of block indices, we\nwrite C{A:Z} to designate the blocks of C from block A (inclusive) to\nblock Z (exclusive), and again any end can be omitted. A negative i or\nj means to take blocks from the end instead of from the beginning, so\nC[\u22121] is the tip. We write A \u2208 C to mean that the block A is in the chain\nC, and C \u2286 C to mean that all of C \u2019s blocks are in C . We write C\u2191\u00b5\n1 2 1 2\nto mean the subsequence of C containing only its \u00b5-superblocks (by the\nabovedefinition,theC\u2191operatorisabsolute:(C\u2191\u00b5)\u2191\u00b5+i= C\u2191\u00b5+i).Because\nC is interlinked, C\u2191\u00b5 will be a chain, too. Given two chains C and C we\n1 2\nwrite C \u222aC to denote the chain consisting of all blocks in either, and\n1 2\nC \u2229C to mean the chain consisting of blocks only in both. Similarly we\n1 2\ndenoteC \\C thechainconsistingofblocksinC butnotinC .Theblocks\n1 2 1 2",
    "source":"whitepaper",
    "section":"any miner that wishes to synchronize with us will need to look at them to (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":328.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_54",
    "content":"# must be ordered chronologically and interlink pointers must be checked\n\ntoensurethattheunion,intersection,andsubtractionofchainsisachain\n\u2014 they will not always be. The chain filtering operators \u2191, [\u00b7], and {\u00b7}\nhave a higher precedence than \u222a,\u2229,\\.\nOur chain compression algorithm Compress (C) is illustrated in Alm,k\ngorithm1.ItusesthehelperfunctionDissolve (C)toobtainthehighest\nm,k\nlevel\u2113,theunstablesu\ufb00ix\u03c7andasetD[\u00b5]ofblockssampledfromthestable part of the chain at each level \u00b5 \u2264 \u2113. All of these levels are combined\ninto a big chain \u03c0, which is sparse at the beginning and dense towards\nthe end. The final compressed state consists of \u03c0, the stable part, and\n\u03c7, the unstable part. Together, these form a chain. Let us now examine\nthe inner workings of Dissolve (C). This function separates the stable\nm,k",
    "source":"whitepaper",
    "section":"must be ordered chronologically and interlink pointers must be checked",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":103.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_55",
    "content":"# part (Part 1)\n\nof the chain and the unstable part \u03c7. In the trivial case that\nour stable chain has no more than 2m blocks, all of them are included.\nOtherwise, the highest level \u2113 with at least 2m blocks is extracted and",
    "source":"whitepaper",
    "section":"part (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":40.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_56",
    "content":"# part (Part 2)\n\n--- Page 13 ---\nincluded in earnest. Then, the levels are traversed downwards. For every\nlevel \u00b5, the last 2m blocks are always included. This is captured by the\nterm C\u2217\u2191\u00b5 [\u22122m:]. Additionally, we look at the mth most recent block\nb from the end at level \u00b5+1, that is C\u2217\u2191\u00b5+1 [\u2212m]. For level \u00b5, we also\ninclude all the blocks succeeding b, that is C\u2217\u2191\u00b5 {b:}.\nAlgorithm 1 Chain compression algorithm for transitioning a full miner\nto a logspace miner. Given a full chain, it compresses it into logspace\nstate.\n1: function Dissolve (C)\nm,k\n2: C\u2217 \u2190C[:\u2212k]\n3: D\u2190\u2205\n4: if |C\u2217|\u22652m then\n5: \u2113\u2190max{\u00b5:|C\u2217\u2191\u00b5 |\u22652m}\n6: D[\u2113]\u2190C\u2217\u2191\u2113\n7: for \u00b5\u2190\u2113\u22121 down to 0 do\n8: b\u2190C\u2217\u2191\u00b5+1 [\u2212m]\n9: D[\u00b5]\u2190C\u2217\u2191\u00b5 [\u22122m:]\u222aC\u2217\u2191\u00b5 {b:}\n10: end for\n11: else\n12: D[0]\u2190C\u2217\n13: end if\n14: \u03c7\u2190C[\u2212k:]\n15: return (D,\u2113,\u03c7)\n16: end function\n17: function Compress (C)\nm,k\n18: (D,\u2113,\u222a\u03c7)\u2190Dissolve\nm,k\n(C)\n19: \u03c0\u2190 \u2113 D[\u00b5]\n\u00b5=0\n20: return \u03c0\u03c7\n21: end function",
    "source":"whitepaper",
    "section":"part (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":162.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_57",
    "content":"# It may not yet be clear why this selection of block headers will lead to\n\na secure protocol, but let us argue that this sampling is polylogarithmic\nin |C|, considering that m and k are constants that do not grow as the\nexecution progresses.\nTheorem 1 (Succinctness). The construction of Algorithm 1 samples",
    "source":"whitepaper",
    "section":"It may not yet be clear why this selection of block headers will lead to",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":38.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_58",
    "content":"# a polylogarithmic number of blocks with respect to the length of the chain\n\nProof (Sketch). Firstly, the number \u2113 of levels of interest is \u0398(log|C|).\nNext, each level \u00b5 has either 2m blocks or more. 2m is a constant, so this\nis irrelevant. But the more blocks cannot be many more either: We are\n\n--- Page 14 ---\ncounting the \u00b5-superblocks following the mth block b at the level \u00b5+1\nabove. How many can these be? They are indeed about 2m. For, suppose\nfor contradiction that they were many more than 2m. But every block\nof level \u00b5 has a 1 probability of also being a \u00b5+1 level block. If there\nwere, say, 4m instead of 2m superblocks of level \u00b5 following block b, then\nb would not be the mth block from the end, but the 2mth one! With high\nprobability (with foresight, utilizing a Chernoff bound), 4m can be taken\nas an upper bound. As such, there will be 2mlog(|C|)+k blocks sampled\nin expectation, and, with high probability, not many more. \u2293\u2294\nWe make this bound and argument more precise in the Analysis section.",
    "source":"whitepaper",
    "section":"a polylogarithmic number of blocks with respect to the length of the chain",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":173.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_59",
    "content":"# 4 Fast Synchronization (Part 1)\n\nWe have seen how a full miner can compress their state into a polylogarithmic sample \u03c0\u03c7 of blocks. But what is the use of this? We will now\nbuild the other side of the protocol: A node, and future miner, booting\nto the network for the first time, but holding only genesis G. The node is\nalso parametrized by the security parameters m and k. This node wishes\nto learn where to mine.\nFor now, let us assume that the rest of the network consists of full\nminers, and only one node is a light node. The first step of the neophyte\nis to determine what the current tip and snapshot are. The light miner\ncan then start mining on top of that tip, extending its application data\nsnapshot.Itdoesnotneedtoknowtheblocksprecedingthetip!Ofcourse,\nthis node will not be helpful towards bootstrapping yet more nodes, but\nnomatter\u2014itcanstillmineasifitwereafullminer,andjustassecurely,\nas long as the tip can be correctly discerned.\nTheprotocolworksasfollows.Initially,thenewlybootingnode,which\nwe call a verifier in this context, connects to multiple full nodes, which\nwe call the provers. We assume at least one of the provers is honest (this\nis a standard assumption in the analysis of all blockchain protocols [20\u2013\n23,46]). Each of these full nodes compresses their state using Algorithm 1\nand sends the compressed state, or proof \u03a0 = \u03c0\u03c7, to the verifier. More\nconcretely, the full node sends the block headers corresponding to the\nblocks in \u03c0 (of size c \u00b7 polylog(n)). For the blocks in \u03c7, the full node\nsends the whole application snapshot (of size a) stored in \u03c7[\u2212k] and\nthe transactions (of size k\u03b4) stored in \u03c7. Naturally, the adversary can\nsend any string as a claimed proof. The verifier checks that \u03a0 forms a\nchain, i.e., that all blocks are connected with interlinks and so they have",
    "source":"whitepaper",
    "section":"4 Fast Synchronization (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":296.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_60",
    "content":"# 4 Fast Synchronization (Part 2)\n\n--- Page 15 ---\nbeen produced in the chronological order presented, and also that the\nfirst block in \u03a0 is the genesis block G that it knows. It then extracts\nthe last k blocks as \u03c7 and the rest as \u03c0. It inspects the application data\nsnapshotfrom\u03c7[\u2212k]andensuresthatthetransactionsin\u03c7canbecleanly\napplied. This allows it to obtain the application state at the end of \u03c0\u03c7,\nwhich, in honest cases, is the same as the application snapshot at the end\nof the underlying blockchain. If any of these checks fail, the particular\nconnection is considered compromised and closed.\nTheverifierreceivesandverifiesaseriesofsuchproofs,eachconsisting\nof a stable part \u03c0 and an unstable part \u03c7, with |\u03c7| = k. Given multiple\nsuch proofs \u03a0 ,\u03a0 ,\u00b7\u00b7\u00b7 ,\u03a0 , the prover begins inspecting the proofs and\n1 2 v\ncomparing one against the other in a pairwise fashion. First, \u03a0 is com1\npared against \u03a0 , and one of them is deemed to be the best (using a\nmechanism we will soon study). The process continues until only one of\nthem remains. As long as at least one proof was honestly generated, our\nprotocol will arrive at a su\ufb00ix \u03c7 that is admissible. This means that our",
    "source":"whitepaper",
    "section":"4 Fast Synchronization (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":195.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_61",
    "content":"# light node will arrive at a snapshot which a full node miner booting for\n\nthe first time from genesis could also have arrived at. Upon taking this\ndecision, the light miner stores \u03c0\u03c7 in its state.\nThe light miner can then start mining on top of \u03c7[\u22121] to produce further blocks and to fully verify the validity of incoming network transactions in its mempool. After all, it is holding ontoan application snapshot.",
    "source":"whitepaper",
    "section":"light node will arrive at a snapshot which a full node miner booting for",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":58.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_62",
    "content":"# Theseblockscanbebroadcasttothenetworkandwillbeacceptedbythe (Part 1)\n\nrest of the miners, despite our light miner not holding the full chain leading from genesis up to the newly mined block. The light miner can also\nunderstand and verify newly mined blocks of others. It can also deal with\nchain reorganizations: In case a reorganization of up to k blocks occurs,\nthe light miner holds the whole of \u03c7 and can verify the state transitions\ncompletely. As for reorganizations of more than k blocks long, these will\nnever occur (except with negligible probability) due to the Common Prefix property [21].\nAsthisminerisnotinterestedinhelpingbootstrapothers,itcaneven\nthrowaway\u03c0 onceithasbootedup.Furthermore,everytimeanewblock\nis mined (either by itself or by someone else), it can append it to \u03c7 and\nthen truncate \u03c7 to only keep the k most recent blocks. However, in the\nfull protocol, described in the next section, the miner will need to hold\non to (and update) \u03c0 to allow others to bootstrap.\nLet us now study the security-critical portion of our protocol, namely\nhow the verifier compares two different proofs \u03a0 and \u03a0 . Given two\nproofs \u03a0 and \u03a0 , the algorithm must decide which one is best or cap15",
    "source":"whitepaper",
    "section":"Theseblockscanbebroadcasttothenetworkandwillbeacceptedbythe (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":186.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_63",
    "content":"# Theseblockscanbebroadcasttothenetworkandwillbeacceptedbythe (Part 2)\n\n--- Page 16 ---\ntures the most proof of work. In other words, it must conceptually correspond to the longest underlying chain, or the underlying chain with the\nmost work. The comparison algorithm is illustrated in Algorithm 2. The\ncomparison is performed as follows. Initially, the two proofs \u03a0 and \u03a0\nare verified for syntactic validity: That \u03a0 begins with G, it is a chain,\nand that \u03c7 contains valid transactions extending the application data\nsnapshot contained in \u03c7[0]. The comparison continues by invoking the\nDissolve (\u03a0) function of Algorithm 1 on each of \u03a0 and \u03a0 . As bem,k\nfore, this function extracts the maximum level \u2113 containing at least 2m\nblocks. Then it picks the required blocks from each level, with at least\n2m blocks per level, but also a su\ufb00icient number of blocks per level to\nspan the last m blocks in the level above. Contrary to the invocation in\nAlgorithm1,wearenotpassingthefullchaintothefunction;instead,we\nare passing a chain which has already undergone compression. As such,\nif the compressed state was honestly generated, the triplet (\u03c7,\u2113,D) on\nthe verifier end will be the same as the triplet on the prover end, because\ncompress (C) = compress (compress (C)) (but may be something\nm,k m,k m,k\nelse in case of adversarial proofs).\nAlgorithm 2 The state comparison algorithm.\n1: function maxvalid (\u03a0,\u03a0\u2032)\nm,k\n2: if \u03a0 is not valid then\n3: return \u03a0\u2032\n4: end if\n5: if \u03a0\u2032 is not valid then\n6: return \u03a0\n7: end if\n8: (\u03c7,\u2113,D)\u2190Dissolve (\u03a0)\nm,k\n9: (\u03c7\u2032,\u2113\u2032,D\u2032)\u2190Dissolve (\u03a0\u2032)\nm,k\n10: M \u2190{\u00b5\u2208N:D[\u00b5]\u2229D\u2032[\u00b5]\u0338=\u2205}\n11: if M =\u2205 then\n12: if \u2113\u2032 >\u2113 then\n13: return \u03a0\u2032\n14: end if\n15: return \u03a0\n16: end if\n17: \u00b5\u2190minM\n18: b\u2190(D[\u00b5]\u2229D\u2032[\u00b5])[\u22121]\n19: if |D\u2032[\u00b5]{b:}|>|D[\u00b5]{b:}| then\n20: return \u03a0\u2032\n21: end if\n22: return \u03a0\n23: end function",
    "source":"whitepaper",
    "section":"Theseblockscanbebroadcasttothenetworkandwillbeacceptedbythe (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":300.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_64",
    "content":"# Theseblockscanbebroadcasttothenetworkandwillbeacceptedbythe (Part 3)\n\n--- Page 17 ---\nOnly once the two proofs are stratified into levels D, the comparison\nalgorithm attempts to choose a level \u00b5 at which the comparison will be\nperformed. This level is the minimum level \u00b5 for which both provers\nhave provided blocks (note that it is not su\ufb00icient that both provers have\nprovidedthesameblockatthesamelevel;itmustalsohavebeenselected\nin the same index of D). In the edge case that no such level can be found,\nthe prover with the higher \u2113 wins (if no such level is found and they share\nthe same level, it is irrelevant which prover will win). In the normal case\nthat a level is found, then the comparison takes place by taking account\nonly blocks of that level. The comparison begins by finding the most\nrecent block shared by the two parties at that level, (D[\u00b5]\u2229D\u2032 [\u00b5])[\u22121].\nWecallthisthelowestcommonancestor b.Theblocksoftheselectedlevel\nfollowing block b (which must necessarily be disjoint by the definition of\nb) are then counted, and the party with the most blocks wins.\nLet us give a high-level intuition of why this protocol chooses the\nlongest chain. The key idea is that, in addition to the Common Prefix property holding for regular blocks, this property also holds for \u00b5superblocks at any level. More precisely, if there is a forking point b, the\nadversary could not have produced more than m superblocks of level \u00b5\nfaster than the honest parties can produce m superblocks of level \u00b5. This\nproperty stands at the heart of the following theorem.\nTheorem 2 (Security). When the honest verifier of Algorithm 2 receives a proof \u03a0 constructed by an honest party using Algorithm 1 and a\nproof \u03a0 constructed by the adversary, it will decide in favour of the hon-\nest proof, unless the adversary is playing honestly and \u03a0 was generated\naccording to protocol.\nProof (Sketch). First, consider the case that M \u0338= \u2205. If the comparison\nis performed at level \u00b5 = 0, this is akin to comparing traditional chains\nand the theorem holds due to the Common Prefix property.\nIf the comparison is performed at a level \u00b5 > 0, then we apply the\nextended Common Prefix property at level \u00b5. By the minimality of \u00b5,",
    "source":"whitepaper",
    "section":"Theseblockscanbebroadcasttothenetworkandwillbeacceptedbythe (Part 3)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":365.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_65",
    "content":"# there will be at least m blocks of the appropriate level following b and so\n\nthe honest parties will win.\nLastly, if M = \u2205, then we can apply the extended Common Prefix\nproperty at the highest level \u2113 achieved by the honest party. By construction, the honest party holds at least 2m blocks at this level. Because the\nadversary must have achieved a better \u2113 > \u2113 to win, she must also have\nat least 2m blocks of a higher level, but these are also of level \u2113. But this\n\n--- Page 18 ---\ncontradicts the extended Common Prefix property, giving us the desired\nresult. \u2293\u2294",
    "source":"whitepaper",
    "section":"there will be at least m blocks of the appropriate level following b and so",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":92.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_66",
    "content":"# Whilethisgivessomeintuitionaboutwhytheprotocolisdesignedthe\n\nwayitis,thecoresecurityargumentpertainstoarguingwhytheextended\nCommon Prefix property holds. We formally prove this statement in the\nAnalysis section for 1\/3 adversaries, where we also make the security\ntheorem more precise.",
    "source":"whitepaper",
    "section":"Whilethisgivessomeintuitionaboutwhytheprotocolisdesignedthe",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":26.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_67",
    "content":"# 5 Mining New Blocks\n\nSo far, we have used full nodes to help bootstrap newly booting miners.\nCan light miners be used to bootstrap newly booting miners instead? If\nwe can achieve this, then we might as well get rid of full nodes altogether.\nOur light miner already holds a valid proof \u03a0 = \u03c0\u03c7 corresponding",
    "source":"whitepaper",
    "section":"5 Mining New Blocks",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":52.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_68",
    "content":"# to an underlying honest full node chain C at the time it is bootstrapped\n\nby others. Before further blocks are mined on the network (either by\nitself, or by others), it can send this \u03a0 to newly booting miners, and\nthey, too, will be convinced of the current application data snapshot. The\nquestion is how to update this \u03a0 when a new block is mined. Suppose\na new block b is mined on top of C, either by our light miner or by\nsomeone else. The underlying honest chain then becomes C\u2032 = Cb. Can\nwe produce a proof \u03a0",
    "source":"whitepaper",
    "section":"to an underlying honest full node chain C at the time it is bootstrapped",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":86.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_69",
    "content":"# corresponding to\n\nby only utilizing \u03a0? More\nspecifically, given \u03a0 = Compress (C) and b, but not given C, can we\nm,k\nproduce \u03a0 \u2032 = Compress (Cb)? Indeed we can. In fact, it is as simple as\nm,k",
    "source":"whitepaper",
    "section":"corresponding to",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":37.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_70",
    "content":"# evaluating (Part 1)\n\n= Compress (\u03a0b).\nm,k\nTheorem 3 (Online). Consider \u03a0 = Compress (C) generated about\nm,k\nan underlying honest chain C, and a block b mined on top of C. Then\nCompress (Cb) = Compress (\u03a0b).\nm,k m,k\nProof. Considerwhichblocksaresampledandwhichblocksareprunedby\nCompress (Cb). Clearly the block b will be included in both the results\nm,k\nof Compress (Cb) and Compress (\u03a0b). All the other blocks selected\nm,k m,k\nby Compress (Cb) will already exist in \u03a0, and in the correct positions.\nm,k\nFor, the blocks selected from a level are the last 2m of a level, or the\nlast m spanning the level above, and adding block b at the end can only\nrender a previously sampled block irrelevant, but not add further block\nrequirements from the past. \u2293\u2294\nNote also that, when mining a new block b, all the data required to\ncomputetheinterlinkpointersofbisreadilyavailablein\u03c0\u03c7,as\u03c0 contains",
    "source":"whitepaper",
    "section":"evaluating (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":143.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_71",
    "content":"# evaluating (Part 2)\n\n--- Page 19 ---\nthe most recent 2m blocks of every level, and only the most recent one is\nneeded for interlinking.\nAlgorithm 3 The final logspace miner.\n1: \u03a0 \u2190\u2205\n2: function Init (\u03a0)\nm,k\n3: for \u03a0\u2032 \u2208\u03a0 do\n4: \u03a0 \u2190maxvalid (\u03a0\u2032,\u03a0)\nm,k\n5: end for\n6: end function\n7: function Mine (x)\nm,k\n8: b\u2190pow(\u03a0[\u22121],x)\n9: if b\u0338=\u03f5 then\n10: \u03a0 \u2190Compress (\u03a0b)\nm,k\n11: broadcast(\u03a0)\n12: end if\n13: end function\n14: upon BootstrapRequest do\n15: return \u03a0\n16: end upon\n17: upon NewBlockReceived(\u03c7\u2032) do\n18: \u03c7\u2190\u03a0[\u2212k:]\n19: \u03c0\u2190\u03a0[:\u2212k]\n20: if \u03c7\u2032 is a chain\u2227\u03c7\u2032[0]\u2208\u03c7 then\n21: b\u2190(\u03c7\u2229\u03c7\u2032)[\u22121]\n22: if |\u03c7\u2032{b:}|>|\u03c7{b:}| then\n23: Validate \u03c7\u2032 state transitions starting from b\n24: \u03a0 \u2190Compress (\u03c0\u03c7{:b}\u03c7\u2032{b:})\nm,k\n25: broadcast(\u03a0)\n26: end if\n27: end if\n28: end upon\nOurfinallightminerthereforeworksasfollows.Itmaintainsacurrent\nproof \u03a0 = \u03c0\u03c7 and mines using \u03c7[\u22121] as the chain tip. If it is successful in\nminingbontopof\u03c7,itreplaces\u03a0 bysettingitto\u03a0 = Compress (\u03a0b)\nm,k\nandbroadcaststhistothenetwork.Asalloftheotheronlineminers,light\nor full, will hold their own \u03c7 not differing more than k blocks from \u03c7,\nit is, in fact, su\ufb00icient that it broadcasts the new \u03c7 = \u03c7[1:]b portion of\n\u03a0 \u2032 . Now the newly computed \u03a0 corresponds to the chain Cb, which the\nminer never sees, as it has been pruned. Regardless, \u03a0 can be used to\nbootstrap new light miners from genesis.\nConsider now the case that our light miner holds a \u03a0 = \u03c0\u03c7 and a\ndifferent miner mines a new block b. By the Common Prefix property,",
    "source":"whitepaper",
    "section":"evaluating (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":248.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_72",
    "content":"# evaluating (Part 3)\n\n--- Page 20 ---\nthis block will not deviate more than k blocks from the \u03c7 that our light\nminer already holds. Typically, it will be just a block on top of \u03c7, but",
    "source":"whitepaper",
    "section":"evaluating (Part 3)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":34.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_73",
    "content":"# occassionally it could correspond to a chain reorganization up to k blocks\n\nlong. In the case of a reorganization, the light miner requests the last k\nblocks \u03c7 on top of which b was mined. These can be provided to us if the\nblock b was mined by a light or a full miner, as both hold and can send\n\u2032 \u2032\n\u03c7. The blocks in \u03c7 will intersect the previously known \u03c7 at some fork\npoint. The light miner checks that the transactions included in this \u03c7",
    "source":"whitepaper",
    "section":"occassionally it could correspond to a chain reorganization up to k blocks",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":76.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_74",
    "content":"# can be applied to the application data snapshot that the light miner has\n\nindependently calculated for the fork point. This amounts to full block\nvalidation. The light miner also checks that the newly mined block really",
    "source":"whitepaper",
    "section":"can be applied to the application data snapshot that the light miner has",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":23.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_75",
    "content":"# does correspond to a longer chain and that a reorganization is warranted\n\nby ensuring that there are more blocks in \u03c7 after the fork point b than\nthere are in \u03c7 after the fork point (i.e., that |\u03c7 \u2032{b:}| > |\u03c7{b:}|). It then\nreplaces the stored proof by setting \u03a0 to be the proof corresponding to\n\u03c0\u03c7 when the portion of \u03c7 after the most recent common block between\n\u2032 \u2032\n\u03c7 and \u03c7 is replaced by the blocks in \u03c7, i.e., it updates its stored proof\nto be \u03a0 \u2032 = Compress (\u03c0\u03c7{:b}\u03c7 \u2032{b:}).\nm,k\nThe light miner is illustrated in Algorithm 3. At this point, full nodes\nare no longer necessary. Light miners can bootstrap from genesis. They\nhave all the data needed to mine on their own, and to validate newly\nmined blocks from the network. If a newly booting light miner wishes\nto synchronize with the network, they have su\ufb00icient data to help them\ndo so. The blockchain protocol remains exactly the same as in traditional\nblockchains,butalltheinstancesofchains arereplacedbyproofs instead.",
    "source":"whitepaper",
    "section":"does correspond to a longer chain and that a reorganization is warranted",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":161.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_76",
    "content":"# Lightminersmineontopoftheircurrentproofinsteadofminingontopof\n\na chain. When they discover a new block, they send the newly computed\nproof instead of a chain. This concludes our construction.",
    "source":"whitepaper",
    "section":"Lightminersmineontopoftheircurrentproofinsteadofminingontopof",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":22.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_77",
    "content":"# 6 Block Suppression\n\n",
    "source":"whitepaper",
    "section":"6 Block Suppression",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_78",
    "content":"# We begin our analysis by developing a probabilistic framework to study\n\nwhether the adversary can suppress blocks of her choice. The central\ndefinition here is the notion of a Q-block, a block that possesses a certain\nproperty \u2014 such as being a \u00b5-superblock for some \u00b5 \u2208 N. The main",
    "source":"whitepaper",
    "section":"We begin our analysis by developing a probabilistic framework to study",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":39.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_79",
    "content":"# theoremwewilleventuallyproveisageneralizationoftheCommonPrefix (Part 1)\n\nproperty: That the Common Prefix property holds for blocks filtered by\nany attribute Q. This will allow us to prove our protocol is secure by\ninstantiating Q-blocks as \u00b5-superblocks.",
    "source":"whitepaper",
    "section":"theoremwewilleventuallyproveisageneralizationoftheCommonPrefix (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":29.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_80",
    "content":"# theoremwewilleventuallyproveisageneralizationoftheCommonPrefix (Part 2)\n\n--- Page 21 ---\nFor our analysis, we work in the Backbone model [21] and adopt an\nenvironment where the network is synchronous and the protocol is executed in distinct rounds. We give a short overview of the model. Let \u03ba\ndenote the security parameter, and n denote the total number of parties,\nt of which are adversarial. Block generation takes place, by honest and\nadversarialpartiesalike,byinvokingasharedRandomOracleH(\u00b7)whose\nrange is {0,1}\u03ba. We use q to denote the number of random oracle queries\navailable to each party per round. The honest parties search the space by\nperforming q queries for ctr \u2190 1 to q. The adversary controlling t parties\ngets qt total queries per round.\nIt has been proven [21,22] that executions follow the properties of\nChain Growth, Common Prefix, and Chain Quality.\nWe define a Q-block as a block satisfying a predicate Q on its hash.\nNote that this evaluation does not depend on any particular execution.\nDefinition 1 (Q-block). A block property is a predicate Q defined on\na hash output h \u2208 {0,1}\u03ba. Given a block property Q, a valid block with\nhash h is called a Q-block if Q(h) is true.",
    "source":"whitepaper",
    "section":"theoremwewilleventuallyproveisageneralizationoftheCommonPrefix (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":193.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_81",
    "content":"# The block properties we are interested in will be evaluated in actual\n\nexecutions as Q(H(\u27e8ctr,s,x\u27e9)) for particular blocks. As such, we will be",
    "source":"whitepaper",
    "section":"The block properties we are interested in will be evaluated in actual",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":11.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_82",
    "content":"# interested in properties which are polynomially computable given h as\n\nthe input.\nDefinitions of random variables. We will call a query of a party successful\nifitsubmitsatriple(ctr,s,x)suchthatH(ctr,s,x) \u2264 T.Considerablock\nproperty Q. Let \u03be = Pr[Q(h)|h \u2264 T], when h is uniformly distributed\nover the range of the hash function. For each round i, query j \u2208 [q], and\nk \u2208 [t] (the kth party controlled by the adversary), we define Boolean\nrandom variables X (i),Y (i) and Z (i,j,k) as follows. If at round i an",
    "source":"whitepaper",
    "section":"interested in properties which are polynomially computable given h as",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":75.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_83",
    "content":"# Q Q Q\n\nhonest party obtains a Q-block, then X (i) = 1, otherwise X (i) = 0.",
    "source":"whitepaper",
    "section":"Q Q Q",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":15.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_84",
    "content":"# Q Q\n\nIf at round i exactly one honest party obtains a Q-block, then Y (i) =\n1, otherwise Y (i) = 0. Regarding the adversary, if at round i, the jth\nquery of the kth corrupted party obtains a Q-block, then Z (i,j,k) = 1,\n\u2211 \u2211 Q\notherwise Z (i,j,k) = 0. Define also Z (i) = t q Z (i,j,k). For\nQ \u2211 Q k=1 j=1 Q\na set of rounds S, let X (S) = X (r) and similarly define Y (S)\nQ r\u2208S Q Q\nand Z (S). We drop the subscript from all variables X,Y,Z, when the\nQ-blockissimplythepropertyofbeingavalidblock.Further,ifX(i) = 1,\nwe call i a successful round and if Y(i) = 1, a uniquely successful round.\nAs in the backbone model [21], the probability f that at least one\nhonest party computes a solution at given round is an important parameter. Writing p = T\/2\u03ba for the probability of success of a single query, we\n\n--- Page 22 ---",
    "source":"whitepaper",
    "section":"Q Q",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":162.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_85",
    "content":"# have\n\n(1\u2212f)pq(n\u2212t) \u2264 f = E[X(i)] = 1\u2212(1\u2212p)q(n\u2212t) \u2264 pq(n\u2212t).",
    "source":"whitepaper",
    "section":"have",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":9.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_86",
    "content":"# The following bounds relate the expectations of the random variables\n\ndefined above to f, for all i and block properties Q.\n\u03be f\n\u03be f \u2264 E[X (i)] \u2264 Q , \u03be f(1\u2212f) < E[Y (i)],\nQ Q 1\u2212f Q Q\n\u03be f t\nE[Z (i)] \u2264 Q \u00b7 .\nQ 1\u2212f n\u2212t\nFor the derivations of these inequalities see Garay et al. [20].\nTypical executions. We now define our typical set of executions. This\nfollows the backbone model, but extended to include block properties.\nInformally, this set consists of those executions with polynomially many",
    "source":"whitepaper",
    "section":"The following bounds relate the expectations of the random variables",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":85.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_87",
    "content":"# rounds and with the property that all the random variables of interest\n\nover su\ufb00iciently many (at least \u03bb = \u2126(\u03ba)) consecutive rounds do not\ndeviate too much from their expectation. To this end, recall the following\nterms[20].Aninsertionoccurswhen,givenachainC withtwoconsecutive\n\u2032 \u2217 \u2032 \u2217 \u2032\nblocks B and B , a block B created after B is such that B,B ,B form\nthree consecutive blocks of a valid chain. A copy occurs if the same block\nexistsintwodifferentpositions.Aprediction occurswhenablockextends\none which was computed at a later round.\nDefinition 2 (Typical execution). Forareal\u03f5 \u2208 (f, 1),integer\u03bb,and\na collection of polynomially many block properties Q, we say an execution\nis Q-typical (or simply typical), if the following hold.\n\u2013 For any Q \u2208 Q and any set S of at least \u03bb\/\u03be consecutive rounds we",
    "source":"whitepaper",
    "section":"rounds and with the property that all the random variables of interest",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":118.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_88",
    "content":"# have\n\n(1\u2212\u03f5)E[X (S)] < X (S) < (1+\u03f5)E[X (S)], (1)",
    "source":"whitepaper",
    "section":"have",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":9.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_89",
    "content":"# Q Q Q\n\n(1\u2212\u03f5)E[Y (S)] < Y (S), (2)",
    "source":"whitepaper",
    "section":"Q Q Q",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":6.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_90",
    "content":"# Q Q\n\nZ (S) < E[Z (S)]+\u03f5E[Y (S)]. (3)",
    "source":"whitepaper",
    "section":"Q Q",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":7.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_91",
    "content":"# Q Q Q\n\n\u2013 No insertions, no copies, and no predictions occurred.\nTheorem 4. If t < (1\u2212\u03b4)(n\u2212t) with \u03b4 > 3\u03f5+3f, an execution is typical\nwith probability 1\u2212e \u2212\u2126(\u03f52f\u03bb).\n\n--- Page 23 ---\nProof. The proof uses standard Chernoff bounds, along the lines of [20].\nWejustnotethatthevariablesX (i)(andsimilarlyY (i)andZ (i,j,k))",
    "source":"whitepaper",
    "section":"Q Q Q",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":47.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_92",
    "content":"# Q Q Q\n\n",
    "source":"whitepaper",
    "section":"Q Q Q",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_93",
    "content":"# areindependentBernoullitrialsforeachQandsuccessfulwithprobability\n\n\u0398(\u03be f). In addition, a union bound is applied over all Q. \u2293\u2294\nLemma 1. Assume t < (1\u2212\u03b4)(n\u2212t) with \u03b4 > 3\u03f5+3f and a Q-typical\nexecution. Then, the following hold for any Q \u2208 Q and any set S of at\nleast \u03bb\/\u03be consecutive rounds.\n(a) (1\u2212\u03f5)\u03be f|S| < X (S) < (1+\u03f5)\u00b7 \u03beQf \u00b7|S|.\nQ Q 1\u2212f\n(b) (1\u2212 \u03b4)\u03be f|S| < (1\u2212\u03f5)\u03be f(1\u2212f)|S| < Y (S).",
    "source":"whitepaper",
    "section":"areindependentBernoullitrialsforeachQandsuccessfulwithprobability",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":69.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_94",
    "content":"# 3 Q Q Q\n\n(c) Z (S) < ( t \u00b7 1 +\u03f5)\u00b7\u03be f|S| \u2264 (1\u2212 2\u03b4)\u03be f|S|.\nQ n\u2212t 1\u2212f Q 3 Q\n(e) Z (S) < Y (S).",
    "source":"whitepaper",
    "section":"3 Q Q Q",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":26.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_95",
    "content":"# Q Q\n\nProof. This follows with straightforward calculations from the properties\nof a typical execution, the bounds on the expectations of the involved\nrandom variables, and the assumed bounds on t\/n,\u03b4,\u03f5 and f. \u2293\u2294\nWe now establish an upper bound in the number of Q-blocks an adversary can suppress, regardless of what attack method she follows.\nUniquelysuccessfulroundshavethefollowingimportantproperty[20].\nLemma 2 (Pairing). For any i and any pair of distinct blocks C[i] and\nC\u2032 [i], if C[i] was computed by an honest party in a uniquely successful\nround, then\n[i] was computed by the adversary.\nProof. Let r be the uniquely successful round that C[i] was computed.\nNo honest party would extend C\u2032 [i \u2212 1] at a round later than r, since\nevery honest party would have a chain of length at least i. Similarly, if an",
    "source":"whitepaper",
    "section":"Q Q",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":134.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_96",
    "content":"# honest party computed\n\n[i] at some round earlier than r, then no honest\nparty would have extended C[i\u22121] at round r. Finally, C\u2032 [i] cannot have\nbeen computed by an honest party at round r, since r was a uniquely\nsuccessful round. \u2293\u2294\nLemma 3 (Suppression). If r is a uniquely successful round and the",
    "source":"whitepaper",
    "section":"honest party computed",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":52.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_97",
    "content":"# corresponding block does not belong to the chain of an honest party at a\n\nlater round, then there is a set of consecutive rounds S such that r \u2208 S\nand Y(S) \u2264 Z(S).\nProof. LetC bethechainofthehonestpartythatwassuccessfulatround\nr and u the depth of the corresponding block. Let r be the first round",
    "source":"whitepaper",
    "section":"corresponding block does not belong to the chain of an honest party at a",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":38.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_98",
    "content":"# after r in which an honest party has a chain\n\n",
    "source":"whitepaper",
    "section":"after r in which an honest party has a chain",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_99",
    "content":"# which does not contain\n\n--- Page 24 ---\nblock C[u]. Let C\u2032 [u \u2032 ] the last block of C\u2032 at round r \u2032 . Let C[u \u2217 ] = C\u2032 [u \u2217 ]\nbe the last honest block on the common prefix of C and C\u2032 , and let r \u2217\nbe its timestamp. We claim that the set S = {i : r \u2217 < i < r \u2032} satisfies\nthe requirements of the statement. Clearly, r \u2208 S. Let us verify that\nY(S) \u2264 Z(S). Indeed, if C\u2217 [v] is any block computed during a uniquely\nsuccessful round i \u2208 S, it must hold u \u2217 < v \u2264 u \u2032 . The first inequality is\nbecause the party computing C\u2217 [v] knows of C[u \u2217 ] (it was announced at\n\u2217 \u2217\nround r and received by round i > r ) and would not mine on a shorter\nchain. The second inequality holds because v > u contradicts an honest",
    "source":"whitepaper",
    "section":"which does not contain",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":161.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_100",
    "content":"# party having a chain of length u\n\n",
    "source":"whitepaper",
    "section":"party having a chain of length u",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_101",
    "content":"# at round r\n\n> i (since\n[v] was received\nby round r ). The inequality then follows by Lemma 2, since it is always\npossible to find a block distinct from C\u2217 [v] on C or C\u2032 (we may use C\u2032 ,",
    "source":"whitepaper",
    "section":"at round r",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":39.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_102",
    "content":"# unless\n\n[v] is on\n, in which case\u2014due to the minimality of r\n\u2014we have\nv < u and we can use C). \u2293\u2294\nAn observation that follows from the above lemma is that if the adversary manages to suppress a Q-block from the chain of an honest party\nand this Q-block was computed in a uniquely successful round, then we\ncan associate with it an adversarial block. In particular, if r is a uniquely",
    "source":"whitepaper",
    "section":"unless",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":74.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_103",
    "content":"# successfulroundandthecorrespondingblockdoesnotbelongtothechain\n\nofanhonestpartyatalaterround,thenthereisanassociated adversarial\nblock of the same height that was adopted by an honest party.\nWenowstateandproveourUnsuppressibilityLemma.Informally,the",
    "source":"whitepaper",
    "section":"successfulroundandthecorrespondingblockdoesnotbelongtothechain",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":15.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_104",
    "content":"# lemmasaysthatifthenumberofblockstheadversaryobtainedinasetof\n\n",
    "source":"whitepaper",
    "section":"lemmasaysthatifthenumberofblockstheadversaryobtainedinasetof",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_105",
    "content":"# consecutive rounds is z and the number of the uniquely successful blocks\n\nthehonestpartiesobtainedinthesamesetofroundsisy,thenthereexist\ny\u22122z blocks that will always belong to the chain of every honest party.\nIt follows that if the power of the adversary is bounded below 1\/3 of the\ntotal power, then with overwhelming probability there will be a nonzero\nnumber of such blocks.",
    "source":"whitepaper",
    "section":"consecutive rounds is z and the number of the uniquely successful blocks",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":44.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_106",
    "content":"# An important note with respect to the Unsuppressibility Lemma is\n\nthe following. Fix all the randomness the random oracle requires for a\ngiven execution. This determines the successful queries of every party\nand therefore determines the parameters y and z above. The observation",
    "source":"whitepaper",
    "section":"An important note with respect to the Unsuppressibility Lemma is",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":33.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_107",
    "content":"# is that even if these random coins are revealed to the adversary at the\n\nbeginning of the execution, one can determine precisely which y \u2212 2z\nblocks \u2014and no matter the adversary\u2019s strategy\u2014 will always belong to\nthe chain of every honest party.\n\n--- Page 25 ---\nLemma 4 (Unsuppressibility). In a typical execution, every set of\nconsecutive rounds U has a subset S of uniquely successful rounds, such",
    "source":"whitepaper",
    "section":"is that even if these random coins are revealed to the adversary at the",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":55.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_108",
    "content":"# that\n\n\u2013 |S| \u2265 Y(U)\u22122Z(U)\u22122\u03bbf( t \u00b7 1 +\u03f5) and\nn\u2212t 1\u2212f\n\u2013 after the last round in S the blocks corresponding to S belong to the\nchain of every honest party.\nProof. Let U be the set of consecutive rounds that contains U and also\nthe \u03bb rounds that come before and after U. By Lemma 3, we may take S\ntocontainallthoseuniquelysuccessfulroundsr \u2208 U suchthatforanyset\nof consecutive rounds S \u2032 \u2286 U \u2032 containing r, Y(S \u2032 ) > Z(S \u2032 ). Note that, in\n\u2032 \u2032\na typical execution, no such S may contain elements outside U . Letting\ny = Y(U) and z = Z(U), we need to show y\u2212|S| \u2264 2z+2(1\u2212 2\u03b4)\u03bbf.\nLet us focus on the uniquely successful rounds not in S. Consider a\ncollection T of sets of consecutive rounds with the following properties.\n\u2013 For all T \u2208 T, Y(T) \u2264 Z(T).\n\u2013 For each r \u2208 U \\S, there is a T \u2208 T that contains r.\n\u2013 |T| is minimum among all collections with the above properties.",
    "source":"whitepaper",
    "section":"that",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":175.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_109",
    "content":"# WenowobservethattheminimalityconditiononT impliesthatnoround\n\nr with Z > 0 belongs to more than two sets of T. If that was the case,\nthen there would be three sets T ,T ,T in T with T \u2229 T \u2229 T \u0338= \u2205.\n1 2 3 1 2 3\nBut then, we could keep the two sets with the leftmost and rightmost\nendpoints, contradicting the minimality of T. Furthermore, no round in\nU \u2032\\U belongs to more than one set of T. Thus,\n\u2211 \u2211 \u2211\ny\u2212|S| = Y \u2264 Y(T) \u2264 Z(T) \u2264 2z+Z(U \u2032\\U).\ni\u2208U\\S T\u2208T T\u2208T",
    "source":"whitepaper",
    "section":"WenowobservethattheminimalityconditiononT impliesthatnoround",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":93.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_110",
    "content":"# The third inequality holds because every round in which the adversary\n\n",
    "source":"whitepaper",
    "section":"The third inequality holds because every round in which the adversary",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_111",
    "content":"# was successful is countedat most twiceinside U and at most once outside\n\nU (by the discussion above the inequalities). Finally, using |U \u2032\\U| \u2264 2\u03bb\nand Lemma 1(c) we obtain the stated bound. \u2293\u2294",
    "source":"whitepaper",
    "section":"was successful is countedat most twiceinside U and at most once outside",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":22.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_112",
    "content":"# The proof of this lemma is quite generous to the adversary on two\n\naccounts. First, it reveals to the adversary all coin flips in the beginning\nof the execution. Second, it gives the adversary two choices for each one\nof his blocks, and assumes that he will be able to choose among these as\nhe sees fit. Nevertheless, we conjecture that the bound y\u22122z cannot be\nsubstantially increased in the case the property is rare.\n\n--- Page 26 ---\nWe can now prove that an adversary with less than 1\/3 of the total\nmining power cannot create a chain with more Q-blocks than an honest\nchain. Such a task would require the adversary to both suppress many\nQ-blocks from the honest chain and to obtain many of them for the adversarial chain.\nLemma 5 (Q-block Common-Prefix). Assume t < (1\u2212\u03b4)n with \u03b4 >\n3\u03f5+3f and a Q-typical execution. Consider a round at which a chain C is",
    "source":"whitepaper",
    "section":"The proof of this lemma is quite generous to the adversary on two",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":144.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_113",
    "content":"# adopted by an honest party and suppose there exist another chain\n\n",
    "source":"whitepaper",
    "section":"adopted by an honest party and suppose there exist another chain",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_114",
    "content":"# such\n\n",
    "source":"whitepaper",
    "section":"such",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_115",
    "content":"# that (Part 1)\n\nC\u2032\\(C\u2032\u2229C)\nhas at least 22\u03bb\u03be f Q-blocks. Then, with overwhelming\nprobability, C has more Q-blocks than C\u2032 .\nProof. Assumeanexecutioninwhichtheassumptionsofthelemmahold.\nLet r \u2217 be the round on which the last honest block on C\u2217 = C \u2229C\u2032 was\ncomputed (if no such block exists let r = 0) and define the set of rounds\nS = {i : r \u2217 < i \u2264 r}. We will study the execution during the rounds in\nS. To that end, let W \u2032 denote the set of adversarial queries on C\u2032 \\ C\u2217\nat some round at least \u03bb greater from r . Denote by W the rest of the\nadversarial queries in S.\nWe first observe that no query in W could have suppressed a Q-block\nonC.AsintheproofofLemma3,insuchacasetherewouldexistasetof\nconsecutive rounds |S \u2217| \u2265 \u03bb such that Y(S \u2217 ) \u2264 Z(S \u2217 ). This contradicts\nthe last item of Lemma 1.\nFrom this observation and the Unsuppressibility Lemma, there are at\nleast Y(S)\u22122Z(W)\u22122\u03bbf( t \u00b7 1 +\u03f5) blocks that the adversary cannot\nn\u2212t 1\u2212f\nsuppress. Each of these is a Q-block independently with probability \u03be .\nUnder our assumptions, 2( t \u00b7 1 +\u03f5) < 1\u2212\u03b4. We conclude that, with\nn\u2212t 1\u2212f 1\u2212\u03f5\noverwhelming probability, there are at least\n[ ]\n(1\u2212\u03f5)\u03be \u00b7 Y(S)\u22122Z(W) \u2212(1\u2212\u03f5)\u03bb\u03be f",
    "source":"whitepaper",
    "section":"that (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":213.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_116",
    "content":"# Q Q\n\nQ-blocks on C \\C\u2217 .\nOntheotherhand,thenumberofQ-blocksonC\u2032\\C\u2217\nisatmosttheQ-\nblocks from the W queries plus the Q-blocks from the initial \u03bb rounds.\nThe latter can be shown to be at most 3\u03bb\u03be f. For the former, using\nLemma 6 (with F = 1 when j \u2208 W \u2032 and M = 1 when it resulted in a Qj j\nblock) and Lemma 1, in a typical execution, are at most (1+\u03f5)\u03be Z(W ).\nThus, there at most\n(1+\u03f5)\u03be p|W \u2032|+3\u03bb\u03be f.",
    "source":"whitepaper",
    "section":"Q Q",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":79.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_117",
    "content":"# Q Q\n\nQ-blocks on C\u2032 \\ C\u2217 . Since these are at least 22\u03bb\u03be f, it can be shown",
    "source":"whitepaper",
    "section":"Q Q",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":17.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_118",
    "content":"# that the difference between the last two displayed expressions is at least\n\n--- Page 27 ---\n(1\u2212\u03f5)\u03be \u00b7[Y(S)\u22122Z(S)]. This is positive in a typical execution in which\nthe power of the adversary is bounded below 1 \u2212\u03b4 the total power. \u2293\u2294",
    "source":"whitepaper",
    "section":"that the difference between the last two displayed expressions is at least",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":29.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_119",
    "content":"# 7 Analysis (Part 1)\n\nWe are now ready to prove the construction of Algorithms 1 and 2 secure\nandsuccinct.Forsecurity,wedenote\u03a0 theproofpresentedbythehonest\nparty and \u03a0 the proof presented by the adversary (but these can be\ngiven to the verifier algorithm in any order). We can safely assume that\nthese proofs were both generated at round r (the adversary could have\ngenerated the proof earlier, but not later, than the honest party). The\nhonest proof \u03a0 was generated based on some honest underlying chain\nC using Algorithm 1. On the other hand, we have no guarantees about\nhow the adversarial proof \u03a0 was generated. It may be based on some\nunderlyingchainminedaccordingtoprotocol,ornot.Inanycase\u03a0 does\nform a chain and its blocks must have been mined in order, as the verifier\nensures this. However, there may not exist intermediate blocks covering\nthe whole proof-of-work as desired.\nSecuritymandatesthattheverifierchoosesthehonestproof,\u03a0.How-\never, it is possible that the verifier also chooses the adversarial proof, \u03a0 ,\nwithout raising any issue, as long as it extends the honest proof at a fork\npoint no longer than k from the tip. To see why this is fine, note that\nan adversary can already do this at the full blockchain: According to the\nCommon Prefix property, she can fork at a block at most k blocks deep\nfrom the honest blockchain\u2019s end and have up to k blocks following the\nfork point. In this case, if it happens that the verifier has chosen \u03a0 , we\nrequire that (\u03a0 \u2032\u2229C)[\u22121] \u2208 C[\u2212k:]. This means that the adversarial proof\nextends the honest chain at some fork point in C[\u2212k:]. But let us contemplate what this entails: It means that the portion \u03a0 \u2032{(\u03a0 \u2032 \u2229C)[\u22121]:}\nis just a valid 0-level extension of the honest chain. As such, requiring\n|\u03a0 \u2032{(\u03a0 \u2032 \u2229 C)[\u22121]:}| \u2265 |C{(\u03a0 \u2032 \u2229 C)[\u22121]:}| would produce a competitive",
    "source":"whitepaper",
    "section":"7 Analysis (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":302.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_120",
    "content":"# adversarial chain that is longer than the honest chain and it would be (Part 1)\n\nperfectly acceptable to a full node (and by the common prefix property,\nthisdifferencecannotbelargerthank blockslong).Wemustclearlyallow\nfor this possibility \u2014 but it is not a problem, as this situation can occur\nin full node executions, too. This property also holds trivially in case the\nhonest proof is chosen.\nTheorem 5 (Security). Consider an arbitrary 1-bounded PPT adver3\nsary A in a typical execution. Let \u03a0 be a proof generated by an honest party at round r using Algorithm 1 by passing his underlying chain",
    "source":"whitepaper",
    "section":"adversarial chain that is longer than the honest chain and it would be (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":82.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_121",
    "content":"# adversarial chain that is longer than the honest chain and it would be (Part 2)\n\n--- Page 28 ---\nC. Let \u03a0 \u2032 be an arbitrary proof generated by the adversary at round r.\nLet \u03a0 be the proof accepted by the verifier using Algorithm 2. Then\n|\u03a0 \u2217{(\u03a0 \u2217\u2229C)[\u22121]:}| \u2265 |C{(\u03a0 \u2217\u2229C)[\u22121]:}| with overwhelming probability.\nProof. Let\n= \u03a0\n. We need to show that, either \u03a0 will be the proof\naccepted by the verifier, or \u03a0 is a proof extending the honest chain that\nis longer at level 0, as mandated by the theorem statement.\nLet us consider first the case that a \u00b5 of Algorithm 2 as above exists.\nWhen\u00b5 = 0,theverifierdeterminesthelongerchainandalwayscorrectly\naccepts the corresponding proof. That is, the verifier will either choose\n\u2217 \u2217 \u2032\n\u03a0 = \u03a0, or, in case \u03a0 = \u03a0 , the verifier will choose the adversarial\n\u2032 \u2032\nproof \u03a0 which contains a \u03c7 that extends the honest chain\u2019s \u03c7 at level\n0 (up to k blocks long) with a longer alternative. This is the only case\nin which \u03a0 can win. For the other cases, we will now argue that the\nadversary cannot win.\nLet us now focus on the case 0 < \u00b5 \u2264 \u2113. Note that, since D[\u00b5\u22121]\u2229\nD\u2032 [\u00b5\u22121] = \u2205 (by the minimality of \u00b5), both superchains must have at\nleast m blocks after their common block b. The Q-block Common-Prefix\nLemma implies that \u03a0 is accepted.\nNext,considerthecasethatnosuch\u00b5exists.Clearly,\u2113 \u0338= \u2113 \u2032 (otherwise\nD[\u2113]\u2229D\u2032\n] would contain the genesis block) and we need to argue that\n\u2032 \u2032\n\u2113 > \u2113. Assume \u2014towards a contradiction\u2014 that \u2113 < \u2113 and consider\nthe statement of the Q-block Common-Prefix Lemma instantiated with\nblocks of level \u2113+1 as the Q-blocks. Together with \u2113 < \u2113, it implies that\nC\u2032 has fewer than m Q-blocks after the common block with C (since C has\nfewer Q-blocks than\nin total, it must also have fewer on its fork; and\nthey must necessary share a common block, since both must begin with\ngenesis). But then, both C and C\u2032 have fewer than m Q-blocks after their\ncommon block. Since D[\u2113]\u2229D\u2032 [\u2113] = \u2205 by assumption, this cannot be the\ncase. \u2293\u2294\nTheorem 6 (Succinctness). In a typical execution with t < (1 \u2212\u03b4)n\nwith 3\u03f5+3f < \u03b4 < 1 and letting m = \u03bb, an honest miner\u2019s state is in\nO(m2log(r)) at round r.\nProof. Ast < (1\u2212\u03b4)nwith3\u03f5+3f < \u03b4 < 1,thereforec = E[Y]\u22122E[Z]\u2212\n3 3\n2\u03bbf( t 1 +\u03f5) will be a positive constant and for sets of consecutive\nn\u2212t1\u2212f\nrounds U with |U| \u2265 \u03bb, we will have Y(U)\u22122Z(U)\u22122\u03bbf( t 1 +\u03f5) >\nn\u2212t1\u2212f\n(1\u2212\u03f5)c|U|.\nConsider a state \u03a0 generated by an honest prover and suppose for\ncontradictionthat|\u03a0| \u2208 \u03c9(mlog(r)),wherer indicatesthecurrentround",
    "source":"whitepaper",
    "section":"adversarial chain that is longer than the honest chain and it would be (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":445.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_122",
    "content":"# adversarial chain that is longer than the honest chain and it would be (Part 3)\n\n--- Page 29 ---\nnumber. From the security of the scheme, this state will correspond to\nsome underlying chain C such that \u03a0 is the compression of C. Consider\nthe variables (D,\u03c7) = Dissolve (C). As |\u03c7| = k is constant, therefore\n\u222a m,k\n| d| \u2208 \u03c9(mlog(r)). Let \u2113 = |D|. It holds that \u2113 \u2208 O(log(|C|)). Consed\u2208D \u2211\nquently, |d| \u2208 \u03c9(mlog(r)). Therefore there must exist some \u00b5 such\nd\u2208D\nthat |D[\u00b5]| \u2208 \u2126(\u03bb2). Consider the maximum such \u00b5.\nWe distinguish two cases.\nCase 1: \u00b5 = \u2113. Then consider D[\u2113]. Let u denote the round dur0\ning which D[\u2113][0] was generated and u denote the round during which\nD[\u2113][\u22121]wasgeneratedandconsiderthesetU ofconsecutiveroundsfrom\nu to u . As D[\u2113] forms a chain, we have that |U| \u2265 |D[\u2113]| > \u03bb. Apply0 1\ning the Unsuppressibility Lemma, we obtain that at least |S| \u2265 c|U| =\nc|D[\u2113]| \u2208 \u2126(\u03bb) rounds of U must have been uniquely successful and belong to the chain of every honest party. Therefore |D[\u2113]\u2191\u2113+1 | \u2265 (1\u2212\u03f5) |S| .\nBy the definition of \u2113 this is impossible.\nCase2:0 \u2264 \u00b5 < \u2113.Bymaximalityof\u00b5,wehave|D[\u00b5+1]| \u2208 O(\u03bb),but\n|D[\u00b5]| \u2208 \u2126(\u03bb2). By the definition of D[\u00b5] = C[:\u2212k]\u2191\u00b5 [\u22122m:]\u222aC[:\u2212k]\u2191\u00b5\n{C[: \u2212 k]\u2191\u00b5+1 [\u2212m]:}, clearly |C[: \u2212 k]\u2191\u00b5 [\u22122m:]| = 2m so necessarily\nC[:\u2212k]\u2191\u00b5 {D[\u00b5+1][\u2212m]:} \u2208 \u2126(\u03bb2). Therefore there exist blocks A and B\nin D[\u00b5+1] and D[\u00b5] such that |D[\u00b5+1]{A:Z}| = 1, but |D[\u00b5]{A:Z}| \u2208\n\u03c9(\u03bb). Similarly to case 1, consider the rounds u and u during which\n0 1",
    "source":"whitepaper",
    "section":"adversarial chain that is longer than the honest chain and it would be (Part 3)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":249.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_123",
    "content":"# blocks A and Z were generated respectively and the set of consecutive\n\nrounds U from u to u with |U| \u2208 \u03c9(\u03bb). Using the Unsuppressibility\n0 1\nLemma, there must exist a set of uniquely successful rounds |S| \u2265 c|U|",
    "source":"whitepaper",
    "section":"blocks A and Z were generated respectively and the set of consecutive",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":28.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_124",
    "content":"# whose blocks have been adopted by all honest parties and of which at\n\nleast (1\u2212\u03f5) |S| \u2265 0 will be of level \u00b5+1. Therefore there must exist a\nblock between A and Z in D[\u00b5+1].\nBoth cases are contradictions. \u2293\u2294",
    "source":"whitepaper",
    "section":"whose blocks have been adopted by all honest parties and of which at",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":27.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_125",
    "content":"# The previous theorem allows us to make miners reject incoming state\n\nthat is too large (more than polylogarithmic) without processing them\nfully.",
    "source":"whitepaper",
    "section":"The previous theorem allows us to make miners reject incoming state",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":11.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_126",
    "content":"# We note here that our analysis critically relies on the honest majority\n\nassumption holding throughout the execution. The reason why our verifiers can maintain a valid chain is that, once they receive a chain C which\nis the longest, they inductively know that C[\u2212k] must contain valid application data snapshot. Then, since they have all the last k blocks, they\ncan validate the transactions \u03b4 on the snapshot obtained before further\nmining on top of them.\n\n--- Page 30 ---",
    "source":"whitepaper",
    "section":"We note here that our analysis critically relies on the honest majority",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":68.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_127",
    "content":"# 8 Discussion and Future Work\n\nWe have presented a scheme in which full miners are replaced with logarithmic-spaceminers.Ournewminingprotocolallowsminerstoonlykeep\nstorage growing logarithmically in time. Furthermore, the data communicated to newly bootstrapped nodes is also logarithmic. We focused on\noptimizing the consensus data portion of blockchains (i.e., block headers)\nwithout concern for the application data portion. Our techniques can be\ncomposed with application data optimization techniques.\nWe have proven our scheme succinct and secure against all 1\/3 adversaries.Ourtreatmentrequiresuninterrupted honestcomputationalmajority throughout the execution, is in the static di\ufb00iculty model, works only\nfor proof-of-work blockchains, and requires modifications to the blockchain protocol for deployment. Let us discuss these aspects of our construction.\nTemporary dishonest majority. One important difference between",
    "source":"whitepaper",
    "section":"8 Discussion and Future Work",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":110.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_128",
    "content":"# our scheme and the existing blockchain protocols is that traditional full\n\n",
    "source":"whitepaper",
    "section":"our scheme and the existing blockchain protocols is that traditional full",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_129",
    "content":"# nodes are able to verify the whole state evolution of the system from (Part 1)\n\ngenesis. This allows them to recover in case of temporary dishonest majority [1,5], while our system cannot do so. Let us consider what could\nhappen in case an adversary temporarily has the upper hand in a blockchain where everybody is mining using our protocol. Let C denote the\nchainofthehonestpartiesthathasconverged.Theadversarybeginsmining on top of the honest tip. She eventually produces k+1 new blocks on\ntop of C[\u22121], generating an adversarial chain C\u2217 , prior to the honest partiesadvancingbyk+1blocks\u2014 aCommon Prefix violation.In theblock\nC\u2217 [\u2212k \u22121], the adversary places an invalid snapshot; say, a snapshot in\nwhich she owns a lot of money. The rest of the blocks in C\u2217 [\u2212k:] are filled\nwith valid transactions. This adversary can then compress this consensus\nstate into a convincing proof, as state transitions buried k+1 blocks beyond the tip are never checked. As soon as the honest parties transition\nto this adversarial chain, the attack concludes, and no more adversarial\nsupremacy is required. It is critical to understand what assumptions our\nprotocol mandates: An uninterrupted honest majority throughout the execution. It remains an open question whether it is possible to construct\nlogarithmic space mining protocols that can withstand temporary adversarial supremacy. We note that a similar uninterrupted honest majority\nassumption (for a 1\/2 adversary) is taken in the backbone model [21,22].\nDespitethestrengthofthisassumption,weremarkthatthehonestparties",
    "source":"whitepaper",
    "section":"nodes are able to verify the whole state evolution of the system from (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":217.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_130",
    "content":"# that are online during the time a long adversarial fork is first broadcast\n\n--- Page 31 ---\nto the network can still detect it. This long fork, generated during a temporary dishonest majority, will violate the k Common Prefix property:",
    "source":"whitepaper",
    "section":"that are online during the time a long adversarial fork is first broadcast",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":27.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_131",
    "content":"# A light miner will see a new winning proof arriving on the network with (Part 1)\n\na \u03c7 portion that shares no common blocks with its adopted \u03c7, and the\nsecond condition in Line 20 of Algorithm 3 will fail. However, miners that\nare offline when such a proof is first broadcast, and in particular miners\nwho bootstrap after the attack, will never detect it.\nThe1\/3adversary.Ideally,ourprotocolwouldworkfora1\/2adversary.\nHowever, it is an inherent limitation of our construction, and not the\ntechniques of our proofs, that only a 1\/3 adversary can be withstood.\nThis stems from the y \u22122z term in Lemma 4. While generous for small\n\u00b5, we conjecture that this bound is tight for su\ufb00iciently high \u00b5, and so\nan adversary with power between 1\/3 and 1\/2 can choose to operate at\nsuch levels. Therefore, a different construction is necessary to achieve a\n1\/2 adversarial bound. We leave such improvements for future work.\nVariable di\ufb00iculty. We have built and analyzed our logarithmic mining\nprotocol in the constant di\ufb00iculty setting, i.e., requiring that the target\nT is a constant. We strongly suspect, but have not provided proof, that\nsimilar protocols to ours work in the variable di\ufb00iculty setting. One important change in the protocol that is required before it can be adapted\nto variable di\ufb00iculty settings is that the \u03c7 portion of the proofs cannot be\na constant number of blocks long. Instead, it must be a su\ufb00ix which corresponds to su\ufb00icient work having been performed, the di\ufb00iculty of which\nmust correspond to the current target. Simply pruning k blocks long is\ninsu\ufb00icient. As such, the verifier must first gauge the di\ufb00iculty of the\nnetwork prior to taking conclusive decisions. An analysis in the variable\ndi\ufb00iculty model is beyond the scope of this work. The model required\nhere would make use of the martingale arguments in the variable di\ufb00iculty backbone model [22]. The precise proofs would need to articulate\nhow the security parameter m is related to the epoch length. We leave\nsuch analysis for future work.\nDeployment. Our scheme requires the introduction of interlink pointers\nto block headers. Some blockchains have already adopted such headers,\nnamely ZCash [34], ERGO [15], Nimiq, and WebDollar. Ethereum has\nproposals to adopt such interlinking [11]. Notably, Bitcoin, while possible [25], does not plan to include such a scheme. However, it may be\npossible to introduce these changes using a velvet fork [32,47]. While velvet forking can enable (superblock and FlyClient) NIPoPoW clients, it",
    "source":"whitepaper",
    "section":"A light miner will see a new winning proof arriving on the network with (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":392.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_132",
    "content":"# remains an open question whether it can also be used to transition to\n\nlight mining.\n\n--- Page 32 ---\nIncentive compatibility. There is a known [10] bribing attack against\nsuperblocks. This attack takes place in a rational setting and not in the\nhonestmajoritysettingofthebackbonemodel[21]whereourUnsuppressibility Lemma was developed. However, these game theoretic attacks are",
    "source":"whitepaper",
    "section":"remains an open question whether it can also be used to transition to",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":39.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_133",
    "content":"# possible only because superblocks give out rewards utilizing the same (Part 1)\n\nschedule as regular blocks. A proposal to make unbribable superblocks\n(using a soft fork) has been recently put forth [48] and can be readily\nadopted for our purposes.\nComparison to other NIPoPoWs. Our protocol is a Non-Interactive\nProof of Proof-of-Work, akin to superblock NIPoPoWs [31] and FlyClient [10]. Our difference with FlyClient is the ability to generate online\nproofs, proofs that can be updated as the blockchain grows. Contrary\nto our construction, FlyClient requires the sampling of past blocks to\nchange as new blocks are added to the tip of the blockchain. This is due\nto their use of the Fiat\u2013Shamir heuristic [19]. More concretely, a block\nthat was not sampled in the past may need to be sampled in the future.\nIn our protocol, previously pruned blocks never need to be salvaged. As\nany block has a potential for future samplability in FlyClient, no blocks\ncan be discarded, and mining cannot be logarithmic. This is an inherent\nlimitation of their construction. The construction of superblock NIPoPoWs [31] is similar to ours. However, their construction is not both succinct and secure against all adversaries. In particular, their certificates of\nbadness allow an adversary to pump the storage state required from logarithmic to linear with the appropriate attack, and their construction is\nonly optimistically succinct (i.e., succinct in honest settings). While both\nconstructions sample superblocks, our means of sampling and comparing\nthem are different. Critically, our comparison is unweighted and always\ntakes place across the same levels \u00b5, while theirs must be weighted and\ncompared against potentially different levels \u00b5 and \u00b5 . The proofs we",
    "source":"whitepaper",
    "section":"possible only because superblocks give out rewards utilizing the same (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":265.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_134",
    "content":"# A B\n\n",
    "source":"whitepaper",
    "section":"A B",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_135",
    "content":"# have developed here are always succinct and always secure against any\n\n1\/3 adversary (with overwhelming probability). Our analysis is based",
    "source":"whitepaper",
    "section":"have developed here are always succinct and always secure against any",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":9.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_136",
    "content":"# on our framework consisting of the novel Unsuppressibility Lemma and\n\nthe generalized Common Prefix theorem, a completely new approach to\nproving security and succinctness. We are thus the first to propose a NIPoPoW which is online, succinct, and secure against all minority (1\/3)\nadversaries. All of these are necessary prerequisites to achieve the desired\ngoal of logarithmic-space mining. Our new probabilistic analysis techniques can be leveraged to significantly simplify the previous analyses of\nthe above protocols.\n\n--- Page 33 ---\nProof of Stake.OurprotocolonlyworksforProof-of-Workblockchains.\nIt seems that our techniques cannot be readily adapted to the Proofof-Stake setting. The probabilistic nature of Q-blocks and predictable\nstochasticprocessesareaby-productoftheminingprocessandthenature\nof the random oracle model. Simple ideas do not work. If we allow the",
    "source":"whitepaper",
    "section":"on our framework consisting of the novel Unsuppressibility Lemma and",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":108.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_137",
    "content":"# block producers to annotate their blocks with an appropriate level and\n\nsignit,theadversarycanfakethis.Ifinsteadwetakeastochasticproperty\nof blocks, the adversary can perform grinding attacks, putting in work\nwhile honest parties are only putting in stake, leading to an adversarial\nadvantage, since this is a setting where only stake majority assumptions\nare made. It remains an open question whether the consensus data of\nstake blockchains can be compressed.",
    "source":"whitepaper",
    "section":"block producers to annotate their blocks with an appropriate level and",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":52.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_138",
    "content":"# References (Part 1)\n\n1. G. Avarikioti, L. K\u00e4ppeli, Y. Wang, and R. Wattenhofer. Bitcoin security under\ntemporary dishonest majority. In 23rd Financial Cryptography and Data Security\n(FC). Springer, 2019.\n2. G. Avarikioti, E. Kokoris-Kogias, and R. Wattenhofer. Divide and scale: Formalizationofdistributedledgershardingprotocols. arXiv preprint arXiv:1910.10434,\n2019.\n3. Z. Avarikioti, E. Kogias, R. Wattenhofer, and D. Zindros. Brick: Asynchronous\nincentive-compatiblepaymentchannels. InInternational Conference on Financial\nCryptography and Data Security. Springer, 2021.\n4. Z.Avarikioti,O.S.T.Litos,andR.Wattenhofer.CerberusChannels:Incentivizing\nWatchtowers for Bitcoin. In International Conference on Financial Cryptography\nand Data Security, pages 346\u2013366. Springer, 2020.\n5. C. Badertscher, P. Gazi, A. Kiayias, A. Russell, and V. Zikas. Consensus redux:\ndistributed ledgers in the face of adversarial supremacy. Technical report, Cryptology ePrint Archive, Report 2020\/1021, 2020.\n6. M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designinge\ufb00icientprotocols. InProceedingsofthe1stACMconferenceonComputer\nand communications security, pages 62\u201373. ACM, ACM, 1993.\n7. E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Scalable, transparent,\nand post-quantum secure computational integrity. IACR Cryptol. ePrint Arch.,\n2018:46, 2018.\n8. J. Bonneau, A. Miller, J. Clark, A. Narayanan, J. A. Kroll, and E. W. Felten.\nSoK: Research perspectives and challenges for bitcoin and cryptocurrencies. In\n2015 IEEE Symposium on Security and Privacy, pages 104\u2013121. IEEE Computer\nSociety Press, May 2015.\n9. B.B\u00fcnz,J.Bootle,D.Boneh,A.Poelstra,P.Wuille,andG.Maxwell.Bulletproofs:\nShortproofsforconfidentialtransactionsandmore. In2018 IEEE Symposium on\nSecurity and Privacy (SP), pages 315\u2013334. IEEE, IEEE Computer Society, 2018.\n10. B. B\u00fcnz, L. Kiffer, L. Luu, and M. Zamani. Flyclient: Super-light clients for\ncryptocurrencies. IACR Cryptology ePrint Archive, 2019, 2019.\n11. V. Buterin. Blockhash refactoring. URL: https:\/\/github.com\/ethereum\/EIPs\/\nblob\/master\/EIPS\/eip-210.md, 2017.",
    "source":"whitepaper",
    "section":"References (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":248.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_139",
    "content":"# References (Part 2)\n\n--- Page 34 ---\n12. V. Buterin et al. A next-generation smart contract and decentralized application\nplatform. white paper, 2014.\n13. A. Chepurnoy, M. Larangeira, and A. Ojiganov. Rollerchain, a blockchain with\nsafely pruneable full blocks. arXiv preprint arXiv:1603.07926, 2016.\n14. A. Chepurnoy, C. Papamanthou, and Y. Zhang. Edrax: A Cryptocurrency with\nStatelessTransactionValidation.IACRCryptologyePrintArchive,2018:968,2018.\n15. E. Developers. Ergo: A resilient platform for contractual money, 2019.\n16. T.B.Developers. Developerguide-bitcoin. Availableat:https:\/\/bitcoin.org\/\nen\/developer-guide.\n17. T. Dryja. Utreexo: A dynamic hash-based accumulator optimized for the Bitcoin\nUTXO set. IACR Cryptol. ePrint Arch., 2019:611, 2019.\n18. C.DworkandM.Naor. Pricingviaprocessingorcombattingjunkmail. InAnnual\nInternational Cryptology Conference, pages 139\u2013147. Springer, Springer, 1992.\n19. A.FiatandA.Shamir. Howtoproveyourself:Practicalsolutionstoidentification\nand signature problems. In A. M. Odlyzko, editor, CRYPTO\u201986, volume 263 of\nLNCS, pages 186\u2013194. Springer, Heidelberg, Aug. 1987.\n20. J. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis\nand applications (revised 2019). Cryptology ePrint Archive, Report 2014\/765,\n2014. https:\/\/eprint.iacr.org\/2014\/765.\n21. J.A.Garay,A.Kiayias,andN.Leonardos. Thebitcoinbackboneprotocol:Analysisandapplications. InE.OswaldandM.Fischlin,editors,AnnualInternational\nConference on the Theory and Applications of Cryptographic Techniques, volume\n9057 of LNCS, pages 281\u2013310. Springer, Apr 2015.\n22. J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol with\nchains of variable di\ufb00iculty. In J. Katz and H. Shacham, editors, Annual International Cryptology Conference,volume10401ofLNCS,pages291\u2013323.Springer,\nAug 2017.\n23. E. Heilman, A. Kendler, A. Zohar, and S. Goldberg. Eclipse attacks on bitcoin\u2019s\npeer-to-peer network. Cryptology ePrint Archive, Report 2015\/263, 2015. http:\n\/\/eprint.iacr.org\/2015\/263.\n24. H. Jameson. Renaming suicide opcode. URL:\nhttps:\/\/github.com\/ethereum\/EIPs\/blob\/master\/EIPS\/eip-6.md, 2015.\n25. K.Karantias. Enabling NIPoPoWApplications on Bitcoin Cash. Master\u2019s thesis,\nUniversity of Ioannina, Ioannina, Greece, 2019.\n26. K.Karantias. Sok:Ataxonomyofcryptocurrencywallets. Technicalreport,IACR\nCryptology ePrint Archive, 2020: 868, 2020.\n27. K.Karantias,A.Kiayias,andD.Zindros.Compactstorageofsuperblocksfornipopow applications. In The 1st International Conference on Mathematical Research\nfor Blockchain Economy. Springer Nature, Springer Nature, 2019.\n28. A.Kiayias,P.Ga\u017ei,andD.Zindros.Proof-of-stakesidechains.InIEEESymposium\non Security and Privacy. IEEE, IEEE, 2019.\n29. A.Kiayias,N.Lamprou,andA.-P.Stouka. Proofsofproofsofworkwithsublinear\ncomplexity. In International Conference on Financial Cryptography and Data\nSecurity, pages 61\u201378. Springer, Springer, 2016.\n30. A. Kiayias and O. S. T. Litos. A composable security treatment of the lightning\nnetwork. In 2020 IEEE 33rd Computer Security Foundations Symposium (CSF),\npages 334\u2013349. IEEE, IEEE, 2020.\n31. A. Kiayias, A. Miller, and D. Zindros. Non-interactive proofs of proof-of-work,\n2017.",
    "source":"whitepaper",
    "section":"References (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":347.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_140",
    "content":"# References (Part 3)\n\n--- Page 35 ---\n32. A. Kiayias, A. Polydouri, and D. Zindros. The Velvet Path to Superlight Blockchain Clients. IACR Cryptology ePrint Archive, 2020:1122, 2020.\n33. A. Kiayias and D. Zindros. Proof-of-work sidechains. In International Conference on Financial Cryptography and Data Security: Workshop on Trusted Smart\nContracts. Springer, Springer, 2019.\n34. Y. T. Lai, J. Prestwich, and G. Konstantopoulos. FlyClient - Consensus-Layer\nChanges. URL: https:\/\/zips.z.cash\/zip-0221, 2019.\n35. R.Matzutt,B.Kalde,J.Pennekamp,A.Drichel,M.Henze,andK.Wehrle. How\ntosecurelyprunebitcoin\u2019sblockchain. In2020IFIPNetworkingConference(Networking), pages 298\u2013306. IEEE, 2020.\n36. I. Meckler and E. Shapiro. Coda: Decentralized cryptocurrency at scale.\nhttps:\/\/cdn.codaprotocol.com\/v2\/static\/coda-whitepaper-05-10-2018-0.pdf, May\n2018.\n37. R. C. Merkle. A digital signature based on a conventional encryption function.\nIn Conference on the Theory and Application of Cryptographic Techniques, pages\n369\u2013378. Springer, 1987.\n38. A. Miller. The high-value-hash highway. bitcoin forum post, 2012.\n39. S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.\n40. A. Poelstra. Mimblewimble. 2016.\n41. J. Poon and V. Buterin. Plasma: Scalable autonomous smart contracts. White\npaper, 2017.\n42. J. Poon and T. Dryja. The bitcoin lightning network: Scalable off-chain instant\npayments, 2016.\n43. W.Pugh. Skiplists:aprobabilisticalternativetobalancedtrees. Communications\nof the ACM, 33(6):668\u2013676, 1990.\n44. J. Teutsch and C. Reitwie\u00dfner. A scalable verification solution for blockchains.\narXiv preprint arXiv:1908.04756, 2019.\n45. G. Wood. Ethereum: A secure decentralised generalised transaction ledger. Ethereum Project Yellow Paper, 151:1\u201332, 2014.\n46. K.W\u00fcstandA.Gervais. Ethereumeclipseattacks. Technicalreport,ETHZurich,\n2016.\n47. A. Zamyatin, N. Stifter, A. Judmayer, P. Schindler, E. Weippl, W. Knottenbelt,\nandA.Zamyatin.Awildvelvetforkappears!inclusiveblockchainprotocolchanges\nin practice. In International Conference on Financial Cryptography and Data\nSecurity. Springer, 2018.\n48. D. Zindros. Soft Power: Upgrading Chain Macroeconomic Policy Through Soft\nForks. InInternational Conference on Financial Cryptography and Data Security.\nSpringer, Springer, 2021.",
    "source":"whitepaper",
    "section":"References (Part 3)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":266.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_141",
    "content":"# Appendix\n\n",
    "source":"whitepaper",
    "section":"Appendix",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_142",
    "content":"# A Maintaining Interlinks\n\n",
    "source":"whitepaper",
    "section":"A Maintaining Interlinks",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_143",
    "content":"# We wish to connect the blocks at each level with a previous block pointer (Part 1)\n\npointing to the most recent block of the same level. These pointers must\nbe included in the data of the block so that proof-of-work commits to\nthem. As the level of a block cannot be prediced before its proof-ofwork is calculated, we extend the previous block id structure of classical",
    "source":"whitepaper",
    "section":"We wish to connect the blocks at each level with a previous block pointer (Part 1)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":50.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_144",
    "content":"# We wish to connect the blocks at each level with a previous block pointer (Part 2)\n\n--- Page 36 ---\nblockchains to be a set, the interlink set. The interlink set points to the\nmost recent preceding block of every level \u00b5 (ignoring duplicates [25]). A\npointer to G is included in every block. The number of pointers that need\nto be included per block is in expectation O(log(|C|)) [27].\nFig.3. The probabilistic hierarchical blockchain. Higher levels have achieved a higher\ndi\ufb00iculty during mining. All blocks are connected to the genesis block G.\nG 3 3\n2 2\n1 1 1 1\n0 0 0 0 0 0 0\nThe algorithm for this construction is shown in Algorithm 4 [27]. The\ninterlink set of the Genesis block is, by definition, empty. The algorithm\ndescribes how the interlink can be updated once a block is found. The\nnewinterlinkisthenincludedinthenextblock.Thisconstructionensures\nthat every block contains a direct pointer to its most recent \u00b5-superblock\nancestor, for every \u00b5 \u2208 N.\nAlgorithm 4 The updateInterlinkSet algorithm which updates the interlink set\n1: function updateInterlinkSet(B\u2032)\n2: interlinkSet\u2190{H(B\u2032)}\n3: for H(B)\u2208B\u2032.interlink do\n4: if level(B)>level(B\u2032) then\n5: interlinkSet\u2190interlinkSet\u222a{H(B)}\n6: end if\n7: end for\n8: return interlinkSet\n9: end function\nThe updateInterlinkSet algorithm accepts a block B , which already\nhas an interlink data structure defined on it. The function evaluates the",
    "source":"whitepaper",
    "section":"We wish to connect the blocks at each level with a previous block pointer (Part 2)",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"section_part",
    "word_count":208.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_145",
    "content":"# interlink data structure which needs to be included as part of the next\n\nblock. It copies the existing interlink data structure from level level(B )\nand adds the reference H(B ).\n\n--- Page 37 ---",
    "source":"whitepaper",
    "section":"interlink data structure which needs to be included as part of the next",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":22.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_146",
    "content":"# B Mathematical Background\n\nTheorem 7 (Chernoff bounds). Suppose {X : i \u2208 [n]} are mutually\nindependent Boolean random variables, with Pr[X = 1] = p, for all\n\u2211 i\ni \u2208 [n]. Let X = n X and \u00b5 = pn. Then, for any \u03b4 \u2208 (0,1],\ni=1 i\nPr[X \u2264 (1\u2212\u03b4)\u00b5] \u2264 e \u2212\u03b42\u00b5\/2 and Pr[X \u2265 (1+\u03b4)\u00b5] \u2264 e \u2212\u03b42\u00b5\/3.\nLemma 6. For each j \u2208 N, let F and M be Boolean random variables",
    "source":"whitepaper",
    "section":"B Mathematical Background",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":74.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_147",
    "content":"# j j\n\nsuchthatE[M ] = \u03b6 andM isindependentofF fori \u2264 j andindependent",
    "source":"whitepaper",
    "section":"j j",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":10.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_148",
    "content":"# j j i\n\nof M for i \u0338= j. For any \u03f5 \u2208 (0,1),\n[ ]\n\u2211 \u2211 \u2227 \u2211\nPr F M > (1+\u03f5)\u03b6 F F M \u2265 k \u2264 e \u2212\u2126(\u03f52k).",
    "source":"whitepaper",
    "section":"j j i",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":30.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_149",
    "content":"# j j j j j\n\nProof. Since e\n\u2212\u2126(\u03f52n)\n= e\n\u2212\u2126(\u03f52k),\nby the union bound it su\ufb00ices to\nn\u2265k",
    "source":"whitepaper",
    "section":"j j j j j",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":15.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_150",
    "content":"# show that\n\n[ ]\n\u2211 \u2227 \u2211\nPr (1+\u03f5)\u03b6 F < k F M = k \u2264 e \u2212\u2126(\u03f52k). (4)",
    "source":"whitepaper",
    "section":"show that",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":18.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_151",
    "content":"# j j j\n\nIn the summations below, let \u03b1 range over words in\n{0,1}\u2217\nand \u03b2 be any\nwordin{0,1}\u2113 ofweightk.Forafixed\u03b1,defineJ = {j \u2208 N : F = 1}and\n\u03b1 j\nB = (M j ) j\u2208J\u03b1 . Also, for j \u2208 N, let E j denote the event {(\u2200i < j)(F i = \u03b1 i\nand i \u2208 J \u21d2 M = \u03b2 )}. Then,",
    "source":"whitepaper",
    "section":"j j j",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":62.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_152",
    "content":"# i i\n\nPr[B = \u03b2] = Pr[B = \u03b2,A = \u03b1]\n\u2211\u220f \u03b1 \u220f\n= Pr[F = \u03b1 |E ] Pr[B = \u03b2 |E ,F = \u03b1 ]",
    "source":"whitepaper",
    "section":"i i",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":26.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_153",
    "content":"# j j j j j j j j\n\n\u03b1 j j\u2208J\n\u2211\u220f \u220f\n= Pr[F = \u03b1 |E ,B = \u03b2] Pr[M = \u03b2 ]",
    "source":"whitepaper",
    "section":"j j j j j j j j",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":17.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_154",
    "content":"# j j j j j\n\n\u03b1 j j\u2208J\n= Pr[A = \u03b1|B = \u03b2]\u00b7\u03b6k(1\u2212\u03b6)\u2113\u2212k \u2264 \u03b6k(1\u2212\u03b6)\u2113\u2212k.\nThus, letting \u03b2 range over all words in {0,1}\u2217 of length less than k\n(1+\u03f5)\u03b6\nand weight k ending with 1, the left-hand side of (4) is equal to\n( )\n\u2211 \u2211 \u2113\u22121\nPr[B = \u03b2] \u2264 \u03b6k(1\u2212\u03b6)\u2113\u2212k.\nk\u22121\n\u03b2 k\u2264\u2113< k\n(1+\u03f5)\u03b6\nThat is, the probability is at most that of a random variable following\na negative binomial distribution with parameters k (the number of successes) and \u03b6 (the probability of success) is less than k . The bound\n(1+\u03f5)\u03b6\nfollows from standard Chernoff bounds.\n\n--- Page 38 ---",
    "source":"whitepaper",
    "section":"j j j j j",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":102.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_MininginLogarithmicSpace_155",
    "content":"# Acknowledgements\n\nThe authors would like to thank Peter Ga\u017ei for proof reading the construction and pinpointing important errata.",
    "source":"whitepaper",
    "section":"Acknowledgements",
    "url":null,
    "filename":"MininginLogarithmicSpace",
    "chunk_type":"complete_section",
    "word_count":17.0,
    "pdf_pages":38.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/MininginLogarithmicSpace.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_0",
    "content":"# Nakamoto Consensus\n\nFebruary23,2023",
    "source":"whitepaper",
    "section":"Nakamoto Consensus",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":1.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_1",
    "content":"# MichaelSutton YonatanSompolinsky\n\nmsutton@cs.huji.ac.il ysompolinsky@fas.harvard.edu",
    "source":"whitepaper",
    "section":"MichaelSutton YonatanSompolinsky",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":2.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_2",
    "content":"# IndependentResearcher HarvardUniversity (Part 1)\n\nABSTRACT parallel.Theheartoftheconsensusprotocolisitsconflictresolution\nIn2008Satoshiwrotethefirstpermissionlessconsensusprotocol, rule,whichiswrittenintheformofaDAGorderingalgorithm\u2014\nknownasNakamotoConsensus(NC),andimplementedinBitcoin. eachnoderunslocallyaprocedurethattakesasinputtheblock\nAlargebodyofresearchwasdedicatedsincetomodifyandextend DAGvisibletoitandreturnsalinearorderingoveritsblocks,and\nNC,invariousaspects:speed,throughput,energyconsumption, by implication over its transactions. This ordering ensures and\ncomputationmodel,andmore[4].Onelineofworkfocusedon recoversconsistency:Thefirstofanysetofconflictingtransactions\nalleviatingthesecurity-speedtradeoffwhichNCsuffersfromby is accepted, and the rest are ignored and skipped over. As any\ngeneralizingSatoshi\u2019sblockchainintoadirectedacyclicgraphof consensusprotocol,thisproceduremustsatisfythepropertythat\nblocks,ablockDAG.Indeed,theblockcreationrateinBitcoinmust allnodeseventuallyagreeontheordering.\nbesuppressedinordertoensurethattheblockintervalismuch KNIGHTisaparameterlessDAG-basedconsensus\u2014theprotocol\nlongerthantheworstcaselatencyinthenetwork.Incontrast,the assumesnoupperboundonthenetwork\u2019slatency.Inotherwords,\nblockDAGparadigmallowsforarbitrarilyhighblockcreationrate theorderingprocedureofKNIGHTdoesnottakeasinputparameandblocksizes,aslongasthecapacityofnodesandofthenet- tersrepresentingthenetwork\u2019sassumedlatency.Tothebestofour\nworkbackbonearenotexceeded.Still,theseprotocols,aswellas knowledge,KNIGHTisthefirstpermissionlessparameterlessconotherpermissionlessprotocols,assumeanaprioriboundonthe sensusprotocolthatissecureagainstanyattackerwithlessthan\nworstcaselatency,andhardcodeacorrespondingparameterin 50%ofthecomputationalpowerinthenetwork.Theseproperties\ntheprotocol.Confirmationtimesthendependonthisworstcase putKNIGHTataninherentlystrongerspotthanitscounterparts:\nbound,evenwhenthenetworkishealthyandmessagespropagate Itisbothfasterandmoresecure,sinceitmakesfewerassumptions\nveryfast.Inthisworkwesetouttoalleviatethisconstraint,and andoperatesproperlydespitevaryingnetworkconditions.\ncreatethefirstpermissionlessprotocolwhichcontainsnoaprioriin-protocolboundoverlatency.KNIGHTisthusresponsiveto 1.1 KNIGHToptimizationframework\nnetworkconditions,whiletoleratingacorruptionofupto50%of Conceptually, KNIGHT is an evolution of the PHANTOM optithecomputationalpower(hashrate)inthenetwork.Tocircumvent mizationframework[20],whichinturnisanevolutionofNC.In\nanimpossibilityresultbyPassandShi[16],werequirethatthe NC,thelongestchainofblockswithinthetreeisselectedandexclientspecifieslocallyanupperboundoverthemaximumadver- tended.PHANTOMgeneralizesthelongestchainrule:Ratherthan\nsarialrecentlatencyinthenetwork.KNIGHTisanevolutionof selectingthelongestchain,itselectsthelargestsufficientlyconthePHANTOMparadigm[20],whichinturnisaparameterized nectedsubsetofblocks.Thefollowingdefinitionfrom[20]captures\ngeneralizationofNC. \u201cwell-connectedness\u201d:\nDefinition1. GivenaDAG\ud835\udc3a =(C,\ud835\udc38),asubset\ud835\udc46 \u2286 Ciscalleda\n1 INTRODUCTION \ud835\udc58-cluster,if\u2200\ud835\udc35 \u2208\ud835\udc46 :|\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35)\u2229\ud835\udc46| \u2264\ud835\udc58.\nThefirstpermissionlessconsensusprotocol,NakamotoConsensus\nHere,theanticoneofablockisthesetofblockswhoseorder\n(NC),wascreatedin2008byBitcoin\u2019soriginatorSatoshiNakamoto\nwithrespecttoitisnotdictatedbytheDAGtopology;seeFigure2.\n[13].Permissionlessisdefinedasanenvironmentwherethesetof\nFormally,PHANTOMsolvesthefollowingoptimizationproblem:\nparticipantsisnotaprioriknownandfixed.Sinceitsintroduction,\ntheresearchcommunityofferedmanyvariantsthatimproveupon PHANTOM Optimization: Maximum \ud835\udc58-cluster subNCintermsofspeed,throughput,energyconsumption,computa- DAG(\ud835\udc40\ud835\udc36\ud835\udc46 \ud835\udc58)\ntionmodel,andmore[4]. Input:DAG\ud835\udc3a =(C,\ud835\udc38),\ud835\udc58\nOnelineofworkfocusedonalleviatingthespeed-securitytradeOutput:Asubset\ud835\udc46\u2605\u2282Cofmaximumsize,s.t.\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35)\u2229\noff, by generalizing Satoshi\u2019s blockchain into a directed acyclic\n\ud835\udc46\u2605\u2264\ud835\udc58forall\ud835\udc35 \u2208\ud835\udc46\u2605.\ngraphofblocks\u2013ablockDAG[11,19,20].WhereasinNCeach Similarlytootherparameterizedconsensusprotocols,theparamblockreferencesasinglepredecessor,andasinglechainwithin eterkofPHANTOMrepresentsanupperboundonthenetwork\u2019s\ntheresultingtreeisextended,inDAG-basedconstructionsblocks latency(technically,onthenumberofblocksperoneunitofdelay,\nreferencemultiplepredecessors.Blocksarethuscreatedmuchmore withhighprobability).Observethatfor\ud835\udc58 =0,PHANTOMcoincides\nfrequentlythanBitcoin\u2019s10minutesinterval,typicallymultiple withNC,asthelongestchainisthelargest0-cluster.Indeed,when\nblocksperoneunitofnetworkdelay.Thisasynchronousoperation theblockintervalislarge(e.g.,Bitcoin\u2019s10minutesperblock),the\nmodeopensupthepossibilityofconflictsacrossblockscreatedin latencyparameter\ud835\udc58canbesetto0.Incontrast,asystemenjoyinga",
    "source":"whitepaper",
    "section":"IndependentResearcher HarvardUniversity (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":132.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_3",
    "content":"# IndependentResearcher HarvardUniversity (Part 2)\n\n--- Page 2 ---",
    "source":"whitepaper",
    "section":"IndependentResearcher HarvardUniversity (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_4",
    "content":"# MichaelSuttonandYonatanSompolinsky (Part 1)\n\n(a)\ud835\udefc=0.05,\ud835\udc58=2 (b)\ud835\udefc=0.25,\ud835\udc58=4 (c)\ud835\udefc=0.45,\ud835\udc58=7\nFigure1:KNIGHToptimizationillustrated.ThefiguresshowafixedhonestDAGontheleft,alongsideanattackerontheright.\nTheattacker\u2019sbyzantinefractiongrowsfrom\ud835\udefc =0.05in1ato\ud835\udefc =0.45in1c.Thealgorithmfindsa\ud835\udc58-clusterofminimumwidth\n(\ud835\udc58+1)sufficienttocoveratleast50%oftheDAG,therebyoutweighingtheminorityattacker.\nhighblockcreationratewouldrequiresetting\ud835\udc58tobemuchlarger. \ud835\udc40\ud835\udc58\ud835\udc40\ud835\udc36,notmerelyforefficiencybutalsoforsecurityconsiderForinstance,inKaspa,acryptocurrencybasedonPHANTOM,the ations\u2013primarily,naturalormaliciouschangesinthelatency1\nblockintervalwassetto1second,and\ud835\udc58 washardcodedwitha \u2013aswillbedescribedformallyinSection2.SeeFigure1foran\nvalueof18,reflectinganassumptionof\ud835\udc37 \u226410seconds;see[2]for illustrationofKNIGHT\u2019soptimizationdynamics.\nalivevisualizationoftheliveDAGofKaspa.\nIncontrast,KNIGHToffersanalternativeoptimizationframe- 1.2 Parameterlessness\nwork,whichdoesnotpre-assumealatencybound: KNIGHTdiffersfrompreviousworkonproof-of-work-basedconKNIGHT Optimization: Minimal \ud835\udc58 Majority Cluster sensusprotocolswhichtypicallyoperateinthesynchronoussetup\nsub-DAG(\ud835\udc40\ud835\udc58\ud835\udc40\ud835\udc36) andassumeanaprioriupperboundover\ud835\udc37,eitherexplicitlyor\nInput:DAG\ud835\udc3a =(C,\ud835\udc38) implicitly.Forinstance,Bitcoin\u2019sdifficultyadjustmentalgorithm\nOutput: A subset \ud835\udc46\u2605 = \ud835\udc40\ud835\udc36\ud835\udc46 \ud835\udc58 (\ud835\udc3a), s.t. \ud835\udc58 is minimal and istargetingablockcreationrateof\ud835\udf06 =1\/600blockspersecond,\n|\ud835\udc46\u2605| \u2265 |\ud835\udc36|. whichreflectsanunderlyingassumptionthat\ud835\udc37 \u226a 600seconds.\n2 Similarly,wheninstantiatingthePHANTOMprotocol,onemust\npre-configuretheprotocol\u2019s\ud835\udc58parameterwhichrepresentstheexpectednumberofblockscreatedinoneunitofdelay,reflectingan\nassumptionthat\ud835\udc37 \u226a \ud835\udc58+1.\nParameterlessnesshastwoimplications.First,confirmationtimes\ninparameterizedprotocolsaretypicallylimitedbytheirparameter\u2014\ntheyareafunctionofthehardcodedparameter,regardlessofthe\nnetwork\u2019sactuallatency.Thus,evenwhentheactuallatencyof",
    "source":"whitepaper",
    "section":"MichaelSuttonandYonatanSompolinsky (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":65.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_5",
    "content":"# B B B (Part 1)\n\nblocksinBitcoinis1or2seconds(asisthesituationformostof\nthetime,see[1]),theprotocol\u2019sconvergencetimesisintheorder\ng g g oftensofminutes.Similarly,Kaspa\u2019sconvergencetimeremainsin\ntheorderoftensofsecondsevenwhenitslatencyiswaybelow10\nseconds.\nFigure2:Thetopologyofablock-DAGinducesapartialorAsaparameterlessprotocol,KNIGHTavoidsthisshortcoming\nderingoverblocks.Thefigureontheleftmarksblocksprovably created after block \ud835\udc35, which are called its future set. andallowsthenetworktoconvergeaccordingtoitsactualcondiSimilarly, the figure on the middle marks blocks provably\ntions.Thus,whenthenetwork\u2019sadversariallatencyisverylow,the\ncreated before\ud835\udc35, its past set. The right-most figure marks orderingofKNIGHTwillconvergeimmediately,allowingclients\nblockswhoseorderingwithrespectto\ud835\udc35 isambiguousand toconfirmtransactionswithinafewInternetRTTs(RoundTrip\nTimes);andwhenthenetworkisslowandclogged,theordering\nmustbedictatedandagreedbytheconsensusprotocol.\nwilltakelongertoconvergeandtransactionslongertoconfirm.\nCrucially,weemphasizethatthisresponsivenessiswithrespectto\nThatis,ratherthanselectingthelargest\ud835\udc58-clusterforonepredetheworst-caseadversariallatency;inSubsection1.4wedistillthis\nterminedvalueof\ud835\udc58,weselectthelargest\ud835\udc58-clusterforeachvalue\nnuance.\nof\ud835\udc58,andpicktheminimal\ud835\udc58whosemaximizingclustercovers50%\nFigures3and4demonstratethiseffect.Intheformer,aDAGof\noftheDAG.Wethusutilizethehonestmajorityassumptionto\nvarious\u201cwidths\u201dispresented,correspondingtodifferentnetwork\nrecognizeasubsetofblocksthataresufficienttocounteranattack.\nlatencies.Whenthenetworkisspeedy,minersareawareofalmost\nInthisway,weavoidtheneedtoknow\ud835\udc58inadvance,andallowthe\nprotocoltoself-adjusttotherealtimelatency.TheactualKNIGHT\n1Whenthedelayisroughlyconstant,KNIGHTcoincideswithPHANTOM,andin\nprotocolcontainsmorecomponentsthantheoptimizationproblem particularwhenthedelayisnegligible,itcoincideswithNC.",
    "source":"whitepaper",
    "section":"B B B (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":61.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_6",
    "content":"# B B B (Part 2)\n\n--- Page 3 ---\nTheDAGKNIGHTProtocol:AParameterlessGeneralizationofNakamotoConsensus\n1.2\n0 0 0\n(a)\ud835\udc37=2,\ud835\udc58=4,conf.time=12 (b)\ud835\udc37=1,\ud835\udc58=1,conf.time=6 (c)\ud835\udc37=0.1,\ud835\udc58=0,conf.time=1.2",
    "source":"whitepaper",
    "section":"B B B (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":12.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_7",
    "content":"# time (Part 1)\n\n(seconds)\nFigure3:ConfirmationtimesofKNIGHTundervariousnetworkconditions.Asthelatencydecreasesfrom2secondsperblock\nmessagein(3a)to0.1secondsin(3c),\ud835\udc58decreasesfrom4to0,andconfirmationtimesimprovefrom12to1.2seconds.Observe\nthatthealgorithmcorrectlyrecognizesaclusterofminimalwidth(=\ud835\udc58+1)whichstillcoversatleast50%ofthecorresponding\nDAGs(\ud835\udc58 =4,1,0in3a,3b,3c,respectively)asrequiredbyKNIGHT\u2019soptimizationframework.ThedepictedDAGsarearesult\nofasimulationofanetworkmining\ud835\udf06 = 3.75blockspersecondandan(invisible,secret)attackerwith\ud835\udefc = 0.2;therequired\nconfidenceparameterwassetto\ud835\udf16 =0.05.\nallblockscreatedbytheirpeers,blocksenjoysmallanticones(or\n\u201cgaps\u201d)ofsize1atmost,andtransactionscanbeconfirmedquickly.\nOntheotherextreme,manyblocksarecreatedinparallel,blocks\nsufferfromlargeranticones,andtransactionstakelongertoconfirm.Thisscenariorepresentseitheraslowdowninthenetwork,\norasystemintentionallyparameterizedwithahighblockrate,\ne.g.,\ud835\udf06=10blockspersecond.Figure4furthercomparestheeffect\nofvaryingnetworkconditionsonparameterizedprotocols(e.g.,\nNC,PHANTOM)andparameterlessones(e.g.,KNIGHT).Theconfirmationtimesintheformerprotocolsareconstant,accounting\ntothehardcodedlatency-dependentparameter;worseyet,when\nthenetworksuffersananomaly,andmessagedelaysviolatethe\nbound,transactionscannotbeconfirmedaltogether.Incontrast,",
    "source":"whitepaper",
    "section":"time (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":24.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_8",
    "content":"# theconfirmationtimesofparameterlessprotocolscorrespondto\n\nthe(boundoftheclientoverthemaximum)currentlatencyinthe\nNetwork latency (sec)\n)ces(",
    "source":"whitepaper",
    "section":"theconfirmationtimesofparameterlessprotocolscorrespondto",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":5.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_9",
    "content":"# emit\n\n",
    "source":"whitepaper",
    "section":"emit",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_10",
    "content":"# noitamrifnoC\n\nnetwork,and,inparticular,thenetworkremainsfullyoperational,\nyetslow,duringperiodsofnetworkanomaly.\nAsecondimplicationofparameterlessnessisaddedsecurity:",
    "source":"whitepaper",
    "section":"noitamrifnoC",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":3.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_11",
    "content":"# KNIGHTenjoysastrongersecuritythanexistingpermissionless\n\nprotocols,asnetworkhiccupsdonotinterruptconsensus,because\ntheydonotviolateassumptionsnecessaryforitsproperoperation.\n\n## 1.3 PartialSynchrony\n\nTraditionally,aconsensusprotocolissaidtobepartiallysynchronousifanupperboundonthenetworklatencyexistsbutisunknowntotheprotocol[6].However,proof-of-workconsensusintroducessomeambiguityintothisclassification,asitdecouples\nthetransactionordering protocolfromthefinalityprotocol:The\ncoreofconsensusisthetransactionorderingrule(e.g.,Bitcoin\u2019s\nlongestchainrule,KNIGHT\u2019sDAGordering).Thisisthecanonical\nalgorithmwhichdefinesthesystem,andwhichallparticipantsrun\ninthesameway,includingadversarialnodes\u2014individualinterpretationsoftheledgerwhichdifferfromthecanonicalprocedureare\nResponsive Not responsive pointless.Incontrast,transactionfinality(e.g.,theconfirmation\ncountinBitcoin)isanon-bindingprocedurewhicheachclientor",
    "source":"whitepaper",
    "section":"KNIGHTenjoysastrongersecuritythanexistingpermissionless",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":17.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_12",
    "content":"# userconfiguresandcalculateslocallyaccordingtotheirownbeliefs\n\nandneeds,andbearstheconsequence.E.g.,aBitcoinuserwhobelievesthatmaliciousminerspossesscurrentlylessthan33%ofthe",
    "source":"whitepaper",
    "section":"userconfiguresandcalculateslocallyaccordingtotheirownbeliefs",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":1.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_13",
    "content":"# hashratewillconfirmtransactionsfasterthanonewhobelievesthe\n\nboundtobe49%,anda34%attackerwillharmtheformerbutnot\nthelatter.AnotherexampleisSPECTRE,whereintheuserneedsto",
    "source":"whitepaper",
    "section":"hashratewillconfirmtransactionsfasterthanonewhobelievesthe",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":2.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_14",
    "content":"# additionallyspecifyherbeliefonthelatencyboundviaaparameter (Part 1)\n\nFigure4:Aqualitativecomparisonoftheconfirmationtime whichisconfiguredindividually,andwhichisinconsequential\u2013\nbehaviour of parameterized protocols and parameterless and,infact,not-communicated\u2013totherestofthenetwork.\nones. Confirmation times in the latter case are fast when Fortheseconsiderations,webelievethataconsensussystem\nthe network is smooth and speedy, whereas in the former whosetransaction-orderingruleisagnostictolatencyshouldbe\nconfirmationtimeisstilllimitedbytheconstanthardcoded referredtoaspartiallysynchronousandparameterless,interchangeworst-case bound. Additionally, when the bound of a pa- ably,eveniftransaction-finalitydependsonalatencybound(conrameterized protocol is violated, transactions may not be figuredbytheuserlocally).Weleavethequestiononterminology\nconfirmedsafely,whereasparameterlessprotocolsadaptto fortheDistributedSystemsacademiccommunitytodecideon,and\ntheanomalyandallowconfirmingtransactionsmoreslowly inthispaperusetheterm\u201cparameterless\u201dtodescribeKNIGHT\u2019s\nthanusual,yetsafely. operationmode.",
    "source":"whitepaper",
    "section":"additionallyspecifyherbeliefonthelatencyboundviaaparameter (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":56.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_15",
    "content":"# additionallyspecifyherbeliefonthelatencyboundviaaparameter (Part 2)\n\n--- Page 4 ---",
    "source":"whitepaper",
    "section":"additionallyspecifyherbeliefonthelatencyboundviaaparameter (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_16",
    "content":"# MichaelSuttonandYonatanSompolinsky\n\n1.4 Responsiveness nodes\u2019communicationbydelayingmessagesbetweenthemforup\nInthelackofanapriorilatencyassumption,confirmationtimesin to\ud835\udc37 seconds;however,the\ud835\udc37 isnotknowntotheprotocol.Conaparameterlessconsensussystemcorrespondtotherealnetwork versely,theattackerisalsocapableofspeedingupcommunication\nlatency.However,\u201creallatency\u201dhastwoprofoundlydifferentinter- betweenhonestnodesdowntono-latency;suchmanipulationsare\npretations:theobservablelatencyinthenetwork,andtheworst specificallyrelevanttoandchallenginginthecontextofKNIGHT.\ncaselatencythatanattackermaycause.Indeed,acapableattacker\n1.5.2 Confirmationtimes(asymptotic). Theparameterlessessof\nmayallow\u2013orevenassist\u2013thenetworktooperatesmoothly,setheprotocolistightlyrelatedtoitsspeedofconfirmation:Transaclectively,anddisruptitduringalaterstageoftheattack.Aprotocol",
    "source":"whitepaper",
    "section":"MichaelSuttonandYonatanSompolinsky",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":17.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_17",
    "content":"# tionconfirmationtimesareafunctionoftheactuallatencyinthe\n\n",
    "source":"whitepaper",
    "section":"tionconfirmationtimesareafunctionoftheactuallatencyinthe",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_18",
    "content":"# thathasthestrongpropertyofconfirmingtransactionsaccording\n\nnetwork(Subsection1.3containsanimportantreservationofthis\ntotheobservablelatencyiscalledresponsive[16].\nstatementinourcontext).\nDespitebeingparameterless,KNIGHTisnotresponsiveinthis\nConfirmationtimesarecommonlydiscussedintwomodes\u2013\nsenseofperformingtightlywiththecurrentobservablelatency,\noptimisticperformanceandpessimisticperformance.Theformer",
    "source":"whitepaper",
    "section":"thathasthestrongpropertyofconfirmingtransactionsaccording",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":7.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_19",
    "content":"# ratherisresponsiveintheweakersenseofperformingtightlywith (Part 1)\n\naccountstothescenariowhereallparticipatingnodesbehavepropthecurrentmaximumlatencycausablebyanadversary.Indeed,in\nerly, and there is no visible attack. In this optimistic scenario,\nK ob N s I e G rv H a T b , le it l i a s te n n o c t y e , n r o a u th g e h r f t o h r e t b h o e u c n li d en s t h t o o u s ld et r a efl lo e c c a t l th bo e u m n a d x o im n u th m e KNIGHT confirms transactions in O (cid:16)(cid:16)ln( \ud835\udf06 1\/\ud835\udf16) +\ud835\udc37 (cid:17) \/(1\u22122\ud835\udefc) +\nlatencythatmaybecausedbytheattacker.Thatis,evenifmessages \ud835\udc372\ud835\udf06(cid:1)seconds,where\ud835\udf06istheblockcreationrateinunitsofblocks\/sec\ncurrentlypropagatefullywithin1or2seconds,ifanattackermay (adjustedviaa\u201cdifficultyadjustment\u201dalgorithmadaptedfromBitdisruptthenetworkandcausemessagestotakeupto30seconds coin[13]),\ud835\udc37isanupperboundontherecentdelayinthenetwork,\ntogothrough,\ud835\udc37shouldbesetbytheclientto30seconds. 0 \u2264 \ud835\udefc < 1\/2istheattacker\u2019ssize,and0 \u2264 \ud835\udf16 < 1istherequired\nThis limitation of KNIGHT is unavoidable, since no parame- confidence.Asinanyproof-of-workprotocol,theparameters\ud835\udefcand\nterless protocol with 50% byzantine tolerance threshold can be \ud835\udf16aresetbytheclient.UniquelytoKNIGHT(andtoSPECTRE[19]),\nresponsive[16]: theparameter\ud835\udc37 tooissetbytheclient\u2014anunderestimationby\nTheorem14(Responsiveprotocolscannottolerate1\/3corruption) theclientwillleadtoherprematureacceptanceoftransactions,\n[PassandShi].Nosecurepermissionlessconsensusprotocolthatis whereasanoverestimationwillcausehertowaitmoretimethan\nalsoresponsivecantolerate1\/3ormorecorruption. necessarybeforeconfirming.\nInthepessimisticscenario,avisiblemanipulationoftheDAG\n1.5 Consensusprotocols,principalcategories isongoing,andconfirmationtimesaresignificantlysloweddown.",
    "source":"whitepaper",
    "section":"ratherisresponsiveintheweakersenseofperformingtightlywith (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":163.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_20",
    "content":"# Analyzingtheconvergencetimeinthiscaseinatightmanneris\n\nConsensusprotocolsaregenerallyclassifiedandcomparedaccordintractable,andwearethusleftwithanexponentialboundonconingtothefollowingaspects:\nfirmation times: O\n(cid:16)1\n(exp(\ud835\udc50\u00b7\ud835\udc37\ud835\udf06\/(1\u22122\ud835\udefc))+ln(1\/\ud835\udf16)\/(1\u22122\ud835\udefc))\n(cid:17)\n\u2022 Whataretheassumptionsmadebytheprotocolontheun- \ud835\udf06\nseconds.Weemphasize,however,thatthisboundisfarfromtight,\nderlyingnetworkandbehaviourofnodes.Thestrongerthe\nassumesanunrealisticallystrongattacker,andfurthermorepayassumptionstheweakertheprotocol.",
    "source":"whitepaper",
    "section":"Analyzingtheconvergencetimeinthiscaseinatightmanneris",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":13.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_21",
    "content":"# mentsofhonestuserscanstillbeconfirmedinquadratictimeas (Part 1)\n\n\u2022 Whenitsassumptionsarepreserved,howdoesitperform,\nintheoptimisticcase.Indeed,aslongastheuserdidnotpublisha\nspecifically,howfastisconsensusreached.\n\u2022 Whenitsassumptionsareviolated,doestheprotocolrecover,\nvisibleconflict(akadoublespend),hertransactioniscommutative\nwithotherrecenttransactionsintheDAG,hencethereceiving\nandhowfastitrecovers.Aprotocolguaranteedtorecover\nclientmayconfirmitdespitetheorderingstillconverging.\nfrompastfailuresiscalledself-stabilizing[5].\n\u2022 Iftheunderlyingsystemisusedtosettlealivequeueoftrans- 1.5.3 Selfstabilization. SimilarlytoNCandotherproof-of-work\nactions,wealsoask:Howmanytransactionscantheprotocol\nconsensusprotocols,KNIGHTisself-stabilizing:Ifthe50%threshserve,i.e.,whatconstraintonthetransactionthroughput\noldwasviolatedatsomepointinthepast,KNIGHTrecoversand\ntheprotocolimposesoritsassumptionsrequire.\ntransactionsmaybeconfirmedsafelyoncetheconditionsaremet;\nThroughthesecategorieswenowsurvey,withsomebrevity, therecoverytimeislinearinthelengthoftheviolationphase.SimKNIGHT\u2019smainproperties: ilarly,thelatencyparameter\ud835\udc37whichissetbyeachclientlocally\nshouldcorrespondtotherecentdelayinthenetwork,andneednot\n1.5.1 Modelassumptions. KNIGHT\u2019sfaultmodelisthebyzantine accountfortheworstcasehistoricallatency.Contrastthesepropsetup,whichallowstheattackertodeviatearbitrarilyfromtheproertiestoproof-of-stakeprotocols,whichrelyheavilyonfinality,\ntocol\u2019srules.Wefollowtheproof-of-workmodelwhichassumesa\nandwhichfailthereforetorecoverfromhistoricalcatastrophes.\ncomputationallyboundedattackerwhichpossesseslessthan50%\nofthecomputationalpowerinthenetwork.Thisassumptioniscon- 1.5.4 Throughput. IncontrasttoNC,andsimilartootherDAGsideredtobeweaker(hencemoresecure)comparedtotraditional basedconsensusprotocols,KNIGHTremainssecureunderarbitrarpermissionedsetupswhichrequireaprioriknowledgeofparticipat- ilyhighthroughputconfigurations\u2014theblockrate,andtheblock\ningnodes,andcomparedtoproof-of-stakewhichtypicallyrequires size,shouldbeconstrainedonlyaccordingtothecapacityofnodes\u2019\nafixedandidentifiablesetofnodesatthebeginningofeachepoch. hardwareandthatofthenetwork\u2019sbackbone.\nTheattackerisnotassumedtosufferanycommunicationdelays Allinall,inthisworkweproposeanovelproof-of-workbased\ninitsincomingoroutgoinglinks,andmayfurtherdisrupthonest parameterlessconsensusprotocol.Asfarasweareaware,KNIGHT",
    "source":"whitepaper",
    "section":"mentsofhonestuserscanstillbeconfirmedinquadratictimeas (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":46.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_22",
    "content":"# mentsofhonestuserscanstillbeconfirmedinquadratictimeas (Part 2)\n\n--- Page 5 ---\nTheDAGKNIGHTProtocol:AParameterlessGeneralizationofNakamotoConsensus\nisthefirstproof-of-workprotocoltosolveconsensusunderthe\nparameterless model; the only other protocol to operate under Honest virtual Attacker Honest virtual Attacker\nthismodelisSPECTRE,whichsolvesaweakerversionoftheconsensusproblem(\u201cweakliveness\u201d),andwhichsupportstherefore",
    "source":"whitepaper",
    "section":"mentsofhonestuserscanstillbeconfirmedinquadratictimeas (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":22.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_23",
    "content":"# onlytheusecaseofpaymentswheretransactionsofhonestusers\n\nare commutative [19]. KNIGHT is a parameterless evolution of\nPHANTOM\u2014savesomenuances,thetwocoincidewhenthedelayisconstant;whenthedelayisnegligiblerelativetotheblock",
    "source":"whitepaper",
    "section":"onlytheusecaseofpaymentswheretransactionsofhonestusers",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":10.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_24",
    "content":"# B B (Part 1)\n\ncreationrate,thetwoprotocolsfurthercoincidewithNC.\n\n## 1.6 Structureofthispaper",
    "source":"whitepaper",
    "section":"B B (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_25",
    "content":"# B B (Part 2)\n\nThe remainder of this paper is organized as follows. Section 2\ncontainsthefulldescriptionoftheKNIGHTprotocol.Section3\nformalizesthemodelandthestatementofKNIGHT\u2019sproperties.\nSection4discussesconfirmationprocedureforclients,andconfirmationtimes.InSection5wepresentimplementationdetails.We\nconcludewithsurveyingrelatedworkinSection6.\n(a) (b)\nFigure5:5ashowsasuccessfulfreeloadingschemeagainst\n2 THEDAGKNIGHTPROTOCOL PHANTOMwith\ud835\udc58 = 5.Thelargest5-clustercontains(also)\n2.1 Preliminaries attackerblockswhichwerewithheldtillnow,andexcludes\nThe following terminology is used extensively throughout this honest blocks which were mined correctly above \ud835\udc35 and\npaper.Wefollowterminologyestablishedbypreviousworkscon- publishedimmediately.5bdemonstratesthefailureofthis\ncerningDAGprotocols[19,20]. schemeagainstKNIGHT.Theprotocolrecognizesthatthe\nInablockDAG\ud835\udc3a =(C,\ud835\udc38),Crepresentsblocksand\ud835\udc38represents\nlargest\ud835\udc58-cluster,for\ud835\udc58 =0,sufficestocoveramajorityofthe\nhashreferencestopreviousblocks\u2014edgesthuspointbackwardsin DAG,selectsthis0-cluster,andexcludestheattackblocks.\ntime.\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35,\ud835\udc3a)denotesthesetofblocksreachablefrom\ud835\udc35,and\n\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35,\ud835\udc3a) thesetofblocksfromwhich\ud835\udc35 isreachable;these\nblockswereprovablycreatedbeforeandafter\ud835\udc35,correspondingly. 2.3 KNIGHToptimizationparadigm\n\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35,\ud835\udc3a) denotesthesetofblocksoutside\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35,\ud835\udc3a) and KNIGHTaddsanotherlayertotheoptimizationproblem(aspre\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35,\ud835\udc3a);thetime-relationbetween\ud835\udc35 andblocksinitsan- sentedinSection1).Ratherthanassuming\ud835\udc58 asaninputtothe\nticonecannotbederivedexplicitlyfromtheDAGtopology.See problem,KNIGHTsearchesfortheminimal\ud835\udc58suchthatthelargest\nFigure2.Whencontextisclear,wewrite\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35)insteadof \ud835\udc58-clustercoversatleast50%oftheDAG.\n\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35,\ud835\udc3a).Wedenoteby\ud835\udc61\ud835\udc56\ud835\udc5d\ud835\udc60(\ud835\udc3a) thesetofblockswithin- Thisdualminmaxoptimization(min\ud835\udc58,max\ud835\udc58-cluster)allows\ndegree0,thatis,whicharenotreferencedbyanyotherblockinthe ustotoleratejustenoughlatencyanddisconnectivityamongthe\nDAG.Thesystemisinitializedwithsomeknownblock\ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc52\ud835\udc60\ud835\udc56\ud835\udc60;ifa selectedsetofblocks:Intuitively,selectingtheclusterofasmaller\ud835\udc58\nsub-DAG\ud835\udc3a\u2032 \u2286\ud835\udc3a hasonlyoneblockwithout-degree0,wedenote wouldcompromisesafety,exposingtheorderingtomanipulations\nitby\ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc52\ud835\udc60\ud835\udc56\ud835\udc60(\ud835\udc3a\u2032). byaminorityattackerwhoseblocksdonotcover50%ofthegraph;\nForconvenience,weadditionallyregardthevirtualblockofthe selectingtheclusterofalarger\ud835\udc58wouldcompromiseliveness,asit\nDAG,\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59(\ud835\udc3a),whichisahypothetical(un-mined)blockwhich wouldallowadversaryblockstoinjectthemselvesintotheorder\npointstotheDAG\u2019stipsasitsparents.Thus,\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59(\ud835\udc3a))=\ud835\udc3a. evenafterhonestblockshavesettled.\nEssentially,\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59(\ud835\udc3a)representtheblocktemplateforthenext Buildingonthisparameterlessoptimizationparadigm,weare\nblocktobecreatedbytheminer,ifitishonest. abletodeviseasecureconsensusDAGorderingrulethatisresponsive to the network\u2019s actual adversarial latency and is not",
    "source":"whitepaper",
    "section":"B B (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":103.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_26",
    "content":"# constrainedtoapriorihardcodedboundsontheadversariallatency (Part 1)\n\n2.2 PHANTOMoptimizationparadigm whichrequirelargesafetymarginsandperformsuboptimally.We\nThePHANTOMprotocol[20]proposedanoptimizationproblem reiterate,however,thatKNIGHTisnotresponsiveinthestrong\nasageneralizationofNC(seeboxinSection1).Theoptimization senseofperformingaccordingtothenetwork\u2019sobservablelatency,\ntargetsthelargest\ud835\udc58-cluster,forapredeterminedfixedparameter ratheraccordingtothemaximumlatencythatanadversarymay\n\ud835\udc58whichisafunctionoftheworstcaselatencyinthenetwork.In causeinthecurrentnetwork;still,undernormalInternetcondia\ud835\udc58-cluster,eachblockisconnectedviatheDAGtopologytoall tions,andwithsufficientredundancybetweenpeers,thisshould\nbutatmost\ud835\udc58blocks.Sincehonestnodespossessamajorityofthe beintheorderofafewsecondsatmost.Infact,noprotocolthat\nhashrate,andsinceblockscreatedbyhonestnodesreferenceone issecureagainstcorruptionofupto50%ofthenodescanachieve\nanother,thelargest\ud835\udc58-clustercontainsrecenthonestblockswith responsivenessinthisstrongsense,aswasprovenbyPassand\nhighprobability,whichsufficestosecuretheordering. Shi[16].",
    "source":"whitepaper",
    "section":"constrainedtoapriorihardcodedboundsontheadversariallatency (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":20.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_27",
    "content":"# constrainedtoapriorihardcodedboundsontheadversariallatency (Part 2)\n\n--- Page 6 ---",
    "source":"whitepaper",
    "section":"constrainedtoapriorihardcodedboundsontheadversariallatency (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":4.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_28",
    "content":"# MichaelSuttonandYonatanSompolinsky (Part 1)\n\nFigure5providesavisualinsightintothedifferentbehaviour \u2022 Computetheorderingsofeachtiponitspast,anditsselected\nofPHANTOMvsKNIGHT\u2019soptimizationparadigms.Itillustrates parent,recursively.(Alg.2)\na\u223c35%attackerattemptinga\u201cfreeloading\u201dmanipulationonthe \u2022 Recognizeiterativelythenextconflictpointbetweenthe\nrespectiveprotocols.ConsiderthecasewherePHANTOMwaspa- remainingtipsP,namely,theirlatestcommonchainancesrameterizedwith\ud835\udc58 =5,say,andwherethehonestnetworkenjoys tor\ud835\udc54.Theinducedhierarchyimpliesthatdisagreements,or\naperiodofextremeconnectivityinthenetworksuchthatitsblocks chain-splits,aredealtwithfromearlytorecent.(Alg.2)\nformachain(a0-cluster,inPHANTOMterminology).Inafreeload- \u2022 Foreachconflictpoint\ud835\udc54,decidebetweencompetingsetsof\ningscheme,theattackerbuildsherblockswithacertainartificial tips\ud835\udc43 \u2019s(whichagreewithoneanotheronthisconflict)by\ngapfromtherestofthenetwork,5inourexample.PHANTOM computingeachset\u2019srank(seebelow),removingthelosers\nthenconsiderstheseblocksaspartofthelargest5-cluster,andthey fromthesetoftips;ifneeded,runatie-breakingprocedure\nwillprecedethesecondhalfofthehonestchaininthefinalordering. (Alg.4).\nKNIGHT,incontrast,isnoteasilymisled\u2014itwillrecognizethat Thiseliminationprocessterminateswhenasingletipre\ud835\udc58 = 0sufficestocoverthemajorityoftheDAG.Thesameintu- mains(|P|=1)followingtheresolutionofthemostrecent\nitionappliesgenerallytoanyscenariowherethenetwork\u2019scurrent conflict point, which is then returned as\ud835\udc3a\u2019s selected tip.\n(adversarial)latencyissmallerthantheworstcase(adversarial) (Alg.2)\nlatency.Moreover,ifthenetworksuffersexcessivedelaysdueto \u2022 Thewinningsetisthatforwhichatleastonerepresentative3\nsomeanomaly,andPHANTOM\u2019slatencyboundisviolated,trans- achievesthelowestrankamongallrepresentativesofallsets.\nactionsmaynotbeconfirmed.KNIGHT\u2019soperation,incontrast, (Alg.3)\nwillremainintact,albeitinevitablyslower. \u2022 Therankofablock,peragivenconflictcontext,istheminimal\ud835\udc58forwhichthe\ud835\udc58-clusterreturnedbythealgorithmhas\n2.4 Vanillaversion asubsetwhichuniformlycovers atleast50%oftheDAG.\nTurningKNIGHT\u2019soptimizationparadigmintoaDAGordering (Alg.3)\nruleseemsstraightforward: \u2022 The\ud835\udc58-clusterreturnedbythealgorithmiscomputedrecursively,similarlytotheGHOSTDAGcluster-selection(aka\ncolouring)procedure.Asubtlecondition,representedbythe\nAlgorithm1Na\u00efveorderingalgorithm\nbooleanflag \ud835\udc53\ud835\udc5f\ud835\udc52\ud835\udc52_\ud835\udc60\ud835\udc52\ud835\udc4e\ud835\udc5f\ud835\udc50\u210e,furtherdictateswhetherthereInput: \ud835\udc3a \u2013theDAGtoorder cursioniscalledforallparentsoftheblockoronlyforthose\nOutput: Orderingof\ud835\udc3a whichagreewithit(onthisconflict).4(Alg.5)\n1: functionOrder-DAG(\ud835\udc3a) \u2022 Asetofblocks\u2013asubsetofthereturnedcluster\u2013uniformly\n2: for\ud835\udc58 =0,1...\u221edo covers50%ofGifforeachblockintheset,atleast50%of\n3: \ud835\udc46 \u2190\ud835\udc40\ud835\udc36\ud835\udc46 \ud835\udc58 itsfuturebelongstotheset(minusatmost\ud835\udc54(\ud835\udc58) \u2208 \ud835\udc5c(\ud835\udc58)).\n4: if |\ud835\udc46| \u2265 |\ud835\udc36 2 | then Checkingfortheexistenceofasubsetwhichsatisfiesthis\n5: Order\ud835\udc3aaccordingtosome(deterministic)topologi- propertycanbedoneefficiently,bytraversingtheDAGtopocalsortthatgivesprecedenceto\ud835\udc46 logicallyfromtipstogenesis,computingeachblock\u2019s\u201cvote\u201d\n6: returntheorderedDAG between-1and1(minus1representsablockthateitherdoes\nnotbelongtotheoriginalcluster,orviolatesthecoverage\ncondition),andreturninggenesis\u2019vote.5(Alg.6)\nHowever,Algorithm1issecureonlyinsetupswithconstant\nlatencyandana\u00efveattacker.2 Wewillnowdescribethefullver- 2.5.2 Formalspecification. WeproceedtopresentthemainprocesionofKNIGHT,whichissecureagainstbothspontaneousand dureofKNIGHT,Algorithm2,anditssubprocedures(Algorithms3maliciouschangesinnetworklatency. 6).Webeginwithsomeformaldefinitionsthatthealgorithmsmake\nuseof.",
    "source":"whitepaper",
    "section":"MichaelSuttonandYonatanSompolinsky (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":114.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_29",
    "content":"# MichaelSuttonandYonatanSompolinsky (Part 2)\n\n## 2.5 Formalspecification\n\nDefinition2. Forablock\ud835\udc35,chain-parent(\ud835\udc35)isauniqueparentof\nWearenowreadytopresenttheholygrailofthiswork,theDAG\ud835\udc35,setbyKNIGHT\u2019schain-selectionrule(line5inAlgorithm2).The\nKNIGHTprotocol,asspecifiedformallyinAlgorithm2.Faithfulto\nchainof\ud835\udc35isdefinedrecursivelyby\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc35):=(chain-parent(\ud835\udc35),\nitsoptimizationparadigm,thecomplexofKNIGHT\u2019sprocedures\nchain-parent(chain-parent(\ud835\udc35)),...,\ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc52\ud835\udc60\ud835\udc56\ud835\udc60).\n(Algorithms2-6)isdesignedtorecognizetheminimal\ud835\udc58forwhich\nthereexistsa\ud835\udc58-clusterthatcoversamajorityoftheDAG.Yet,the Observethat\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35)fullydetermineschain-parent(\ud835\udc35).",
    "source":"whitepaper",
    "section":"MichaelSuttonandYonatanSompolinsky (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":13.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_30",
    "content":"# choiceofclusterentailsmorethanmerelyfindingalargeenough (Part 1)\n\ncluster,andproducesaratherinvolvedalgorithm;thesecomplexi- Definition3. Asetofblocks\ud835\udc4b \u2282\ud835\udc3aissaidtoagreein\ud835\udc3aiftheirlatest\ntieswillbeexplainedandjustifiedinSubsection2.6.Butfirstletus commonchainancestorisachain-descendantof\ud835\udc54 = \ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc52\ud835\udc60\ud835\udc56\ud835\udc60(\ud835\udc3a):\nprovideabird\u2019s-eyeviewofthealgorithm.\n\u2203\ud835\udc54\u2032:\ud835\udc54\u2208\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc54\u2032)\u2227\u2200\ud835\udc35 \u2208\ud835\udc4b :\ud835\udc54\u2032\u2208\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc35).\n2.5.1 Overview. ThealgorithmreceivesasinputablockDAG\ud835\udc3a, 3Arepresentativeisanyblockintheinclusivepastofthesetoftipswhichdoesnot\nandoutputsaselectedtipof\ud835\udc3a andanorderingoveritsblocks, belongtotheinclusivepastoftheothersets.\n4Inshort,ablockmayinherittheclusterfromadisagreeingparentthereofonlyifthe\nfollowingthesesteps:\nlatter\u2019srankissmallerthanformer\u2019srank,orifsuchaconditionwasmetinaprevious\nrecursioncall.\n2Additionally,line3involvessolvinganNP-hardproblem[20]. 5ThisprocedureborrowsfromthecascadevotingofSPECTRE.",
    "source":"whitepaper",
    "section":"choiceofclusterentailsmorethanmerelyfindingalargeenough (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":25.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_31",
    "content":"# choiceofclusterentailsmorethanmerelyfindingalargeenough (Part 2)\n\n--- Page 7 ---\nTheDAGKNIGHTProtocol:AParameterlessGeneralizationofNakamotoConsensus\nIntuitively,twoblocksagreein\ud835\udc3a iftheyagreeon\ud835\udc54\u2019ssuccessor Algorithm3Rankcalculationprocedure\ninthechain. Input: \ud835\udc3a \u2013ablockDAG,P \u2013asetofblocksin\ud835\udc3a (typicallyP \u2282\nDefinition4. Foraset\ud835\udc4b \u2282\ud835\udc61\ud835\udc56\ud835\udc5d\ud835\udc60(\ud835\udc3a)agreeingin\ud835\udc3a,theset\ud835\udc5f\ud835\udc52\ud835\udc5d\ud835\udc60 \ud835\udc3a (\ud835\udc4b) \ud835\udc61\ud835\udc56\ud835\udc5d\ud835\udc60(\ud835\udc3a))\n(representatives)isdefinedby Output: TherankofPin\ud835\udc3a\n(cid:8)\ud835\udc65 \u2208\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61 (\ud835\udc4b)\\\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc61\ud835\udc56\ud835\udc5d\ud835\udc60(\ud835\udc3a)\\\ud835\udc4b):\ud835\udc65 agreeswith\ud835\udc4b(cid:9).6 1: functionCalculate-Rank(P,\ud835\udc3a)\n2: for\ud835\udc58 =0,1...\u221edo\nDefinition 5. For a block \ud835\udc35 and chain-ancestor \ud835\udc54 \u2208 \ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc35) 3: for\ud835\udc5f \u2208\ud835\udc5f\ud835\udc52\ud835\udc5d\ud835\udc60 \ud835\udc3a (P)do\ns.t. \u2203\ud835\udc5d1,\ud835\udc5d2 \u2208 \ud835\udc5d\ud835\udc4e\ud835\udc5f\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc60(\ud835\udc35) which do not agree over \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc54), 4: C\ud835\udc58 (\ud835\udc5f),_\u2190K-Colouring(cid:0)\ud835\udc5f,\ud835\udc3a,\ud835\udc58,false (cid:1)\n\ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc58 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc54) (\ud835\udc35)isdefinedtobetherankcalculatedbyKNIGHTor- 5: if UMC-Voting(cid:0)\ud835\udc3a \\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5f),C\ud835\udc58 (\ud835\udc5f),\ud835\udc54(\ud835\udc58)(cid:1) > 0\nderingwhenrecursivelyexecutingOrder-DAG(\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35))andforthe",
    "source":"whitepaper",
    "section":"choiceofclusterentailsmorethanmerelyfindingalargeenough (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":74.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_32",
    "content":"# then (Part 1)\n\niterationoftheWhileloopwhere\ud835\udc54wasfound(line12inAlgorithm2). 6: return\ud835\udc58\nDefinition6. For\ud835\udc48 \u2286 \ud835\udc3a,\ud835\udc51 \u2265 0,wesaythat\ud835\udc48 isa\ud835\udc51-UMCof\n\ud835\udc3a (UniformMajorityCoverage),if\ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc52\ud835\udc60\ud835\udc56\ud835\udc60(\ud835\udc3a) \u2208\ud835\udc48 AND\u2200\ud835\udc35 \u2208\ud835\udc48,\nAlgorithm4Ranktie-breakingprocedure\n\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35)\u2229\ud835\udc48 +\ud835\udc51 \u2265 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35)\u2229(\ud835\udc3a\\\ud835\udc48)\nInput: \ud835\udc3a \u2013ablockDAG,P1,...,P\ud835\udc5a \u2282\ud835\udc61\ud835\udc56\ud835\udc5d\ud835\udc60(\ud835\udc3a)\nForanynon-negativeinteger\ud835\udc58,\ud835\udc54(\ud835\udc58) =\ud835\udc5c(\ud835\udc58) isafunctionreOutput: AsetoftipsP\ud835\udc56 winingthetie-breaking\nturninganon-negativeinteger,usedthroughouttheprotocol.We\nset\ud835\udc54(\ud835\udc58) (cid:66) \u230a \u221a \ud835\udc58\u230b.Whenappliedtosetsofblocks,maxandmin7 1 2 : : fun \ud835\udc58 ct \u2190 ion th T e ie m -B ut r u e a a l k r i a n n g k (\ud835\udc3a of ,P P 1 1 , , . . . . . . , , P P \ud835\udc5a \ud835\udc5a ) in\ud835\udc3a\noperatorsrepresenttopologyrelations.Thatis,if\ud835\udc35=max\ud835\udc3a then\nF,_\u2190K-Colouring(cid:0)\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59(\ud835\udc3a),\ud835\udc3a,\ud835\udc54(\ud835\udc58),true (cid:1)\n\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35)\u2229\ud835\udc3a =\u2205,andlikewiseif\ud835\udc35=min\ud835\udc3athen\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35)\u2229\ud835\udc3a =\u2205. 4: forP\ud835\udc56 \u2208 (cid:8) P1,...,P\ud835\udc5a (cid:9) do\n5: for\ud835\udc58\u2032\u2208 (cid:8) \u230a\ud835\udc58\/2\u230b,...,\ud835\udc58(cid:9) do\nAlgorithm2KNIGHTDAGorderingalgorithm\n6: _,\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b \ud835\udc56,\ud835\udc58\u2032 \u2190K-Colouring(cid:0)\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59(\ud835\udc3a),\ud835\udc3a,\ud835\udc58\u2032,false (cid:1)\nInput: \ud835\udc3a \u2013ablockDAG conditioned8 on\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59(\ud835\udc3a)agreeingwithP\ud835\udc56\nO 1 u : tp fu u n t: ct S io el n ec O te r d d t e i r p - o D f A \ud835\udc3a G , ( O \ud835\udc3a r ) deringover\ud835\udc3a\u2019sblocks 7: \ud835\udc36 \ud835\udc56 \u2190(cid:208) \ud835\udc58\u2032 (cid:8)\ud835\udc35 \u2208F :\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35)\u2229\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b \ud835\udc56,\ud835\udc58\u2032 >\ud835\udc58\u2032(cid:9)\n2: if\ud835\udc3a is(cid:8)\ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc52\ud835\udc60\ud835\udc56\ud835\udc60(cid:9) then 8: \ud835\udc57 \u2190argmin \ud835\udc56\u22081,...,\ud835\udc5a max{\ud835\udc36 \ud835\udc56} (breaktiesaccordingtohash)\nreturn\ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc52\ud835\udc60\ud835\udc56\ud835\udc60,(cid:2)\ud835\udc54\ud835\udc52\ud835\udc5b\ud835\udc52\ud835\udc60\ud835\udc56\ud835\udc60(cid:3) 9: returnP\ud835\udc57\n4: for\ud835\udc35 \u2208\ud835\udc61\ud835\udc56\ud835\udc5d\ud835\udc60(\ud835\udc3a)do\n5: chain-parent(\ud835\udc35),\ud835\udc5c\ud835\udc5f\ud835\udc51\ud835\udc52\ud835\udc5f \ud835\udc35 \u2190Order-DAG(cid:0)\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35)(cid:1)\n6: P \u2190\ud835\udc61\ud835\udc56\ud835\udc5d\ud835\udc60(\ud835\udc3a) 2.6.1 Greedymaximization. Tocopewiththeintractablenatureof\n7: while (cid:12) (cid:12)P (cid:12) (cid:12) >1 do findingthemaximal\ud835\udc58-cluster,wetakeanapproachsimilarto[20]\nwheretheNP-hardversionwasreplacedwithagreedyprocedure,\n8: \ud835\udc54\u2190latestcommonchainancestorofall\ud835\udc35 \u2208P\ncalledthereinGHOSTDAG.Wethuslimitthesearchtoextensions\n9: PartitionPintomaximaldisjointsetsP1,...,P\ud835\udc5b \u2282P\nof\ud835\udc58-clustersoftheprevioustipsoftheDAG(K-Colouring,line7).\ns.t.latestcommonchainancestorofP\ud835\udc56 isin\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc54)\n10: forP\ud835\udc56 \u2208 (cid:8) P1,...,P\ud835\udc5b (cid:9) do 2.6.2 RevisitingtheMajoritycondition. Insteadofrequiringthat\n11: rank\ud835\udc56 \u2190Calculate-Rank (cid:16) P\ud835\udc56 ,\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52 \ud835\udc3a (\ud835\udc54) (cid:17) theselected\ud835\udc58-clustercoversamajorityoftheDAG(equiv.,the\nmajorityofthefuturesetofthegenesisblock),wecheckwhether\n12: \ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc58 \ud835\udc3a,\ud835\udc54 \u2190min \ud835\udc56\u2208 (cid:8) 1,...,\ud835\udc5b (cid:9)rank\ud835\udc56 itcoversamajorityofthefuturesetofeachofitsmemberblocks,\n13: P \u2190 Tie-Breaking (cid:16) \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52 \ud835\udc3a (\ud835\udc54),(cid:8) P\ud835\udc56 : rank\ud835\udc56 = includinggenesis;werefertothispropertyasuniformmajority\ncoverage,orUMC.Blockswhosefuturetheclusterfailstocoverby\n\ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc58\n(cid:9)(cid:17)\nmajorityarecastoutasoutliers,andtheprocedurecountsthem\n\ud835\udc3a,\ud835\udc54\noutsidethecluster.Theprocedureinducesacascadingmajority\n14: \ud835\udc5d \u2190thesingleelementinP\nvote(borrowedfrom[19])fromrecentblocksdowntothegenesis\n15: return\ud835\udc5d,(cid:2)\ud835\udc5c\ud835\udc5f\ud835\udc51\ud835\udc52\ud835\udc5f \ud835\udc5d \u2225\ud835\udc5d \u2225\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc5d) (cid:3) \u22b2 operator\u2225issequence block,andthelatter\u2019svotedictateswhetherthemajoritycoveris\nconcatenation;\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc5d)isiteratedinhash-basedbottom-uptopologicalorder\nsatisfactory.",
    "source":"whitepaper",
    "section":"then (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":277.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_33",
    "content":"# Byextendingthemajoritycoveragerequirementfromgenesisto\n\nany(non-outlier)blockinthe\ud835\udc58-cluster,werecoverthe\u201cMarkovian\u201d\n\n## 2.6 ReviewingthecomponentsofKNIGHT\n\nnatureofthecoverageproperty:Anynewhonestblock\u201cresets\u201dthe\nThealgorithmspresentedaboveareadmittedlyinvolved.Inthissubprocessbyposinganadditionalchallengetotheattacker,namely,to\nsectionwereviewtheircorecomponents.Thefullversion,which\ncoverthemajorityofthisnewblock.Indeed,honestminerspossess\nwillappearonline,includesalinebylineexplanationofthethree\namajorityofthehashrate,andblocksofhonestminersarereferprocedures.\nencedbytheirhonestcounterpartsafteratmost\ud835\udc37seconds,after\n6The\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61operatorisusedonasethereandreflectstheunionover\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35)for whichhonestblocksareexpectedtowintheblockracewithhigh\neveryblockintheset. probability.Toaccountforthese\ud835\udc37seconds,weallowtheclusterto\n7Aswellasargmax,argmin.\n8MeaningthatinthiscalltoK-Colouring,\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59(\ud835\udc3a)isconsideredtoagreewith\ncoveralmostamajority\u2014adeficitof\ud835\udc54(\ud835\udc58)blocksispermitted(line5\nP\ud835\udc56. inCalculate-Rank);thisrelaxedpropertyiscalled\ud835\udc54(\ud835\udc58)-UMC.\n\n--- Page 8 ---",
    "source":"whitepaper",
    "section":"Byextendingthemajoritycoveragerequirementfromgenesisto",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":24.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_34",
    "content":"# MichaelSuttonandYonatanSompolinsky (Part 1)\n\nAlgorithm5\ud835\udc58-colouringalgorithm itschainpredecessortheblockwhichminimizesitsown\ud835\udc58,ormore\nInput: \ud835\udc3a \u2013ablockDAG,\ud835\udc36 \u2013ablockin\ud835\udc3a,\ud835\udc58 \u2013anon-negative accurately,itsrank(Order-DAG,line11).Thatis,weutilizethe\ninteger,free_search\u2013aBooleanindicatingifthesearchcan optimizationproblemofKNIGHTtoselectthechain-predecessor\nmaximizefreely ofeachblockratherthantoordertheentirehistoricalDAG.This\nOutput: \ud835\udc58-colouringof\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61 \ud835\udc3a (\ud835\udc36),\ud835\udc58-chainof\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61 \ud835\udc3a (\ud835\udc36) decouplingallowsthechainto\u201crepresent\u201ddifferent\ud835\udc58\u2019salongits\n1: functionK-Colouring(\ud835\udc36,\ud835\udc3a,\ud835\udc58,free_search) growth,whichcorrespondtotheeffectivelatencyatthetime.For\n2: if\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61 \ud835\udc3a (\ud835\udc36)=\u2205then example,ifatchain-level200theattackerexposedaside-DAGthat\n3: return\u2205,\u2205 requiredincreasing\ud835\udc58from5to7,theorderingofpastblockswould\nstillbedictatedbythechainbelowlevel198,say.\n4: P \u2190\u2205\nThisdecouplingofcluster-selectionfromDAG-orderingspawns\n5: for\ud835\udc35 \u2208\ud835\udc5d\ud835\udc4e\ud835\udc5f\ud835\udc52\ud835\udc5b\ud835\udc61\ud835\udc60(\ud835\udc36)do\nanintricatedesignspacewithdifferentinter-dependenciesbetween\n6: if\ud835\udc35agreeswith\ud835\udc36then\n7: \ud835\udc4f\ud835\udc59\ud835\udc62\ud835\udc52\ud835\udc60 \ud835\udc35 ,\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b \ud835\udc35 \u2190 K-Colouring(cid:0)\ud835\udc35,\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35) \u2229 cluster-selectionandchain-ordering.Interestingly,somenatural\n\ud835\udc3a,\ud835\udc58,free_search (cid:1) candidatesturnouttobeinsecure,erringeitheronover-stability\n(therebycompromisingliveness)oron over-flexibility(compro8: P \u2190P\u222a\ud835\udc35\nmisingsafety).Westrikeabalancebetweenthesetwonecessary\n9: elseiffree_searchOR\ud835\udc58 >\ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc58 \ud835\udc3a (\ud835\udc36)then\n10: \ud835\udc4f\ud835\udc59\ud835\udc62\ud835\udc52\ud835\udc60 \ud835\udc35 ,\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b \ud835\udc35 \u2190 K-Colouring(cid:0)\ud835\udc35,\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35) \u2229 objectives byallowing thecluster-selection todeviate from the\n\ud835\udc3a,\ud835\udc58,true (cid:1) chain-selectionoflower-rankedblocks(K-Colouring,line9).\n11: P \u2190P\u222a\ud835\udc35 2.6.4 Tie-breakingforrecovery. Consideratemporaryanomaly\n12: \ud835\udc35max\u2190argmax{|\ud835\udc4f\ud835\udc59\ud835\udc62\ud835\udc52\ud835\udc60 \ud835\udc35|:\ud835\udc35 \u2208P}(breaktiesaccordingtohash) (\u201cPoissonburst\u201d)intheblockcreationprocesswhichledtoanab13: \ud835\udc4f\ud835\udc59\ud835\udc62\ud835\udc52\ud835\udc60 \ud835\udc3a ,\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b \ud835\udc3a \u2190\ud835\udc4f\ud835\udc59\ud835\udc62\ud835\udc52\ud835\udc60 \ud835\udc35max \u222a (cid:8)\ud835\udc35max (cid:9),\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b \ud835\udc35max \u222a (cid:8)\ud835\udc35max (cid:9) normallyhighrank\ud835\udc3e.Afterthenetworkresumesnormaloperation,\n14: for\ud835\udc35 \u2208\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35max,\ud835\udc3a)doinhash-basedtopologicalordering wewouldliketorecoverthenormalrank,denoted\ud835\udc58\u2605,orother15: if (cid:12) (cid:12) \ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b \ud835\udc3a \u2229 \ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35) (cid:12) (cid:12) \u2264 \ud835\udc58 AND \ud835\udc4f\ud835\udc59\ud835\udc62\ud835\udc52\ud835\udc60 \ud835\udc3a \u2229 wiselivenesswouldbecompromised(thewaitingtimeforliveness\n\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35max) <\ud835\udc58 then dependsonanon-divergingupperboundovertherank);wethus\n16: \ud835\udc4f\ud835\udc59\ud835\udc62\ud835\udc52\ud835\udc60 \ud835\udc3a \u2190\ud835\udc4f\ud835\udc59\ud835\udc62\ud835\udc52\ud835\udc60 \ud835\udc3a \u222a (cid:8)\ud835\udc35(cid:9) mustguaranteehealthygrowthofthe\ud835\udc58\u2605-cluster,evenwhenthe\n17: return\ud835\udc4f\ud835\udc59\ud835\udc62\ud835\udc52\ud835\udc60 \ud835\udc3a ,\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b \ud835\udc3a currentrank\ud835\udc3e isexcessivelyhigh.\nInthiscontextthetie-breakingrulebetweentwochain-tipcandidatesofthesamerankturnsouttobecrucial.Ana\u00efverulewould\nAlgorithm6UMCcascadevotingprocedure\npreferthelarger\ud835\udc3e-cluster,yetsuchadesignwouldallowanatInput: \ud835\udc3a \u2013ablockDAG,\ud835\udc48 \u2286 \ud835\udc3a (typicallya\ud835\udc58-colouring),\ud835\udc52 \u2013a tackertokeepthenetworkatitscurrentrankandpreventitfrom\nnon-negativeintegerrepresentingthedeficitthreshold recovering towards\ud835\udc58\u2605. Instead, we identify the tip whose clusOutput: Thevotingresult\ud835\udc63\ud835\udc5c\ud835\udc61\ud835\udc52 \u2208 (cid:8) \u22121,1(cid:9)of\ud835\udc48 \u2286\ud835\udc3a ter utilized the excessive rank latest, and prefer its counterpart\n1: functionUMC-Voting(\ud835\udc3a,\ud835\udc48,\ud835\udc52) (Tie-Breakingalgorithm,line8).Theresultingchain-selectionrule\n2: \ud835\udc63 \u2190(cid:205) \ud835\udc35\u2208\ud835\udc48 UMC-Voting(cid:0)\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35),\ud835\udc48 \u2229\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35),\ud835\udc52(cid:1) forcesatie-preservingattackertocompeteonranksmuchlower\n3: returnsign (cid:0)\ud835\udc63\u2212 (cid:12) (cid:12) \ud835\udc3a\\\ud835\udc48(cid:12) (cid:12)+\ud835\udc52(cid:1) \u22b2 wheresign(\ud835\udc65)(cid:66) (cid:26)1\ncurrentone,andeventuallytocompeteonthenatural\n2.6.5 Adaptivenesstolong-termdelaychanges. Inthelackofan\n2.6.3 Decoupleorderingfromcolouring. Recallthatourassumpapriorilatencybound,aparameterlessprotocolnecessarilypertionsallowforanattackertocontrolthepropagationtimeofany\nformsaccordingtotheactual(adversarial)latency,asdiscussed\nmessageinthenetworkuptosome(unknown)bound\ud835\udc37.Itfollows\ninSection1.However,inthecontextofaconsensusprotocolthat\nthatthelargest\ud835\udc58-cluster,for\ud835\udc58 \u22482\u00b7\ud835\udc37\u00b7\ud835\udf06(whichboundstheexpected\nservesacontinuousqueueoftransactions,thelatencymightchange\nsizeofanhonestblock\u2019snaturalanticone)isexpectedtosatisfy\nwithtime.Itwouldthenbeundesirableiftheprotocolperforms\nthemajoritycoverageproperty(\ud835\udc54(\ud835\udc58)-UMC).Onewouldexpect,",
    "source":"whitepaper",
    "section":"MichaelSuttonandYonatanSompolinsky (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":215.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_35",
    "content":"# accordingtotheworstcasehistoricallatencyratherthantherecent (Part 1)\n\ntherefore,thatthefollowingprocedurewouldsufficetosecurethe\nlatencyinthenetwork.WeformalizethisrequirementinSection3.\nordering:Findtheminimal\ud835\udc58forwhichthelargest\ud835\udc58-clustersatisfies\nthe\ud835\udc54(\ud835\udc58)-UMCproperty,andordertheDAGaccordingtothatcluster.9\nToachievethisproperty,theprotocoldefinesaconflicthierarchy,\neliminatesiterativelythelosingcandidates,andselectsthefinal\nAlbeit,thisapproachwouldunderminethestabilityoftheordersurvivalasthechain-predecessor.Thislogicisimplementedinthe\ning:Ifthenetwork\u2019slatencychanges,spontaneouslyormaliciously,\nWhileloopinOrder-DAG(line7).\nfrom\ud835\udc51 \u226a\ud835\udc37to\ud835\udc37theorderingoftheDAGwouldchangeretroactively from the largest\ud835\udc58(\ud835\udc51)-cluster to the largest\ud835\udc58(\ud835\udc37)-cluster, 2.6.6 Representativesandmonotonicity. Intheory,anattackermay\nunderminingtheconvergenceguarantee. attempttoartificiallyincreasetherankofhonestblocksbywasting\nTocopewiththischallenge,we(re)introducethenotionofa partofherhashratetomineblocksthatagreewithhonestblocks\nmainchain,andordertheDAGaccordingtothischain.Weshow butwhichdonotbelongtotheir\ud835\udc58-cluster,where\ud835\udc58isthecurrent\nthischaintoberobustevenunderchangesofdelays,renderingthe rankofhonestblocks.Whilethisschemecanbeshown(yet,at\norderingrobust.Thechainisformedasfollows:Eachblockpicksas theexpenseoffurthercomplicationoftheanalysis)tobeoverall\nsuboptimalonherpart,itdoesundermineadesired\u201cmonotonous\u201d\n9Inotherwords,for\ud835\udc58=0,1,...run\ud835\udc58-GHOSTDAG,andreturnthefirstoutputthat\nsatisfiesthe\ud835\udc54(\ud835\udc58)-UMCproperty. behaviouroftheprotocol.ConsideraDAG\ud835\udc3awithtwotips\ud835\udc35and\ud835\udc36,",
    "source":"whitepaper",
    "section":"accordingtotheworstcasehistoricallatencyratherthantherecent (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":34.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_36",
    "content":"# accordingtotheworstcasehistoricallatencyratherthantherecent (Part 2)\n\n--- Page 9 ---\nTheDAGKNIGHTProtocol:AParameterlessGeneralizationofNakamotoConsensus\nandassumethat\ud835\udc35\u201cwon\u201dandis\ud835\udc3a\u2019sselectedchaintip.Considerthe \ud835\udc37 seconds(\ud835\udc37 dependsontimesincenetworkconditionsandcon\ud835\udc61 \ud835\udc61\neffectofaddingto\ud835\udc3a anewblock\ud835\udc38,whichreferences\ud835\udc35only.Since nectivitymightchangewithtime);wedenoteby\ud835\udc37max ,orsimply\n\ud835\udc38acknowledges\ud835\udc35butnot\ud835\udc36,onewouldexpecttheadditionof\ud835\udc38to \ud835\udc37,themaximal\ud835\udc37 \ud835\udc61 across\ud835\udc61 \u2208 [0,\u221e).Importantly,\ud835\udc37 =\ud835\udc37max isa\nonlyincreasethechanceof\ud835\udc35towinover\ud835\udc36,anddefinitelynotto functionoftheblocksizelimitdenoted\ud835\udc4f\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc58_\ud835\udc60\ud835\udc56\ud835\udc67\ud835\udc52_\ud835\udc59\ud835\udc56\ud835\udc5a\ud835\udc56\ud835\udc61(KB),since\nharmit.Alas,ifasetofdisconnected\ud835\udc38\u2019sareaddedto\ud835\udc35\u2019sfuturein largemessagestakelongertopropagate.Forbrevity,weignore\nthismanner,theymayincreasetherankoftheirpartoftheDAG, thisparameter,andregardtheblocksizeasfixed.Weemphasize\nandinparticularmayflipthechoiceandleadtothechaingoing that\ud835\udc4f\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc58_\ud835\udc60\ud835\udc56\ud835\udc67\ud835\udc52_\ud835\udc59\ud835\udc56\ud835\udc5a\ud835\udc56\ud835\udc61 canbeincreasedinthesamemannerthan\nthrough\ud835\udc36.Torecoverthedesiredmonotonousbehaviour(thereby theblockrate\ud835\udf06maybeincreased,asdiscussedinSubsection5.1.\nsimplifyingoursecurityanalysis,asabyproduct),wedictatethat Theproof-of-workmechanismtargetsacertainblockcreation\n\ud835\udc36competeswith\ud835\udc35evenif\ud835\udc35isnolongeratipof\ud835\udc3a(!)Thus,towin rateof\ud835\udf06blockspersecond,kept(roughly)constantviaadifficulty\nthechainover\ud835\udc38,\ud835\udc36mustenjoyaranklowerthan\ud835\udc38(thenewtip) adjustment algorithm, similarly to Bitcoin [13]. We denote the\nbutalsoofallblocksin\ud835\udc38\u2019spast(whicharenotin\ud835\udc36\u2019spast),and proof-of-work protocol by\ud835\udc5d\ud835\udc5c\ud835\udc64(\ud835\udf06). Block creation thus follows\n\ud835\udc35inparticular;thisexemplifiestheroleoftherepresentativeset a Poisson process with parameter \ud835\udf06, and the next block in the\n(Definition4)usedinline3ofCalculate-Rank. networkiscreatedbyanhonestnodewithprobability1\u2212\ud835\udefc\n,for\nsome(unknown,potentiallydynamic)0\u2264\ud835\udefc \ud835\udc61 <\ud835\udefc (for\ud835\udc61 \u2208 [0,\u221e)).\n2.7 Runtimecomplexity Ifthisinequalityisguaranteedtoholdforsomerange\ud835\udc61 \u2265\ud835\udc60,We\nThealgorithmsspecifiedinthepreviousarticleterminateinpolysaythat\ud835\udefcisan\ud835\udc60-updatedboundovertheattacker\u2019scomputational\npower;thisdefinitionisusedbelowtoemphasizeaself-stabilizing\nnomialtime:\npropertywhichallowstorecoverfrom\u201c51%attacks\u201d.\nProposition1. Algorithm2terminatesinpolynomialtimein|\ud835\udc3a|, TheDAGorderingrule\ud835\udc42\ud835\udc45\ud835\udc37isanalgorithmthattakesasinput\nandreturnsatipandanorderingof\ud835\udc3a. aDAGofblocksandreturnsalinearorderingoveritsblocks.Inour\nparameterlessmodel,asintheclosely-relatedpartialsynchrony\nProof. Observethefollowingfacts:\nmodel,thealgorithmmaytakenoparametersasinputarguments\n\u2022 The while loop in line 7 decreases the size of P at each (suchas\ud835\udc37,\ud835\udefc,\ud835\udc58,etc.).WerequirethatallblocksintheDAGwere\niteration. minedcorrectlyaccordingto\ud835\udc5d\ud835\udc5c\ud835\udc64(\ud835\udf06).Ifblock\ud835\udc4eadmitsapathto\n\u2022 Followingline13itremainsthatP \u2260\u2205,thus,aftertheloop, block\ud835\udc4f intheDAG,\ud835\udc4ewasnecessarilycreatedafter\ud835\udc4f.TheDAG\n(cid:12) (cid:12)P (cid:12) (cid:12)=1(line14);thus,thereturnargumentisnotnull,and topologyinducesthereforeanaturalpartialordering,andthegist\nisanelementinP. oftheorderingruleistoextendthistoafullorderingoverthe\n\u2022 Theoverallrecursion(line5)terminatessince\u2200\ud835\udc35 \u2208\ud835\udc61\ud835\udc56\ud835\udc5d\ud835\udc60(\ud835\udc3a), DAG.\n\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35)\u228a\ud835\udc3a.\n\u2022 TheprocedureCalculate-Rankterminatesinpolynomial 3.1 Convergenceoftheordering\ntime,sincetheoutputofK-Colouring(\ud835\udc36,\ud835\udc3a,\ud835\udc58,\u00b7),forany\nThefollowingdefinitionsadaptandextendthemodelfromPHANblock\ud835\udc36 \u2208\ud835\udc3a,returnsak-UMC10,for\ud835\udc58 =|\ud835\udc3a|,sinceallblocks\nTOM:\nin\ud835\udc3a belongtoitslargest|\ud835\udc3a|-cluster(thereare,obviously,\nmuchtighterarguments). Property1. Anorderingrule\ud835\udc42\ud835\udc45\ud835\udc37issaidtobe:\n\u25a1 \u2022 ParameterlessifitsonlyinputargumentisablockDAG\ud835\udc3a;all\nblocksin\ud835\udc3a mustbeminedcorrectlyaccordingtotheproof-ofInafutureversionofthispaper,wewillpresentanequivalent workprotocol\ud835\udc5d\ud835\udc5c\ud835\udc64(\ud835\udf06).\nspecificationthattakesasinputtwoblocksandreturnstheirrespec- \u2022 (1\u2212\ud835\udefc)-convergent,if\u2200\ud835\udc61 >0,\u2200\ud835\udc62 \u2208H and\u2200\ud835\udc4f \u2208\ud835\udc3a \ud835\udc61 \ud835\udc62 :\ntiveordering.Thisprocedureisusefulforcertaintypesofclients\n(e.g.,whatareknownas\u201cliteclients\u201d),andcanbeshowntoterlim \ud835\udc5f\ud835\udc56\ud835\udc60\ud835\udc58(\ud835\udc4f,\ud835\udc61,\ud835\udc5f)=0,\n\ud835\udc5f\u2192\u221e\nminatewithinaconstant(intime)numberofsteps,concretely,in\nO(\ud835\udc37\u00b7\ud835\udf06)2steps.\nevenwhenafractionofatmost\ud835\udefcoftheminingpowerisbyzantine;theconvergencerateof\ud835\udc5f\ud835\udc56\ud835\udc60\ud835\udc58(\u00b7)shouldbeinO(\ud835\udc53(\ud835\udc37,\ud835\udf06,\ud835\udefc)),\nforsomefunction\ud835\udc53,and,inparticular,maynotgrowindefi3 MODELANDFORMALSTATEMENT\nnitelywith\ud835\udc61. 11\nWefollowtheprevalentmodelsforaproof-of-workgovernednet- \u2022 Scalableifthereexistsaconstant\ud835\udefc >0suchthatit(1\u2212\ud835\udefc)-\nwork[13,15]anditsextensionstotheblockDAGframework[11,19, converges for all \ud835\udf06 > 0; the maximal such\ud835\udefc is called the\n20].Anetworkofnodes(orminers)isdenotedN,eachnode\ud835\udc62main- securitythresholdof\ud835\udc42\ud835\udc45\ud835\udc37.\ntainingareplicaoftheDAGobservabletoit\ud835\udc3a \ud835\udc61 \ud835\udc62.ThesetHdenotes \u2022 Selfstabilizingifthesecuritythresholdof\ud835\udc42\ud835\udc45\ud835\udc37dependsonthe\nnodesthatfollowtheminingprotocol,whichdictatesthatevery \ud835\udc61-updatedboundovertheattacker\u2019scomputationalpower. 12",
    "source":"whitepaper",
    "section":"accordingtotheworstcasehistoricallatencyratherthantherecent (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":196.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_37",
    "content":"# newblockreferencesalltipsoftheDAGobservabletoitsminer\n\natitscreation,andisbroadcastbyitimmediatelytothenetwork.\n11Growingindefinitelywith\ud835\udc61wouldimplythatconfirmationtimesarenotbounded.\nTheattackerdeviatesarbitrarilyfromtheminingprotocol,andcan 12Thisproperty,whichissatisfiedbymanyproof-of-workconsensusprotocols,implies\nfurtheraccelerateordelaymessagesfromortohonestnodesupto thattheprotocolrecoversfromperiodswheretheattacker\u2019scomputationalpower\nexceededtheallowedthreshold,andspecificallyfromwhatisknownas\u201c51%attacks\u201d.\nInfact,someoftheseprotocols,includingKNIGHT,satisfyastrongerpropertyand\n10AsshowninthefullproofinAppendixA,UMC-Votingreturnsapositivesignif\ud835\udc48 allowthecomputationalpoweroftheattackertoexceedtheboundforsomelimited\nisa\ud835\udc51-UMC. time-intervalsinthefuture.Delvingintothesenuancesisoutsideourscope.\n\n--- Page 10 ---",
    "source":"whitepaper",
    "section":"newblockreferencesalltipsoftheDAGobservabletoitsminer",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":16.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_38",
    "content":"# MichaelSuttonandYonatanSompolinsky (Part 1)\n\n\u2022 Adaptiveiftheconvergencerateof\ud835\udc5f\ud835\udc56\ud835\udc60\ud835\udc58(\ud835\udc4f,\ud835\udc61,\ud835\udc5f) dependson thechainsolidificationunderthemostsophisticatedattack,and\ntherecentdelayratherthanthehistoricaldelay;formally,if furthergranttheattackerunrealisticcommunicationcapabilities.\nitisinO(max\n\ud835\udc60\u2265\ud835\udc61\n((\ud835\udc54(\ud835\udc60\u2212\ud835\udc61,\ud835\udefc)\u00b7\ud835\udc53(\ud835\udc37\n,\ud835\udf06,\ud835\udefc)))).Thefunction Toovercometheintractability,andinspiredbyatechniquefrom\n\ud835\udc54representsthe\u201cmemory\u201doftheprocess,i.e.,howfarintothe PHANTOMpaper,ouranalysiswaitsforarareeventinwhich\npastcurrentvaluesof\ud835\udc37(\ud835\udc37 \ud835\udc60)impactconvergence. thehonestnetworkmined\ud835\udc4d \u00b7\ud835\udc37\u00b7\ud835\udf06consecutiveblocksinachain,\nforsomepredeterminedconstant\ud835\udc4d.Thiseventisguaranteedto\nHere,\ud835\udc5f\ud835\udc56\ud835\udc60\ud835\udc58(\ud835\udc4f,\ud835\udc61,\ud835\udc5f)istheprobabilitythattheorderingbetween\ud835\udc4f\nhappenwithinaconstantnumberofsteps.Whilethisconditionis\nandanyotherblock\ud835\udc50changesbetweentime\ud835\udc61 and\ud835\udc61+\ud835\udc5f [20].\nanoverkill,relaxingitandtighteningtheconfirmationtimesisa\ncomplextask,andwedeferittofuturework.\n\n## 3.2 Formalstatement",
    "source":"whitepaper",
    "section":"MichaelSuttonandYonatanSompolinsky (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":28.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_39",
    "content":"# MichaelSuttonandYonatanSompolinsky (Part 2)\n\nNotwithstanding,anattackercannotslowdowntheconfirmation\nWearefinallyreadytoformallystatetheachievementoftheKNIGHT timesofregulartransactions,evenifitcarriesoutavisibleattack.\nprotocol: Aslongastheuserdidnotpublishanexplicitvisibleconflicttoher\ntransaction,itsreceiverwillbeabletoacceptitinthesameorderTheorem2. KNIGHT\u2019sorderingrule(Algorithm2)isparameterof-magnitudeasintheoptimisticscenario.Indeed,inthiscase,the\nless,scalable,self-stabilizing,andadaptive.",
    "source":"whitepaper",
    "section":"MichaelSuttonandYonatanSompolinsky (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":8.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_40",
    "content":"# orderingbetweenthepublishedtransactionandothertransactions (Part 1)\n\nTothebestofourknowledge,KNIGHTisthefirstproof-of-work wouldbecommutative,andthusthependingchainsolidification\nbasedprotocoltosatisfyalloftheseproperties.Forsomecompar- wouldbeinconsequentialtothistransaction.Admittedly,inthe\nisons:NCisnotscalable,sinceitssecuritythresholddeteriorates caseoftradingagainstasmartcontract,thiscommutativeproperty\nastheblockcreationrate\ud835\udf06grows;PHANTOMisnotparameter- mightnothold.14\nless,sinceitsorderingruletakesasinput\ud835\udc58,correspondingtothe Thereadermayfindthecomparisonbetweenasymptoticconnetwork\u2019s worstcase latency, andfor thesame reason itis not firmationtimesinKNIGHTandotherproof-of-workprotocolsin\nadaptive.13SPECTREdoesnotguaranteeconvergencealtogether Table1insightful.Amongtheprotocolsundercomparison,NCis\n[19]. thefastesttoconvergeundervisible(liveness)attacks,yetitconInSection4wewillfurthershedlightontheconvergencerate vergesonlyfortherange\ud835\udefc \u2208 (0,1\/(1+\ud835\udc37\u00b7\ud835\udf06))[21].SPECTREisthe\nofKNIGHT,specifically,ontheorderofthefunctions\ud835\udc53 and\ud835\udc54.In fastesttoconvergeundernovisibleattacks,itconvergesaccording\nAppendixAwewillprovidearigorousproofofTheorem2. tothecurrent(adversarial)latency\ud835\udc37 ,anddoessoslightlyfaster\nthanKNIGHTdoes.KNIGHT,inturn,convergesintheinvisible\n4 CONFIRMATIONTIMES andvisibleattackcases,anddoessocorrespondingto\ud835\udc37 aswell,\nAscommoninproof-of-workprotocols,theprocedurefordeter- incontrasttoPHANTOMwhichconvergesintermsof\ud835\udc37max=\ud835\udc37\nminingtherobustnessoftheordering\u2013i.e.,evaluatingthefunc- only.InSection6wewillsurveyadditionalprotocols.\ntion\ud835\udc5f\ud835\udc56\ud835\udc60\ud835\udc58 \u2013 is done by the client locally, outside the context of Finally,wenotethatconfirmationtimeanalysisofKNIGHTcan\nconsensus.Theperformanceoftheprotocolintermsofspeedis betightenedsignificantlywhenrestrictedtotheattackerrange\ncapturedbytheconvergencerateof\ud835\udc5f\ud835\udc56\ud835\udc60\ud835\udc58.Thismetricshouldar- \ud835\udefc <1\/3.Wedeferthisimprovementtofuturework.\nguably be dissected into two modes, optimistic and pessimistic.\nIntheformerscenario,allparticipatingnodes(miners)seemto 5 IMPLEMENTATIONDETAILS\nbehaveproperly,andinparticularthereisnovisiblesplitinthe\nAnimplementationofAlgorithm2anditssubprocedureswillbe\nDAG;formally:allblocksagreeonandamplifytheentirechain\nmadeavailableonline.\nselection,saveperhapsaconstant-sizesuffix.Inthisoptimisticscenario,KNIGHTperformsveryfast,andtransactionsmaybesafely",
    "source":"whitepaper",
    "section":"orderingbetweenthepublishedtransactionandothertransactions (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":75.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_41",
    "content":"# orderingbetweenthepublishedtransactionandothertransactions (Part 2)\n\n## 5.1 Blocksizelimit",
    "source":"whitepaper",
    "section":"orderingbetweenthepublishedtransactionandothertransactions (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":3.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_42",
    "content":"# orderingbetweenthepublishedtransactionandothertransactions (Part 3)\n\nconfirmedafteratmostO(cid:0)(ln(1\/\ud835\udf16)+\ud835\udc37\u00b7\ud835\udf06)\/(1\u22122\ud835\udefc)+(\ud835\udc37\u00b7\ud835\udf06)2(cid:1)\nsteps,orO (cid:16)(cid:16)ln(1\/\ud835\udf16) +\ud835\udc37 (cid:17) \/(1\u22122\ud835\udefc)+\ud835\udc372\u00b7\ud835\udf06 (cid:17) seconds.Intermsof So far we treated synchronous protocols as assuming a bound\n\ud835\udf06 onlatency\ud835\udc37.Infact,increasing\ud835\udc37 anddecreasing\ud835\udf06bythesame\nDefinition 1, the latter expression describes the asymptotic be- multiplicativefactorhasnoeffectandcouldberegardedasmere\nhaviourofthefunction\ud835\udc53.Thefunction\ud835\udc54definedthereincanbe changeinunits.Thus,intruth,thelatencyassumptiontakesthe\nshowntodecayexponentiallyfastinitsargument,implyingthat formofaboundover\ud835\udc37\u00b7\ud835\udf06.\nconfirmationtimesarehighlydependentontherecentworst-case Recallthat\ud835\udc37dependsonthesizeofmessages\ud835\udc4f\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc58_\ud835\udc60\ud835\udc56\ud835\udc67\ud835\udc52_\ud835\udc59\ud835\udc56\ud835\udc5a\ud835\udc56\ud835\udc61\nlatencyinthenetwork,andareinsensitivetopastorfuturenetwork (Section3).Thus,increasingtheblocksizewouldhaveasimilar\nhiccups. effect to that of increasing the block rate\ud835\udf06.15 Consequently, in\nInthepessimisticcase,whereanattackercontinuouslypublishes the same manner in which scalable protocols (Definition 1) relateblocksandtherebyslowsdownchainsolidification,ourbounds mainsecureunderany\ud835\udf06,theyremainsecureunderanyblocksize\noverconfirmationtimespresentanorder-of-magnitudeslowdown: \ud835\udc4f\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc58_\ud835\udc60\ud835\udc56\ud835\udc67\ud835\udc52_\ud835\udc59\ud835\udc56\ud835\udc5a\ud835\udc56\ud835\udc61.Inthefollowingsubsectionwediscusswhether\nO(exp(\ud835\udc50 \u00b7\ud835\udc37 \u00b7\ud835\udf06\/(1\u22122\u00b7\ud835\udefc))+ln(1\/\ud835\udf16)\/(1\u22122\ud835\udefc))) steps.Thisde- scalableparameterlessprotocols,suchasKNIGHT,needtolimit\ud835\udf06\nscribestheasymptoticbehaviourof\ud835\udc53 inthepessimisticscenario or\ud835\udc4f\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc58_\ud835\udc60\ud835\udc56\ud835\udc67\ud835\udc52_\ud835\udc59\ud835\udc56\ud835\udc5a\ud835\udc56\ud835\udc61.\n(thebehaviourof\ud835\udc54remainsthesame).Westressthatthesebounds\narefarfromtight\u2014theyresultfromtheintractabilityofanalyzing\n14Thesescenarioscorrespond,essentially,totheconsensuspropertiessafety,liveness,\n13Indeed,anylatency-parameterizedprotocolwouldnotbeadaptive.However,one andweakliveness,thelatterdefinedin[19].\nmayconceiveaparameterlessprotocolthatisnotadaptive. 15Notwithstanding,thefunction\ud835\udc37(\ud835\udc4f\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc58_\ud835\udc60\ud835\udc56\ud835\udc67\ud835\udc52_\ud835\udc59\ud835\udc56\ud835\udc5a\ud835\udc56\ud835\udc61)isnonhomogeneous.",
    "source":"whitepaper",
    "section":"orderingbetweenthepublishedtransactionandothertransactions (Part 3)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":79.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_43",
    "content":"# orderingbetweenthepublishedtransactionandothertransactions (Part 4)\n\n--- Page 11 ---\nTheDAGKNIGHTProtocol:AParameterlessGeneralizationofNakamotoConsensus",
    "source":"whitepaper",
    "section":"orderingbetweenthepublishedtransactionandothertransactions (Part 4)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":5.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_44",
    "content":"# Visibleattack Novisibleattack (Part 1)\n\n(cid:32) (cid:33)\nNC O m ( a l x n (cid:110) ( 0 1 , \/\ud835\udf16 1 ) \u2212 + \ud835\udefc \ud835\udc37\ud835\udc61 \u2212 \ud835\udf06 \ud835\udefc ) (cid:111) (sameasthevisibleattackcase,asymptotically)\n1+\ud835\udc37\ud835\udc61\u00b7\ud835\udf06\nPHANTOM O (cid:16) exp (cid:16) \ud835\udc501 \ud835\udc6b 1\u2212 ma 2 x \ud835\udefc \ud835\udf06(cid:17) + ln 1 ( \u2212 1 2 \/ \ud835\udefc \ud835\udf16)(cid:17) O (cid:16)ln(1\/ 1 \ud835\udf16 \u2212 )+ 2\ud835\udefc \ud835\udc6bmax \ud835\udf06(cid:17)\nSPECTRE \u221e O (cid:16)ln(1 1 \/ \u2212 \ud835\udf16) 2 + \ud835\udefc \ud835\udc6b\ud835\udc95 \ud835\udf06(cid:17)\nKNIGHT O (cid:16) exp (cid:16) \ud835\udc5021 \ud835\udc6b \u2212 \ud835\udc95 2 \ud835\udf06 \ud835\udefc (cid:17) + ln 1 ( \u2212 1 2 \/ \ud835\udefc \ud835\udf16)(cid:17) O (cid:16)ln(1 1 \/ \u2212 \ud835\udf16) 2 + \ud835\udefc \ud835\udc6b\ud835\udc95 \ud835\udf06 +(\ud835\udc6b\ud835\udc95 \ud835\udf06) 2(cid:17)\nTable1: Acomparisonoftheconvergenceratesofdifferentproof-of-workprotocols,intermsoftime-steps(equiv.,number\nofblocks),inthepresenceofavisibleongoinglivenessattack(leftcolumn)andwhennosuchattackiscarriedvisibly(right\ncolumn).\ud835\udc37maxdenotesanaprioriupperboundontheworstcaselatency,whereas\ud835\udc37 \ud835\udc61 denotesanupperboundonthecurrent\nlatency(includingpossibledelaysbyanadversary).Togetexpectedconfirmationtimesinseconds,multiplyeachexpression\nbytheexpectedblockinterval\ud835\udf06\u22121\n5.2 DifficultyAdjustmentAlgorithm(DAA) Thunderella[17]isapermissionlessprotocolthatisresponsive\nNCandotherproof-of-workprotocolsemployaDAAthatincreases inthestrongsenseofperformingaccordingtothenetwork\u2019sactual\nthedifficulty-targetofcreatingnewblockswhenthecomputational latency;itrequiresasupermajorityof75%tobehonestforthis\npowercontributedtoblockcreation(akahashrate)increases,and optimisticmode(comparedtoKNIGHT\u2019s51%majority),aswell\nviceversawhenitdecreases;referto[8]foraformaltreatment.Itis asthepre-selectionofaspecial\u201caccelerator\u201dnode,whichcomcommontoascribetheSybil-resiliencyofthesystemtothismech- promisesthepermissionlesspropertyofthesystem.Theworks\nanism.However,intruth,proof-of-worksufficestoprotectagainst in[3,7,22]maintain\ud835\udc58 parallelNCchains,whereeachblockis\nSybil-nodesevenwithoutanyDAA.Infact,evenifnodeswere assignedinrandomtooneofthesechains.Theorderingrulemust\nfreetochoosethedifficultyoftheirownblocks,onecoulddevisea thenspecifytherespectiveorderingbetweenblocksindifferent\nsecureconsensusprotocolbygrantingeachblockaweight,or\u201cvot- chains. These works operate in the synchronous setup, as they\ningpower\u201d,inproportiontoitsdifficulty.Instead,themotivation pre-assume\ud835\udc58 soastoensurethateachchaingrowswithnegliforDAAisthreefold: giblelatency;conceptually,asobservedby[20],theseprotocols\nrequire\ud835\udc37\u00b7\ud835\udf06\/(\ud835\udc58+1) \u226a1.Prism[3]claimaconfirmationtimeof\n\u2022 Existingprotocolsoperateinthesynchronoussetupwhich O(max(\ud835\udc501(\ud835\udefc)\u00b7\ud835\udc37,\ud835\udc502(\ud835\udefc)\u00b7\ud835\udc35 \ud835\udc63\u00b7ln(1\/\ud835\udf16)))seconds;here,\ud835\udc35 \ud835\udc63\/\ud835\udc36effecassumesanaprioriboundoverthenumberofblockscreated tivelyrepresentsthenumberofblockspersecond(\ud835\udf06,inourwork).\nperoneunitofdelay,i.e.,\ud835\udc37\u00b7\ud835\udf06.Forinstance,NCassumes Importantly,intheaboveterm\ud835\udc37standsasafunctionthatdepends\n\ud835\udc37\u00b7\ud835\udf06\u226a1,andPHANTOMassumes\ud835\udc37\u00b7\ud835\udf06\u226a\ud835\udc58+1.Topreserve onlyonnetworklatencyanddoesnotdependontheblockmessage\ntheseboundsandkeeptheprotocolsecure,\ud835\udf06cannotincrease size(denoted\ud835\udc35 ,andinourwork\ud835\udc4f\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc58_\ud835\udc60\ud835\udc56\ud835\udc67\ud835\udc52_\ud835\udc59\ud835\udc56\ud835\udc5a\ud835\udc56\ud835\udc61).Wefindthis\nindefinitely,andmustberegulatedbytheprotocol. claimquestionable,andarguethatifindeed\ud835\udc37 doesnotdepend\n\u2022 DoSprevention:Thecapacityofthenetworkandofnodes on\ud835\udc4f\ud835\udc59\ud835\udc5c\ud835\udc50\ud835\udc58_\ud835\udc60\ud835\udc56\ud835\udc67\ud835\udc52_\ud835\udc59\ud835\udc56\ud835\udc5a\ud835\udc56\ud835\udc61,then\u201cproposerblocks\u201dand\u201cvoterblocks\u201din\nislimited.TheDAAthrottlestheblockcreationrateand Prismdonotinfactattestthat\u201ctransactionblocks\u201dreferencedby\nensuresthatthemaximumcapacityisnotexceeded. themhavebeenfullypublished,whichopensupdataavailability\n\u2022 Someapplicationconsiderationsnecessitateaccesstoabso- attacks.ThenumberofchainsinPrismfurtherdependsonthe\nlutetime,suchastheregulationofminting,ortimelocks. parameter\ud835\udf16.\nTheseapplicationsusetheblockcountasaproxyforabso- Theworkin[18]proposesaseriesofprotocols,Slush,Snowflake,\nlutetime. andSnowball,whichuseanetworksamplingtechniquetoresolve\nconflictsbetweennodes.Thepaperclaimsveryfastconfirmation\nThefirstconsiderationaboveisirrelevanttoKNIGHT,whichcan times(1.35seconds).Yet,theseprotocolsoperateinthesynchronous\ncopewithdynamic\ud835\udc37and\ud835\udf06(and\ud835\udc37\u00b7\ud835\udf06).WhileKNIGHTstillrequires model(seeSection2,\u201cAchievingLiveness\u201d),andthusconfirmation\nDAAforthelatterconsiderations\u2013particularlyDoSprevention timesinthepessimisticcasearenotresponsivetothenetwork\u2019s\n\u2013itcouldbesatisfiedperhapswithrelaxedversionsofDAA.we latency. The protocols are further limited to a fixed confidence\nhopethatthisdiscussionspursnewideasforproof-of-worksystem parameter\ud835\udf16 (seee.g.Subsection3.2therein),similarlytoPrism.\ndesignsintheparameterlesssetup. Finally,thislineofworkbuildsonnovelassumptionsonnodes\u2019\nabilitytosamplethenetwork.\nOurworkwasmotivatedbyPassandShi\u2019simpossibilityresult",
    "source":"whitepaper",
    "section":"Visibleattack Novisibleattack (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":212.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_45",
    "content":"# 6 RELATEDWORK\n\nregardingresponsiveconsensusprotocols[16],whichisanadapWeconcludethispaperwithasurveyofrelatedwork.DAG-based\ntationoftheclassic34%byzantinethresholdboundonpartially\nprotocols have been mentioned extensively throughout the pasynchronousprotocolsbyDworketal.[6]topermissionlesssetper, see for example Table 1. Additional relevant protocols intings.Tocircumventthisimpossibility,wefocusedonarelaxed\ncludeGHOST,whichisanalternativechain-selectionruletoNC\u2019s",
    "source":"whitepaper",
    "section":"6 RELATEDWORK",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":20.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_46",
    "content":"# propertythataimstoberesponsivetothemaximallatencycausable\n\nlongestchain,andwhichperformssimilarly(inqualitativeterms)\nbyanadversary,ratherthantotheobservablelatency;accordingly,\ntoNC[9,10].\n\n--- Page 12 ---",
    "source":"whitepaper",
    "section":"propertythataimstoberesponsivetothemaximallatencycausable",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":7.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_47",
    "content":"# MichaelSuttonandYonatanSompolinsky (Part 1)\n\nTheorem2doesnotstateKNIGHTasbeingresponsive.KNIGHT [17] RafaelPassandElaineShi. Thunderella:Blockchainswithoptimisticinstant\nrespectstheboundof[6,16]inthatitisresponsivetothecurrent confirmation.InAnnualInternationalConferenceontheTheoryandApplications\nworst-caseadversariallatency(\u0394,intheirmodel)butnottothe\nofCryptographicTechniques,pages3\u201333.Springer,2018.\n[18] TeamRocket,MaofanYin,KevinSekniqi,RobbertvanRenesse,andEminG\u00fcn\nactualobservableone(\ud835\udefftherein).Indeed,theimpossibilityresult Sirer.Scalableandprobabilisticleaderlessbftconsensusthroughmetastability.\n(Section9.2in[16])reliesdirectlyontheattackerincreasingthe arXivpreprintarXiv:1906.08936,2019.\n[19] YonatanSompolinsky,YoadLewenberg,andAvivZohar.SPECTRE:Afastand\ndelayfrom\ud835\udeff to\u0394aftertransactionshavebeenconfirmed.Inour scalablecryptocurrencyprotocol. IACRCryptologyePrintArchive,2016:1159,\nmodel,however,transactionconfirmationtimesdependon\u0394(\ud835\udc37 , 2016.\ninournotation). [20] Yonatan Sompolinsky, Shai Wyborski, and Aviv Zohar. PHANTOM and\nGHOSTDAG:Ascalablegeneralizationofnakamotoconsensus. Cryptology\nFordiscussionoftightertransactionconfirmationpolicies,which ePrintArchive,Report2018\/104,2018.https:\/\/eprint.iacr.org\/2018\/104.\nemployabsolutetimeinadditiontotheledgerstate,see[14].The [21] YonatanSompolinskyandAvivZohar.Securehigh-ratetransactionprocessingin\nresultsthereinapply,qualitatively,toKNIGHTaswell.\nbitcoin.InInternationalConferenceonFinancialCryptographyandDataSecurity,\npages507\u2013527.Springer,2015.\nTheachievementofKNIGHTismadepossiblebythedecoupling [22] HaifengYu,IvicaNikolic,RuomuHou,andPrateekSaxena.Ohie:Blockchain\nofthecanonicalprotocoldictatingtheorderingoveralltransactions, scalingmadesimple.arXivpreprintarXiv:1811.12628,2018.\nandtheclientprotocolforestimatingitsfinality(Subsection1.4).",
    "source":"whitepaper",
    "section":"MichaelSuttonandYonatanSompolinsky (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":50.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_48",
    "content":"# AsimilardecouplingwaspreviouslyproposedintheFlexibleBFT A SECURITYPROOF (Part 1)\n\npaper [12]. That work operates in the traditional permissioned A.1 DefinitionsandNotation\nsetup, and is still restricted by the 34% threshold for byzantine\nDefinition7. \ud835\udc3a \ud835\udc61 istheoracleDAGattime\ud835\udc61.Similarly,forblock\ud835\udc35\nresilienceofpartiallysynchronousprotocols,byDworketal.[6].\nToreasonaboutthefundamentaldifferenceinparadigm,observe\nminedat\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52(\ud835\udc35),weabusenotationanddefine\ud835\udc3a \ud835\udc35 (cid:66)\ud835\udc3a \ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52(\ud835\udc35).\nthattheconsensusparticipantsinFlexibleBFTarenotagnostic Definition8. F\ud835\udc58 (\ud835\udc35,\ud835\udc3a)isthemaximization-free\ud835\udc58-clusterofblock\ntothefinalityoftransactions\u2014theyreacheventualagreementon \ud835\udc35ascalculatedbythecallK-Colouring(\ud835\udc35,\ud835\udc3a,\ud835\udc58,true)inAlg.5.\nfinality.Incontrast,proof-of-workminersrunningKNIGHTneed\nnotreachanyagreementonfinalityoftransactions,andareinfact\nDefinition 9. C\ud835\udc58 (\ud835\udc35,\ud835\udc3a) is the\ud835\udc58-cluster of block \ud835\udc35 as calculated\nbyK-Colouring(\ud835\udc35,\ud835\udc3a,\ud835\udc58,false) inAlg.5.Weuse C(\ud835\udc35) todenote\nnotrequiredtointerpretthestatewhatsoever.Webelievethatthis\nagnosticismtowardsthestateisnecessarywhendesigninga50%\nC\ud835\udc58 (\ud835\udc35,\ud835\udc3a)forthespecialcase\ud835\udc58 =\ud835\udc58\u2605 .Whenthecontextisclearwe\nBFTparameterlessconsensusprotocol.\nabbreviateandwritesimplyC\ud835\udc58 (\ud835\udc35).\nDefinition10. \ud835\udc58-chain(\ud835\udc35,\ud835\udc3a)isthechainof\ud835\udc58-maximizingblocks\nusedbyK-Colouring(\ud835\udc35,\ud835\udc3a,\ud835\udc58,\ud835\udc53\ud835\udc4e\ud835\udc59\ud835\udc60\ud835\udc52)inordertocomposeC\ud835\udc58 (\ud835\udc35,\ud835\udc3a).\nREFERENCES Moreconcretely,the\ud835\udc58-chainparentofblock\ud835\udc35is\ud835\udc35max,assignedat\n[1] http:\/\/bitcoinfibre.org\/stats.html. line12ofAlg.5,andsoon,recursively.\n[2] http:\/\/kgi.kaspad.net\/.\n[3] VivekBagaria,SreeramKannan,DavidTse,GiuliaFanti,andPramodViswanath. Definition 11. C\ud835\udc58 (\ud835\udc35) is the complementary set of C\ud835\udc58 (\ud835\udc35) at",
    "source":"whitepaper",
    "section":"AsimilardecouplingwaspreviouslyproposedintheFlexibleBFT A SECURITYPROOF (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":89.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_49",
    "content":"# lim\n\n\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52(\ud835\udc35).Moreformally, C\ud835\udc58 (\ud835\udc35)(cid:66)\ud835\udc3a \ud835\udc35\\C\ud835\udc58 (\ud835\udc35)\npages585\u2013602,2019. Definition 12. The merge set of block \ud835\udc65 is defined by\n[4] SheharBano,AlbertoSonnino,MustafaAl-Bassam,SarahAzouvi,PatrickMcCorry,SarahMeiklejohn,andGeorgeDanezis. Sok:Consensusintheageof \ud835\udc5a\ud835\udc52\ud835\udc5f\ud835\udc54\ud835\udc52\ud835\udc60\ud835\udc52\ud835\udc61(\ud835\udc65) (cid:66) \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc65) \\\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(chain-parent(\ud835\udc65)). We say block\nblockchains.InProceedingsofthe1stACMConferenceonAdvancesinFinancial \ud835\udc65 ismergingblock\ud835\udc66if\ud835\udc66 \u2208\ud835\udc5a\ud835\udc52\ud835\udc5f\ud835\udc54\ud835\udc52\ud835\udc60\ud835\udc52\ud835\udc61(\ud835\udc65).\nTechnologies,pages183\u2013198,2019.\n[5] EdsgerWDijkstra.Self-stabilizingsystemsinspiteofdistributedcontrol.Com- Thesetofblocksminedafterandbeforeblock\ud835\udc65(inabsolutetime,\n[6]\nmeyer.Consensusinthepresence\nasseenbyanexternaloracle),aredenotedbefore(\ud835\udc65)andafter(\ud835\udc65)\nofpartialsynchrony.JournaloftheACM(JACM),35(2):288\u2013323,1988. respectively.Weusesubscriptnotation\ud835\udc4b\nand\ud835\udc4b\n\u27e8\ud835\udc65,\ud835\udc66\u27e9",
    "source":"whitepaper",
    "section":"lim",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":42.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_50",
    "content":"# over (Part 1)\n\n[7] MatthiasFitzi,PeterGazi,AggelosKiayias,andAlexanderRussell. Parallel asetofblocks\ud835\udc4b,toindicate\ud835\udc4b \\after(\ud835\udc65),\ud835\udc4b \u2229after(\ud835\udc65)and\ud835\udc4b \u2229\nchains:Improvingthroughputandlatencyofblockchainprotocolsviaparallel\ncomposition.IACRCryptologyePrintArchive,2018:1119,2018. after(\ud835\udc65)\\after(\ud835\udc66)respectively.\n[8] JuanGaray,AggelosKiayias,andNikosLeonardos.Thebitcoinbackboneprotocol We notate\ud835\udc65 \u21d2 \ud835\udc66 if\ud835\udc66 = chain-parent(\ud835\udc65). Similarly, we use\nwithchainsofvariabledifficulty.InAnnualInternationalCryptologyConference,\n\ud835\udc65 \u21d2 \ud835\udc66if\ud835\udc66isthe\ud835\udc58-chainparentof\ud835\udc65.\npages291\u2013323.Springer,2017. \ud835\udc58\n[9] AggelosKiayiasandGiorgosPanagiotakos.Ontrees,chainsandfasttransactions\nintheblockchain.CryptologyePrintArchive,Report2016\/545,2016. A.2 K-clusterCombinatorics\n[10] LuciannaKiffer,RajmohanRajaraman,andAbhiShelat.Abettermethodtoanalyzeblockchainconsistency.InProceedingsofthe2018ACMSIGSACConference Unlike the GHOSTDAG\ud835\udc58-colouring algorithm (Algorithm 1 in\nonComputerandCommunicationsSecurity,pages729\u2013744,2018. [20]), the K-Colouring procedure in Algorithm 5 uses weaker\n[11] YoadLewenberg,YonatanSompolinsky,andAvivZohar.Inclusiveblockchain\nprotocols.InInternationalConferenceonFinancialCryptographyandDataSecucolouringruleswhichgiveprecedencetopastandcurrentchain\nrity,pages528\u2013547.Springer,2015. blocks(line15therein).Nonetheless,asweshowbelow,forsome\n[12] DahliaMalkhi,KartikNayak,andLingRen.Flexiblebyzantinefaulttolerance.In larger\ud835\udc3e >\ud835\udc58theresultingclusterisstillavalid\ud835\udc3e-cluster.Denote\nProceedingsofthe2019ACMSIGSACconferenceoncomputerandcommunications\nsecurity,pages1041\u20131053,2019. \ud835\udc3e(\ud835\udc58) (cid:66) (2\ud835\udc58+1)(\ud835\udc58+1).\n[13] SatoshiNakamoto.Bitcoin:Apeer-to-peerelectroniccashsystem,2008.\n[14] SebNeumayer,MayankVaria,andIttayEyal.Ananalysisofacceptancepolicies Lemma1. Foranyblock\ud835\udc35andDAG\ud835\udc3a,thecluster\ud835\udc36 returnedby\nforblockchaintransactions.CryptologyePrintArchive,2018. K-Colouring(\ud835\udc35,\ud835\udc3a,\ud835\udc58,\u00b7)isa\ud835\udc3e(\ud835\udc58)-cluster.\n[15] RafaelPass,LiorSeeman,andAbhiShelat.Analysisoftheblockchainprotocol\ninasynchronousnetworks.IACRCryptologyePrintArchive,2016:454,2016. Proof. Thefirstconditioninline15impliesthatablockaddedto\n[16] RafaelPassandElaineShi.Hybridconsensus:Efficientconsensusinthepermissionlessmodel,2016. thecolouringcannothavemorethan\ud835\udc58chain-blocksinitsanticone.",
    "source":"whitepaper",
    "section":"over (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":83.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_51",
    "content":"# over (Part 2)\n\n--- Page 13 ---\nTheDAGKNIGHTProtocol:AParameterlessGeneralizationofNakamotoConsensus\nHence by the time \ud835\udc35 is coloured and added to\ud835\udc36, is holds that thegrowth-rateprovenforGHOSTDAGfromachievingarelative\n|\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35)\u2229\ud835\udc36| \u2264 (\ud835\udc58+1)(\ud835\udc58+1).Thisfollowsfromthefactthat majority(overtheattacker),toachievinganabsolutemajority.\neachofthe\ud835\udc58chainblockspriortothechain-blockmerging\ud835\udc35has\nmergedatmost\ud835\udc58blocks(fromthesecondconditioninline15). Claim1. Thereexists\ud835\udc58\ud835\udc5b\ud835\udc4e\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc4e\ud835\udc59 ,dependingonlyon\ud835\udc37,\ud835\udefc and\ud835\udf06,s.t.\nLikewise, only the next \ud835\udc58 chain-blocks can colour blocks \u2208 theexpectedgrowthofF \ud835\udc58\ud835\udc5b\ud835\udc4e\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc4e\ud835\udc59 (\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc61)isstrictlylargerthan0.5;\n\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35),resultingin\ud835\udc58(\ud835\udc58+1)moreblocks.Combinedweget thatis,\n|\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35)\u2229\ud835\udc36| \u2264 (2\ud835\udc58+1)(\ud835\udc58+1)=\ud835\udc3e(\ud835\udc58) \u25a1 E(cid:0)(cid:12) (cid:12)F \ud835\udc58\ud835\udc5b\ud835\udc4e\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc4e\ud835\udc59 (\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc61+\ud835\udc5f) (cid:12) (cid:12)\u2212 (cid:12) (cid:12)F\ud835\udc58\u2605(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc61) (cid:12) (cid:12) (cid:1) >0.5\ud835\udc5f\ud835\udf06.\nLemma2. Let\ud835\udc351,\ud835\udc352,...,\ud835\udc35 \ud835\udc5b\u22121,\ud835\udc35 \ud835\udc5bbeasequenceof\ud835\udc58-chainblocks Wenowusethemaximization-freeexpectedgrowth-rate,and\ns.t.\ud835\udc35 \ud835\udc56\u22121 \u21d2 \ud835\udc58 \ud835\udc35 \ud835\udc56 andlet\ud835\udc35 \u2208C\ud835\udc58 (\ud835\udc351)\\C\ud835\udc58 (\ud835\udc352)s.t.\ud835\udc35 \ud835\udc5bisthemaximal utilizetheTie-Breakingalgorithm,toshowthatlarger-than50%\nelement\u2208\ud835\udc58-chain(\ud835\udc351)\u2229\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35);thenC\ud835\udc58 (\ud835\udc351)\\C\ud835\udc58 (\ud835\udc35 \ud835\udc5b) \u22644\ud835\udc3e(\ud835\udc58). growth-rateisachievedalsoforthenon-freecolouring,albeitwith\nalarger\ud835\udc58parameter.\nProof. 16Theset\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc351)\\\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35 \ud835\udc5b)iscoveredbytheanticonesof\ud835\udc35,\ud835\udc352,\ud835\udc35 \ud835\udc5b\u22121,\ud835\udc35 \ud835\udc5b \u2208 C\ud835\udc58 (\ud835\udc351),whichimmediatelyimpliesits Proposition3. Thereexists\ud835\udc58\u2605 ,dependingonlyon\ud835\udc37,\ud835\udefc and\ud835\udf06s.t.\nintersectionwithC\ud835\udc58 (\ud835\udc351)is\u22644\ud835\udc3e(\ud835\udc58).Toseethecovering,assume theexpectedgrowthofC\ud835\udc58\u2605(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc61)isstrictlylargerthan0.5;that\nthereexistsablock\ud835\udc37 notinanyanticone,so\ud835\udc37 \u2209 \ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35); is,\nif \ud835\udc37 \u2208 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35) then it must be \u2208 \ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc352), otherwise E(cid:0)(cid:12) (cid:12)C\ud835\udc58\u2605(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc61+\ud835\udc5f) (cid:12) (cid:12)\u2212 (cid:12) (cid:12)C\ud835\udc58\u2605(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc61) (cid:12) (cid:12) (cid:1) >0.5\ud835\udc5f\ud835\udf06.\n\ud835\udc35 \u2208 \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc352); if on the other hand \ud835\udc37 \u2208 \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35) it cannot be\nin\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35 \ud835\udc5b\u22121)sincethatwillcontradictmaximalityof\ud835\udc35 \ud835\udc5b ,thus Corollary2. If\ud835\udc48 is\ud835\udc51-UMCof\ud835\udc3a,thenUMC-Voting (cid:0)\ud835\udc3a,\ud835\udc48,\ud835\udc51(cid:1) >0.\n\u2208\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35 \ud835\udc5b\u22121)whichimplies\ud835\udc37 \u2208\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35 \ud835\udc5b),acon\nClaim 3. UMC-Voting (cid:0)\ud835\udc3a \ud835\udc61 ,C\ud835\udc58\u2605(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc61),\ud835\udc54(\ud835\udc58\u2605)(cid:1) has positive\nvalueinexpectation.\nLemma3. Let\ud835\udc351,...,\ud835\udc35 \ud835\udc5b\u22121,\ud835\udc35 \ud835\udc5bbeasequenceof\ud835\udc58-chainblockss.t.\nA.4.2 Livenesscollapse.\n\ud835\udc35 \ud835\udc56\u22121 \u21d2 \ud835\udc58 \ud835\udc35 \ud835\udc56 andlet\ud835\udc35 \u2208 C\ud835\udc58 (\ud835\udc351) s.t.\ud835\udc35 \ud835\udc5b isthemaximalelement\u2208\n\ud835\udc58-chain(\ud835\udc351)\u2229\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc35),then (cid:0)\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35 \ud835\udc5b)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35)(cid:1)\u2229C\ud835\udc58 (\ud835\udc351) \u2264 Definition 13. The attacker advantage \ud835\udc4e\ud835\udc51\ud835\udc63(\ud835\udc61) at time \ud835\udc61 as\n2\ud835\udc3e(\ud835\udc58). \ud835\udc4e\ud835\udc51\ud835\udc63(\ud835\udc61) (cid:66)max \ud835\udc35\u2208C\ud835\udc58\u2605(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59\ud835\udc61) \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35)\u2229(\ud835\udc3a \ud835\udc61 \\C\ud835\udc58\u2605(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc61))\u2212\n\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35)\u2229C\ud835\udc58\u2605(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc61).\nProof. Theset\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35 \ud835\udc5b)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc35)iscoveredbytheanticonesof\ud835\udc35,\ud835\udc35 \ud835\udc5b\u22121 \u2208C\ud835\udc58 (\ud835\udc351),whichimmediatelyimpliesitsinter- Lemma4. Theattackeradvantage\ud835\udc4e\ud835\udc51\ud835\udc63(\ud835\udc61)isupperboundedbya\nsectionwithC\ud835\udc58 (\ud835\udc351)is\u22642\ud835\udc3e(\ud835\udc58).Toseethecovering,assumethere stochasticprocesswhichadmitsastationarydistributionwith\ud835\udc360 =\nexistsablockinthissets.t.\ud835\udc37 \u2209\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35),\u2209\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc35 \ud835\udc5b\u22121); O(\ud835\udc58\ud835\udc5b\ud835\udc4e\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc4e\ud835\udc59)skewandanexponentiallydecayingtail.\ns c im o on p \ud835\udc37 t l r ie \u2208 a s d \ud835\udc5d i \ud835\udc37 c \ud835\udc4e t \ud835\udc60 \u2209 \ud835\udc61 m ( \ud835\udc53 \ud835\udc35 a \ud835\udc62 x ) \ud835\udc61 i \ud835\udc62 h m \ud835\udc5f e a \ud835\udc52 n l c ( it e \ud835\udc35 y \ud835\udc5b it o ) c , f a a \ud835\udc35 n c \ud835\udc5b n o , o n s t t o b ra e i d t i i n m ct \ud835\udc53 i u o \ud835\udc62 s n \ud835\udc61 t \ud835\udc62 . b \ud835\udc5f e \ud835\udc52 \u2208 (\ud835\udc35 \ud835\udc5b \ud835\udc5d \u2212 \ud835\udc4e 1 \ud835\udc60\ud835\udc61 ) ( s \ud835\udc35 in \ud835\udc5b c \u2212 e 1 t ) h w at h w ic i \u25a1 h ll \ud835\udc36 D 0 efi + n 3\ud835\udc4d iti s o t n ar 1 ti 4 n . g A at b ti u m rs e t \ud835\udc61 e , v w en h t er B e \ud835\udc61 \ud835\udc4d ,\ud835\udc4d is is a a f n un h c o t n io e n st o c f h \ud835\udc3e ai ( n \ud835\udc58\u2605 bu ). rstofsize",
    "source":"whitepaper",
    "section":"over (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":425.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_52",
    "content":"# LetBdenotethesequenceofblocksconstitutingtheburstevent (Part 1)\n\nA.3 Maintheorem B\ud835\udc61,\ud835\udc4d andletB\ud835\udc56 bethe\ud835\udc56\u2019thblockfromthestartoftheevent.Denote\nWearenowreadytoproveourmainresult.Forthereader\u2019sconve- theparticularblockss (cid:66) B1,\ud835\udf19 (cid:66) B\ud835\udc360 ,d (cid:66) B\ud835\udc360+\ud835\udc4d ,e (cid:66) B\ud835\udc360+2\ud835\udc4d .\nnience,wefirstrestatetheclaim: Theseblocksrepresentthestartingpointsoftheevent,thepivot\nTheorem2.KNIGHT\u2019sorderingrule(Algorithm2)isparameter- block\ud835\udf19whichweclaimtobeonanyfuturehonestchain,thedefeat\nless,scalable,self-stabilizing,andadaptive. blockdrepresentingthepointwheretheattackerisinsufficient\ndeficit,andtheendblockoftheburst,e.\nA.4 Proof\nDefinition15. Anhonestblock-racewineventW\ud835\udc61 istheeventthat\nW vie e w fi . x W a e n t a h r u bi s tr a a b r b y re h v o i n a e te st \ud835\udc63 n \ud835\udc56\ud835\udc5f o \ud835\udc61 d \ud835\udc62 e \ud835\udc4e \ud835\udc62 \ud835\udc59 \u2208 to \u210e r \ud835\udc5c e \ud835\udc5b p \ud835\udc52 r \ud835\udc60 e \ud835\udc61 se a n n t d t a h s e su v m irt e u i a ts lb p l o o i c n k t o o f f startingfromtime\ud835\udc61,\u2200\ud835\udc60 >\ud835\udc61,C(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc60) \u27e8\ud835\udc61 \u2265 C(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc60) \u27e8\ud835\udc61\nnode\ud835\udc62attime\ud835\udc61.Weadditionallyregardthepovofahypothetical Definition16. Theevent-sequenceE\ud835\udc61,\ud835\udc4d isdefinedtobethesequence\noraclenodethatseesallblocksimmediatelyupontheircreation, ofevents(i)\ud835\udc4e\ud835\udc51\ud835\udc63(\ud835\udc61) \u2264\ud835\udc360,(ii)followedbyaburstB\ud835\udc61,\ud835\udc4d,(iii)followed\nincludingtheattacker;infact,theomnipotentattackerinourmodel byablock-racewinW\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52(e).Notethatalleventsareindependent\nenjoysthesamepovastheoraclenode. andhavepositiveprobability.\nBelow,wewillskipproofsofthemorestraightforwardclaims.\nWewillclosethisgapinafutureversionofthispaper. Definition17. Aisthesetofnon-convincedblocksfollowingthe\nburstevent,i.e.,theset (cid:8)\ud835\udc35 \u2208\ud835\udc3a \u27e8e,\u221e\u27e9 :\ud835\udf19 \u2209\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc35) (cid:9) .\nA.4.1 Chaingrowth. Webeginbyanalyzingthegrowthrateofthe\nm ist a s x a im \u201cn iz a a tu ti r o a n l\u201d -f \ud835\udc58 re f e or c w ol h o i u c r h in t g hi F s \ud835\udc58 co ( l \ud835\udc63 o \ud835\udc56 u \ud835\udc5f r \ud835\udc61 i \ud835\udc62 n \ud835\udc4e g \ud835\udc59 \ud835\udc61 y ) ie a l n d d s> sh 5 o 0 w % t g h r a o t w th th e . re Th ex is - f D ro e m fin b i l t o io ck n d 18 o . f H th \ud835\udc50 e i b s u th r e st se e t v o e f n c t h , a i. i e n ., b t l h oc e k s s e o t f (cid:8) h \ud835\udc35 one \u2208 st \ud835\udc3a no \u27e8d d , e \u221e \ud835\udc62 \u27e9 ,s : ta \u2203 r \ud835\udc61 tin > g\n\u201cfree-search\u201dalgorithmcanbeseenasamodifiedGHOSTDAG[20], \ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52(d),\ud835\udc35 \u2208\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc61) (cid:9) .",
    "source":"whitepaper",
    "section":"LetBdenotethesequenceofblocksconstitutingtheburstevent (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":339.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_53",
    "content":"# wherebyweakeningthecolouringruleswewereabletostrengthen\n\nClaim4. Forblock\ud835\udc4e\u2208A,denote\ud835\udc4e1=min\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc4e)\u2229after(e)and\n16TheproofsofthecurrentandfollowinglemmasareinspiritofPHANTOM\u2019s \ud835\udc4e2 = max\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc4e)\u2229before(s).Thenitholdsthat\u2200\ud835\udc5d \u2208 B \u27e8\ud835\udf19 ,\ud835\udc5d \u2208\nfreeloaderbound[20]. \ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc4e1)\u222a\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc4e2).\n\n--- Page 14 ---",
    "source":"whitepaper",
    "section":"wherebyweakeningthecolouringruleswewereabletostrengthen",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":17.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_54",
    "content":"# MichaelSuttonandYonatanSompolinsky\n\nProof. Assume there exists such \ud835\udc5d \u2209 \ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc4e1) \u222a Claim6.1.1. \u2200\ud835\udc5d \u2208 \ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\u210e) \u27e8d ,\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d)\u2229C(\u210e)+2\ud835\udc58\u2605+2 \u2265\n\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc4e2),then\ud835\udc5d \u2208 \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e1)\u2229\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4e2),so\ud835\udc5d \u2208\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc4e), \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d)\\C(\u210e).\ncontradicting\ud835\udc4e\u2208A. \u25a1\nProof. Notethat\ud835\udc5d \u2208H\ud835\udc50 \\Asince\ud835\udc5d \u2208\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\u210e),\u210e\u2208H\ud835\udc50 \\A,\nClaim5. Forblock\ud835\udc4e\u2208A,C\ud835\udc58 (\ud835\udc4e)\u2229B \u27e8\ud835\udf19 \u22642\ud835\udc3e(\ud835\udc58). thusfromminimalityof\u210e,\ud835\udc4ewehavethatafter(\ud835\udc5d)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d) \u2265\nC(\ud835\udc5d) \u2212 C(\ud835\udc5d) .\n\u27e8d \u27e8d\nProof. FollowsfromClaim4andfromthedefinitionofa\ud835\udc58- Partition after(\ud835\udc5d) into the following disjoint sets: \ud835\udc5a (cid:66)\ncluster. \u25a1 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d)\u2229C(\u210e),\ud835\udc63 (cid:66)after(\ud835\udc5d)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d)and\ud835\udc62 (cid:66) \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d)\\\nC(\u210e).Additionally,define\u2113 (cid:66)after(\u210e).Thefollowingclaimsshow",
    "source":"whitepaper",
    "section":"MichaelSuttonandYonatanSompolinsky",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":61.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_55",
    "content":"# The proof of the claim below assumes that the colouring of (Part 1)\n\nrelationsregardingthesedefinitions.\n\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc35)coincideswith\ud835\udc58-chain(\ud835\udc35,\ud835\udc3a),forany\ud835\udc58andforanysubDAG\ud835\udc3a.Followingtheproofwealleviatethisassumption.Addition- Claim6.1.1.1. C(\u210e)\u2212 C(\ud835\udc5d)\u2265\ud835\udc62+\ud835\udc63\u2212\u2113\u2212\ud835\udc58\u2605\u22121.\nally,forlegibility,theproofdoesnotdistinguishexplicitlybetween\n\ud835\udc58\u2605and\ud835\udc3e(\ud835\udc58\u2605).Thismerelymeansthatsomeoftheconstantssuch Proof. Since\ud835\udc5d \u2208\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\u210e)itfollowsbyincrementalityofC(\u210e)\nas\ud835\udc4d needtobesetlargerandwithrespectto\ud835\udc3e(\ud835\udc58\u2605)ratherthan over\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\u210e) that C(\ud835\udc5d) \u2282 C(\u210e). It also follows by\ud835\udc58\u2605-cluster\n\ud835\udc58\u2605. anticoneboundthat\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc5d)\u2229C(\u210e) \u2264\ud835\udc58\u2605+1.\nWenowcontrastbothexpressions C(\u210e)\u2212 C(\ud835\udc5d)and\ud835\udc62+\ud835\udc63\u2212\u2113\nClaim 6. (main claim) Conditioned on the occurrence of event- withtheset\ud835\udc3a\n\u27e8\ud835\udc5d,\u210e\u27e9\n\\C(\u210e)andshowthattheydifferonlyby\ud835\udc58\u2605+1.\nsequenceE\ud835\udc61,\ud835\udc4d,itholdsthatforany\u210e\u2208H\ud835\udc50 \\A,andforany\ud835\udc4e\u2208A\nObservethat C(\ud835\udc5d)=\ud835\udc3a\n\\C(\ud835\udc5d) =\ud835\udc3a\n\\C(\u210e)+\ud835\udc3a\n\u2229(C(\u210e)\\\nmerging\u210e,\nC(\ud835\udc5d)),andthat C(\u210e)=\ud835\udc3a \u210e\\C(\u210e).Thusbysubtractionweobtain\n\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e)\u2229after(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e) \u2265C(\u210e) \u27e8d \u2212 C(\u210e) \u27e8d . C(\u210e)\u2212 C(\ud835\udc5d)=(\ud835\udc3a \u210e\\\ud835\udc3a \ud835\udc5d)\\C(\u210e)\u2212\ud835\udc3a \ud835\udc5d\u2229(C(\u210e)\\C(\ud835\udc5d))=\ud835\udc3a \u27e8\ud835\udc5d,\u210e\u27e9 \\\nC(\u210e)\u2212(before(\ud835\udc5d)\\\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5d))\u2229C(\u210e).\nProof. Assumeforcontradictiontheclaimisfalse.Welookat\nOntheotherhand\ud835\udc63+\ud835\udc62\u2212\u2113 =after(\ud835\udc5d)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d)+\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d)\\\ntheminimalevent\u210e,\ud835\udc4eviolatingtheclaimstatement,i.e.,\ud835\udc4e\u2208Aisa\nC(\u210e) \u2212after(\u210e) = (after(\ud835\udc5d) \\ \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d)) \\C(\u210e) + (after(\ud835\udc5d) \\\n) \u27e8\n\u2208H\ud835\udc50\\Aand\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e)\u2229after(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e) <\n\u210e) \u2212after(\u210e) = \ud835\udc3a \u27e8\ud835\udc5d,\u210e\u27e9 \\\nDenote\ud835\udc54tobethemostrecentsharedchain-ancestorof\u210eand\ud835\udc4e,\nCombining both parts we have C(\u210e)\u2212 C(\ud835\udc5d)+ (before(\ud835\udc5d) \\\ni.e.,\ud835\udc54=max\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\u210e)\u2229\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc4e).WeanalyzetherunofAlgorithm\n2fortherecursivecallwhere\ud835\udc3a = \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e) (line5),andforthe \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5d)) \u2229 C(\u210e) = \ud835\udc3a \u27e8\ud835\udc5d,\u210e\u27e9 \\ C(\u210e) = \ud835\udc63 +\ud835\udc62 \u2212 \u2113 \u2212 (after(\ud835\udc5d) \\\niteration of the While loop at which\ud835\udc54 is obtained (line 8), and\n\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d))\u2229C(\u210e),thus C(\u210e)\u2212 C(\ud835\udc5d)=\ud835\udc63+\ud835\udc62\u2212\u2113\u2212\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc5d)\u2229\nreachacontradictiontothealgorithm\u2019sdecision.Throughoutthe\nC(\u210e) \u2265\ud835\udc63+\ud835\udc62\u2212\u2113\u2212\ud835\udc58\u2605\u22121. \u25a1\nproofandsub-claims,weimplicitlyuseacontextDAGCwhich\nClaim6.1.1.2.\n\ud835\udc5a+\ud835\udc58\u2605+1\u2265C(\u210e)\u2212C(\ud835\udc5d).\nallsetsareintersectedwith.WesetthebroadercontexttobeC=\n\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52 (\ud835\udc54)\u2229\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e),howeveratsomeinnerargumentswenarrow Proof. Asshowninthepreviousclaim,C(\ud835\udc5d) \u2282C(\u210e).Itfollows\nthecontextfurther. byelementarysetlogicthatC(\u210e)\u2212C(\ud835\udc5d)=C(\u210e)\\C(\ud835\udc5d)=C(\u210e)\\\nFrom minimality of\ud835\udc4e we have that \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e) \u2229A = \u2205. To \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5d)=C(\u210e)\u2229\ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\ud835\udc5d)+C(\u210e)\u2229\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d) \u2264\ud835\udc58\u2605+1+\ud835\udc5a;\nsee this, assume otherwise and let \ud835\udc4e\u2032 = min\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e) \u2229 A. wherethelasttransitionisfrom\ud835\udc58\u2605-clusteranticonebound. \u25a1\nSo \u210e \u2208 \ud835\udc5a\ud835\udc52\ud835\udc5f\ud835\udc54\ud835\udc52\ud835\udc60\ud835\udc52\ud835\udc61(\ud835\udc4e\u2032) since \u210e \u2209 A,\ud835\udc4e\u2032 \u2208 A. Additionally,",
    "source":"whitepaper",
    "section":"The proof of the claim below assumes that the colouring of (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":190.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_56",
    "content":"# Usingtheabovedefinitionsandthecontradictionhypothesiswe\n\nsince \ud835\udc4e\u2032 \u2208 \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e) it holds that \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e\u2032) \u2282 \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e), hence\n\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e\u2032)\u2229after(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e) \u2282\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e)\u2229after(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e) < have\ud835\udc63 \u2265 C(\ud835\udc5d) \u27e8d \u2212 C(\ud835\udc5d) \u27e8d and\u2113 < C(\u210e) \u27e8d \u2212 C(\u210e) \u27e8d .Negating",
    "source":"whitepaper",
    "section":"Usingtheabovedefinitionsandthecontradictionhypothesiswe",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":29.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_57",
    "content":"# thefirstinequalityandsummingtheexpressionsweobtain (Part 1)\n\nC(\u210e) \u2212 C(\u210e) ,contradictingminimalityof\ud835\udc4e.\n\u27e8d \u27e8d\nWe now prove that \u2200\ud835\udc5e \u2208 \ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\u210e) \u2229 A,\ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc58 C (\u210e) < C(\u210e) \u27e8d \u2212C(\ud835\udc5d) \u27e8d >\u2113\u2212\ud835\udc63+ C(\u210e) \u27e8d \u2212 C(\ud835\udc5d) \u27e8d .\n\ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc58 (\ud835\udc5e).\nC ApplyingClaims6.1.1.1,6.1.1.2onbothsideswegetthat\ud835\udc5a+\ud835\udc58\u2605+1>\nClaim6.1. C(\u210e)isa (cid:0)4\ud835\udc58\u2605+2(cid:1) -UMCofC\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e). \u2113\u2212\ud835\udc63+\ud835\udc63+\ud835\udc62\u2212\u2113\u2212\ud835\udc58\u2605\u22121=\ud835\udc62\u2212\ud835\udc58\u2605\u22121,whichtranslatestothedesired\nresult:\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d)\u2229C(\u210e)+2\ud835\udc58\u2605+2\u2265 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d)\\C(\u210e).\nProof. Inthefollowing,wenarrowtheimplicitcontexttobe\nC\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e).\nBydefinitionofaUMCitneedstobeshownthateveryblock For a non-chain block \ud835\udc4f \u2208 C(\u210e)\n\\\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\u210e), denote \ud835\udc5d =\ninC(\u210e) hasboundednegativescore (withinthecontext).More max\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\u210e) \u27e8d \u2229\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4f).Plugging\ud835\udc351 = \u210e,\ud835\udc35 \ud835\udc5b = \ud835\udc5d,\ud835\udc35 = \ud835\udc4f into\nformally,weneedtoshowthatforeveryblock\ud835\udc4f \u2208C(\u210e),itholds Lemma 3 we getthat \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f) \u2229C(\u210e) +2\ud835\udc58\u2605 \u2265 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d) \u2229\nthat\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f)\u2229C(\u210e)+4\ud835\udc58\u2605+2\u2265 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f)\\C(\u210e). C(\u210e).CombiningwithClaim6.1.1weconcludethat\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f)\u2229\nIntuitively,whileblocksbeforeandduringthestartoftheburst C(\u210e) +4\ud835\udc58\u2605+2 \u2265 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d) \u2229C(\u210e) +2\ud835\udc58\u2605+2 \u2265 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d) \\\nenjoy the natural advantage of the burst, for blocks following C(\u210e) > \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f)\\C(\u210e);wherethatlastinequalityfollowsfrom\n\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52(d)amoresophisticatedargument,usingthecontradiction \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5d) \u2283 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f).\nhypothesis,isrequired.Wethusbeginbyprovingatighterresultfor Itremainstoprovetheboundforblocksbeforeandduringthe\nchainblocksminedafter\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52(d),subsequentlyusingittoprove startoftheburst.Forablock\ud835\udc4f \u2208 C(\u210e)\n,wehavefromeventtheboundforallblocksinC(\u210e)\n. sequenceE\ud835\udc61,\ud835\udc4d that\ud835\udc4e\ud835\udc51\ud835\udc63(s) \u2264\ud835\udc360 ,thusbydefinition\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f)",
    "source":"whitepaper",
    "section":"thefirstinequalityandsummingtheexpressionsweobtain (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":123.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_58",
    "content":"# thefirstinequalityandsummingtheexpressionsweobtain (Part 2)\n\n--- Page 15 ---\nTheDAGKNIGHTProtocol:AParameterlessGeneralizationofNakamotoConsensus\nC(\u210e)+\ud835\udc360 \u2265 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f)\n\\C(\u210e).Additionally,byconstructionof Proof. Recallthatafter(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e) <\ud835\udc4d+C(\u210e)\n\u2212C(\u210e)\ntheburstevent,\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f) \u27e8s,d\u27e9 \u2229C(\u210e)=\ud835\udc360+\ud835\udc4d > \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f) \u27e8s,d\u27e9 \\ Reorganizingtermsweobtainthatafter(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e)+C(\u210e)\nC(\u210e) = 0.Finally,sinceafter(\u210e) < C(\u210e)\n\u2212 C(\u210e)\n,itfollows \ud835\udc4d+C(\u210e)\n;notingthatbydefinition\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e)\n\\C(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e)=\nthat\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f) \u27e8d \u2229C(\u210e) \u2265 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f) \u27e8d \\C(\u210e).Summingoverall C(\u210e) \u27e8e +after(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e)wederivethat\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e) \u27e8e \\C(\u210e)\\\ntimeperiodswegetthat\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f)\u2229C(\u210e) \u2265 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f)\\C(\u210e), \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e) <C(\u210e) +\ud835\udc4d.\nasclaimed. Define\ud835\udc5a (cid:66) C(\u210e) ,\ud835\udc62 (cid:66) \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e) \\ C(\u210e) \\ \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e) \\\n\u27e8e \u27e8e\nForblocks\ud835\udc4f \u2208C(\u210e) \u27e8s,d\u27e9 ,similarargumentshold. \u25a1 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5e)and\ud835\udc63 (cid:66) C\ud835\udc58 (\ud835\udc5e)\n.Wegetthat\ud835\udc62 \u2264\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e)\n\\C(\u210e)\\\n\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e) <C(\u210e) +\ud835\udc4d =\ud835\udc5a+\ud835\udc4d.Adding\ud835\udc62tobothsideswehave\nClaim6.2. \u2200\ud835\udc5e \u2208 \ud835\udc4e\ud835\udc5b\ud835\udc61\ud835\udc56\ud835\udc50\ud835\udc5c\ud835\udc5b\ud835\udc52(\u210e)\u2229A,\u2200\ud835\udc58 \u2264 \ud835\udc4d\u2212 4 5\ud835\udc58\u2605 ,C\ud835\udc58 (\ud835\udc5e) isnota 2\ud835\udc62 <\ud835\udc5a+\ud835\udc62+\ud835\udc4d \u2264\ud835\udc5d \u27e8 \ud835\udc4e e \ud835\udc60\ud835\udc61(\ud835\udc4e) \u27e8e \\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5e)+\ud835\udc4d.\n\ud835\udc4d\u2212 4 5\ud835\udc58\u2605 -UMCofC\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5e). FromClaim6.2.1wehavethatC\ud835\udc58 (\ud835\udc5e) \u27e8e \u2264\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e) \u27e8e \\C(\u210e) \u27e8e .\nNoting that\ud835\udc63 = C\ud835\udc58 (\ud835\udc5e)\n\u2264 \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e)\n\\C(\u210e)\n\u2282 \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e)\nProof. WeseektoshowtheexistenceofaweakblockinC\ud835\udc58 (\ud835\udc5e) C(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5e) =\ud835\udc62,wegetthat\ud835\udc63 \u2264\ud835\udc62.Thus2\ud835\udc63 <\nwhichhasnegativescoregreaterthan \ud835\udc4d\u2212 4 5\ud835\udc58\u2605,thusdisobeyingthe \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e) \u27e8e \\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5e)+\ud835\udc4d.Reorganizingtermsandnotingthat\ud835\udc63 \u2282\nUMCrequirement.Weshowthisoveramaximalpre-burstblock \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e) \u27e8e \\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5e),weconcludethatC\ud835\udc58 (\ud835\udc5e) \u27e8e < \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e) \u27e8e \\\nintheintersectionC(\u210e)\u2229C\ud835\udc58 (\ud835\udc5e). C\ud835\udc58 (\ud835\udc5e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5e)+\ud835\udc4d,asclaimed. \u25a1",
    "source":"whitepaper",
    "section":"thefirstinequalityandsummingtheexpressionsweobtain (Part 2)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":152.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_59",
    "content":"# Webeginbyshowingthattheattackercannoteffectivelyfreeload (Part 1)\n\nfollowingtheburstevent.Tothatend,weshowinthefollowing Tocompletetheargument,wedeterminetheattacker\u2019sweak\nclaimthatC\ud835\udc58 (\ud835\udc5e)\nisboundedinsizebythenumberofblocksout block. Let \ud835\udc64 (cid:66) maxC(\u210e)\ud835\udf19\u27e9 \u2229 C\ud835\udc58 (\ud835\udc5e)\ud835\udf19\u27e9 (this intersection is\nofC(\u210e)\n. not empty as it contains \ud835\udc54). If \ud835\udc64 \u2208 after(s), then \ud835\udc64 \u2208 B, so\nClaim6.2.1. C\ud835\udc58 (\ud835\udc5e) \u27e8e \u2264\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e) \u27e8e \\C(\u210e) \u27e8e .\n\ud835\udc62\ud835\udc5f\ud835\udc52\n\ud835\udc62\ud835\udc61\ud835\udc62\n).W\nt d h e e fi P F n p o r r e r o o o t a o h f f c e . i o s m F u i i n r m o s t r i t m e n , e g i c n d o p i m t a r h t o p e e c le e s s x i s i n m s c c a p a e n s le C e d , \ud835\udc58 c r w a ( e s \ud835\udc5e h a e ) c e \u27e8 h w r e e h t \u2286 h C e e \ud835\udc58 r \ud835\udc5d e \ud835\udc4e d (\ud835\udc5e \ud835\udc60 C e \ud835\udc61 ) s \ud835\udc58 i \u27e8 ( r e \ud835\udc5e ( e \ud835\udc5e ) \u2229 d ) \u27e8e \u27e8 r C e e \\ s \u2229 ( C \u210e u ) l C ( t \u27e8 \u210e e ( u ) \u210e s \u2260 \u27e8 ) i e n \u27e8 . e \u2205 g , = t w h \u2205 e e w f j \ud835\udc53 o r \ud835\udc62 e o in \ud835\udc61 m h \ud835\udc62 t a , \ud835\udc5f t v e \ud835\udc52 h e v ( u e t \ud835\udc64 s h n ) a \ud835\udc53 t s - t \ud835\udc62 \u27e9 s \ud835\udc53 \ud835\udc61 e \u2229 \ud835\udc62 \ud835\udc62 q \ud835\udc5f C \ud835\udc61 u \ud835\udc62 \ud835\udc52 e ( \ud835\udc5f ( n \u210e \ud835\udc52 \ud835\udc64 c ) ( e ) + \ud835\udc64 s \ud835\udc36 E \u27e9 ) \\ 0 s \ud835\udc61, \u27e9 C \ud835\udc4d \u2265 \u2229 \ud835\udc58 t C \ud835\udc53 ( h \ud835\udc5e \ud835\udc62 ( a ) \ud835\udc61 \u210e t \ud835\udc62 + ) \ud835\udc4e \ud835\udc5f \ud835\udc36 a \ud835\udc51 \ud835\udc52 n 0 \ud835\udc63 ( d \ud835\udc64 \u2265 ( \ud835\udc53 s ) ) \ud835\udc62 \ud835\udc53 s \ud835\udc62 \ud835\udc61 \u27e9 \u2264 \ud835\udc62 \\ \ud835\udc61\ud835\udc62 \ud835\udc5f C \ud835\udc52 \ud835\udc36 \ud835\udc5f\ud835\udc52 ( 0 ( \u210e \ud835\udc64 , ( ) \ud835\udc64 t ) . h s F ) u \u27e9 s r \u2229 s \u27e9 o \u2229 m C b \ud835\udc58 y C m ( d ( \ud835\udc5e a \u210e e x ) ) fi i a + m n r \ud835\udc36 i e a t 0 l i d i o t i \u2265 n y s- ,\nbound\ud835\udc58 \u2264 \ud835\udc4d\u22125\ud835\udc58\u2605. \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc64) s\u27e9 \\C(\u210e) \u2265 \ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc64) s\u27e9 \u2229C\ud835\udc58 (\ud835\udc5e).Noticing(again,by\nfoll D o e w fi i n ng e w a a s y e 4 q : uenceofchainblocks\ud835\udc5e = \ud835\udc5e0,...,\ud835\udc5e \ud835\udc5b \u2208 A inthe m th a a x t i \ud835\udc53 m \ud835\udc62 a \ud835\udc61 l \ud835\udc62 it \ud835\udc5f y \ud835\udc52 ) (\ud835\udc64 th ) a \ud835\udf19 t \u27e9 al \u2229 l\ud835\udc36 C 0 \ud835\udc58 b ( l \ud835\udc5e o ) c \u2212 ks \ud835\udc53 o \ud835\udc62 f \ud835\udc61 B \ud835\udc62\ud835\udc5f \u27e8 \ud835\udc52 s,\ud835\udf19 (\ud835\udc64 \u27e9 a )\ud835\udf19 re \u27e9 n \\ o C t \ud835\udc58 in (\ud835\udc5e C ) \ud835\udc58 \u2264 (\ud835\udc5e \ud835\udc36 ) 0 w \u2212 e \ud835\udc36 o 0 bt = ain 0.\nSince\ud835\udc5e \u2208 AwehavefromClaim5thatC\ud835\udc58 (\ud835\udc5e)\u2229B \u27e8\ud835\udf19 \u2264 2\ud835\udc58 \u2264\n\u2022 \u2022 \ud835\udc5d D G \ud835\udc4e i e v \ud835\udc60 n \ud835\udc61 e o n ( t \u0394 e \ud835\udc5e \ud835\udc56 \u0394 \ud835\udc56 \u2212 \u2212 1 \ud835\udc56 1 \u2212 ) , . 1 if (cid:66) \u0394 \ud835\udc56 C \u22121 (\u210e \u2260 )\u2229 \u2205, C s \ud835\udc58 el ( e \ud835\udc5e c ) t \u2229 \ud835\udc5e \ud835\udc56 \ud835\udc5a t \ud835\udc52 o \ud835\udc5f\ud835\udc54 b \ud835\udc52 e \ud835\udc60\ud835\udc52 m \ud835\udc61 a ( x \ud835\udc5e \ud835\udc50 \ud835\udc56\u2212 \u210e 1 \ud835\udc4e ) \ud835\udc56\ud835\udc5b(\ud835\udc5e \ud835\udc56\u22121)\u2229 w \u2212 \ud835\udc4d 3 e \u2212 \ud835\udc4d 2 5 g \ud835\udc58 e + \u2605 t . \ud835\udc4d th N \u2212 a o t t 5 \ud835\udc53 i \ud835\udc58 n \ud835\udc62 \u2605 g \ud835\udc61\ud835\udc62 \u2264 t \ud835\udc5f h \ud835\udc52 \u2212 a ( t 2 \ud835\udc64 \ud835\udc4d th ) . \u27e8 e \ud835\udf19, r e e \u27e9 m \u2229 a C in \ud835\udc58 d ( e \ud835\udc5e r ) o \u2212 f \ud835\udc53 th \ud835\udc62 e \ud835\udc61\ud835\udc62 b \ud835\udc5f u \ud835\udc52 r ( s \ud835\udc64 t ) is \u27e8\ud835\udf19 n ,e o \u27e9 t \\ i C n \ud835\udc58 C ( \ud835\udc58 \ud835\udc5e) (\ud835\udc5e \u2264 )\n\u2022 Otherwiseif\u0394 \ud835\udc56\u22121 = \u2205,select\ud835\udc5e \ud835\udc56 tobemax\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc5e \ud835\udc56\u22121) s.t. UsingClaim6.2.2andsummingoveralltimeperiodsweget\nhablockexists,or\n\ud835\udc52(\ud835\udc64)\u2229C\ud835\udc58 (\ud835\udc5e)\u2212\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc64)\\C\ud835\udc58 (\ud835\udc5e) <\u2212\ud835\udc4d <\u2212 \ud835\udc4d\u2212\n5\ud835\udc58\u2605,asw\n\u2022 If\ud835\udc5e \ud835\udc56 \u2208before(\ud835\udf19),halttheprocessandset\ud835\udc5b=\ud835\udc56.\nItistruebyconstructionthat(cid:208)(cid:164)\ud835\udc5b\n\ud835\udc56=1 \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e \ud835\udc56\u22121) \u27e8e \\\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e \ud835\udc56) \u27e8e is Toconclude,itremainstoset\ud835\udc4d largeenoughs.t.4\ud835\udc58\u2605\u2264 \ud835\udc4d\u22125\ud835\udc58\u2605\napartitioningof\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e) .Itthusremainstoshowthatforeach 4\npartition\ud835\udc56,C\ud835\udc58 (\ud835\udc5e)\u2229\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e \u27e8 \ud835\udc56 e \u22121)\\\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e \ud835\udc56) \u2264\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e \ud835\udc56\u22121)\\\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e \ud835\udc56)\\ a R n e d ca t l h l u t s h \u2200 a \ud835\udc5e t \u2208 \ud835\udc53\ud835\udc62 \ud835\udc4e \ud835\udc61 \ud835\udc5b \ud835\udc62 \ud835\udc61 \ud835\udc5f \ud835\udc56\ud835\udc50 \ud835\udc52 \ud835\udc5c ( \ud835\udc5b \u210e \ud835\udc52 ) ( \u2229 \u210e) \ud835\udc5d \u2229 \ud835\udc4e A \ud835\udc60\ud835\udc61 , ( \ud835\udc5f \ud835\udc4e \ud835\udc4e ) \ud835\udc5b\ud835\udc58 \u2229 \ud835\udc5d\ud835\udc4e A \ud835\udc60\ud835\udc61(\ud835\udc4e = ) (\u210e \u2205 ) , < so \ud835\udc5f\ud835\udc4e b \ud835\udc5b y \ud835\udc58 \ud835\udc5d d \ud835\udc4e e \ud835\udc60\ud835\udc61 fi ( n \ud835\udc4e i ) ti ( o \ud835\udc5e n ).\nC(\u210e).\nForthefirstcasewhere\u0394 \ud835\udc56\u22121\u2260\u2205,let\ud835\udc4fbeanyelementof\u0394\n\ud835\udc56\u22121\n. \ud835\udc61\n\ud835\udc5f\ud835\udc4e\ud835\udc5b\nP b C e l \ud835\udc58 u s ( g h \ud835\udc5e g o ) i w n \u2229 g n \ud835\udc5d\ud835\udc4e \ud835\udc35 ( \ud835\udc60 f 1 r \ud835\udc61 o ( = m \ud835\udc5e \ud835\udc56\u2212 \ud835\udc5e m 1 \ud835\udc56\u2212 i ) n 1 \\ i , m \ud835\udc5d \ud835\udc35 \ud835\udc4e \ud835\udc5b a \ud835\udc60 l \ud835\udc61 i = t ( y \ud835\udc5e \ud835\udc5e o \ud835\udc56) \ud835\udc56 f , \u210e \u2264 \ud835\udc35 ,\ud835\udc4e 4 = \ud835\udc58 an \u2264 \ud835\udc4f d \ud835\udc4d i f n r \u2212 t o o m 5\ud835\udc58 L b \u2605 e l m . o A c m k d a - d r i a 2 ti c o w e n c e a o ll g n y e d , t i i t t t i c h o a a n n t ) \ud835\udc5f th \ud835\udc4e a \ud835\udc5b t \ud835\udc58 \ud835\udc5d \ud835\udc5f \ud835\udc4e \ud835\udc52 \ud835\udc60 \ud835\udc5d \ud835\udc61 \ud835\udc60 (\ud835\udc4e ( ) P ( \ud835\udc56 \u210e ) ),c \u2286 on \ud835\udc4e tr \ud835\udc5b a \ud835\udc61 d \ud835\udc56\ud835\udc50 ic \ud835\udc5c t \ud835\udc5b in \ud835\udc52 g (\u210e \ud835\udc4e ) \u2208 \u2229 A A , , si t n h c u e s \ud835\udc4e \ud835\udc5f m \ud835\udc4e\ud835\udc5b u \ud835\udc58 s \ud835\udc5d t \ud835\udc4e s \ud835\udc60 e \ud835\udc61 l ( e \ud835\udc4e c ) t ( a P c \ud835\udc56 h ) ai > n\nparentfromP\\A. \u25a1\nthat\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e \ud835\udc56\u22121)\u2229after(\ud835\udc4f)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc4f) \u2265\ud835\udc4d\u22124\ud835\udc58\u2605,thus\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e \ud835\udc56\u22121)\\\n\\ C",
    "source":"whitepaper",
    "section":"Webeginbyshowingthattheattackercannoteffectivelyfreeload (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":1125.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_60",
    "content":"# ass\n\n",
    "source":"whitepaper",
    "section":"ass",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":0.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_61",
    "content":"# ies\n\nInthesecondcasewhere\u0394 \ud835\udc56\u22121=\u2205,theresultisimmediatesince\ntheactualcolouringalgorithm.Wefirstdealwiththecasewherethe",
    "source":"whitepaper",
    "section":"ies",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":3.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_62",
    "content":"# cti\n\nC\ud835\udc58 (\ud835\udc5e) \u2229\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e \ud835\udc56\u22121) \\\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e \ud835\udc56) \u2286 \ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc5e \ud835\udc56\u22121) \\\nrecursivecallwithinK-Colouringhasneversetfree_search=\ud835\udc61\ud835\udc5f\ud835\udc62\ud835\udc52.\n\u25a1 Thismeansthat\u2200\ud835\udc4e \u2208 A,\ud835\udc58-chain(\ud835\udc4e) \u27e8d \u2282 A,thusallinequalities\nintheaboveprooftriviallyhold.",
    "source":"whitepaper",
    "section":"cti",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":19.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_63",
    "content":"# The more challenging case is the one where a recursive call\n\nWeproceedbyusingtheabovetoshowthatC\ud835\udc58 (\ud835\udc5e)hassmaller\nthan\ud835\udc4d advantagewithinpost-burstblocks.\ntoK-Colouringswitchestofree_search=\ud835\udc61\ud835\udc5f\ud835\udc62\ud835\udc52(line10),henceby\nthatallowingtheattackerto\u201cinherit\u201dthehonestcolouring.Observe\nClaim6.2.2. C\ud835\udc58 (\ud835\udc5e) \u27e8e <\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e) \u27e8e \\C\ud835\udc58 (\ud835\udc5e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\ud835\udc5e)+\ud835\udc4d. thatthiscanonlyhappenif\ud835\udc58 >\ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc58 \ud835\udc3a (\ud835\udc36),thusimplicitlyforcing\n\n--- Page 16 ---",
    "source":"whitepaper",
    "section":"The more challenging case is the one where a recursive call",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":22.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_64",
    "content":"# MichaelSuttonandYonatanSompolinsky (Part 1)\n\narankincrease.Thefollowingextendedargumentcapturesexactly We first observe that at the starting point, i.e., at time \ud835\udc60 =\nthisproperty: \ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52(e), it holds by construction of the burst event that \ud835\udf19 \u2208\nClaim7. (generalizedmainclaim)Conditionedontheoccurrence\n\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc60).Assumeforcontradictionthereexistsaminimal\nofevent-sequenceE\ud835\udc61,\ud835\udc4d,itholdsthatforany\u210e\u2208H\ud835\udc50\\A,andforany\ntime\ud835\udc60 >\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52(e)s.t.\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59\n\u2208A.\nWewillusethepropertiesoftheevent-sequence(specifically,\n\ud835\udc4e\u2208Amerging\u210e,\nblockracewinandtheinitialburstadvantage)toprovideanupper\n\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e)\u2229after(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e)\nboundon\ud835\udc3a\n\ud835\udc60\u22121\nandalowerboundon\ud835\udc3a\n,andarriveatacontradiction.\n\u2265C(\u210e) \u27e8d \u2212 C(\u210e) \u27e8d (1) From minimality of \ud835\udc60, there exists a block \u210e \u2208 H\ud835\udc50 \\ A s.t.\n+max(cid:0)0,4\ud835\udc58\u2605 \u2212\ud835\udc5f\ud835\udc4e\ud835\udc5b\ud835\udc58 \ud835\udc3a (\ud835\udc4e)(cid:1)\u00b7\ud835\udc4d. \ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc60\u22121 \u21d2\u210e.Additionally,fromblock-racewinwehavethat\nAfullproofofthisclaimwillappearinafutureversionofthe C(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc60\u22121) \u2265 C(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc60\u22121), thus 2C(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc60\u22121) \u2265 \ud835\udc3a \ud835\udc60\u22121 ,\npaper.\nwhichleadsto2C(\u210e)+2\ud835\udc58\u2605\u2265\ud835\udc3a\n\ud835\udc60\u22121\nOntheotherhand,attime\ud835\udc60,let\ud835\udc4e\u2208Abethemergingblockof\nToconcludetheproofofTheorem2,thefollowingCorollary\nshowsthat,indeed,followingevent-sequenceE\ud835\udc61,\ud835\udc4d ,theattacker\n\u210e(beitany\ud835\udc4e\u2208\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc60)or\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59\nitself),thenbyClaim6\ncanneverregainanadvantage:\nitholdsthat\ud835\udc5d\ud835\udc4e\ud835\udc60\ud835\udc61(\ud835\udc4e)\u2229after(\u210e)\\\ud835\udc53\ud835\udc62\ud835\udc61\ud835\udc62\ud835\udc5f\ud835\udc52(\u210e) \u2265\ud835\udc4d +C(\u210e)\u2212 C(\u210e).\nCorollary8. Conditionedontheoccurrenceofevent-sequenceE\ud835\udc61,\ud835\udc4d,\nItfollowsthat\ud835\udc3a\n\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52(\u210e)\n+C(\u210e)\u2212 C(\u210e)+\ud835\udc4d =C(\u210e)+ C(\u210e)+\ntheattackercannotreorgbelowtheburstevent.Moreformally,\u2200\ud835\udc60 \u2265\nC(\u210e)\u2212 C(\u210e)+\ud835\udc4d =2C(\u210e)+\ud835\udc4d.\n\ud835\udc61\ud835\udc56\ud835\udc5a\ud835\udc52(e),\ud835\udf19 \u2208\ud835\udc50\u210e\ud835\udc4e\ud835\udc56\ud835\udc5b(\ud835\udc63\ud835\udc56\ud835\udc5f\ud835\udc61\ud835\udc62\ud835\udc4e\ud835\udc59 \ud835\udc60). 17\n\ud835\udc4d \u2212",
    "source":"whitepaper",
    "section":"MichaelSuttonandYonatanSompolinsky (Part 1)",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"section_part",
    "word_count":117.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"whitepaper_The DAG KNIGHT Protocol_Feb23_2023_65",
    "content":"# tra\n\n\ud835\udc60\u22121\u22652C(\u210e)\nProof. All sets within the current proof are implicitly intersectedwithafter(e). 17Equivalently:H\ud835\udc50\u2229A=\u2205.",
    "source":"whitepaper",
    "section":"tra",
    "url":null,
    "filename":"The DAG KNIGHT Protocol_Feb23_2023",
    "chunk_type":"complete_section",
    "word_count":12.0,
    "pdf_pages":16.0,
    "extraction_method":"pdfplumber",
    "pdf_path":"..\/data\/whitepapers\/The DAG KNIGHT Protocol_Feb23_2023.pdf"
  },
  {
    "id":"twitter_x_0",
    "content":"A common misconception about Kaspa ($KAS) is that there are missing transactions for the first six months of the ledger. Here are the facts:",
    "source":"twitter_discussions",
    "section":"Discussion Point 1",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"twitter_x_1",
    "content":"100% of all the data has been recovered for anything after February 10, 2022 (Kaspa launched in November 2021). Additionally, 75% of all the data has been recovered for the period between the launch and February 10, 2022. While 25% remains missing, there is sufficient data to consider this a non-issue.",
    "source":"twitter_discussions",
    "section":"Discussion Point 2",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"twitter_x_2",
    "content":"The genesis block can be found at the following link: [Genesis Block](https:\/\/explorer.kaspa.org\/blocks\/caeb97960a160c211a6b2196bd78399fd4c4cc5b509f55c12c8a7d815f7536ea). The earliest mined block is available here: [Earliest Mined Block](https:\/\/explorer.kaspa.org\/blocks\/d884013dc7b892b793f1f261432fa7de504be574d4f327b1a7a9379a630b96b3).",
    "source":"twitter_discussions",
    "section":"Discussion Point 3",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"twitter_x_3",
    "content":"Concerns have been raised regarding the missing transactions, particularly about the implications of a single entity potentially pre-mining and splitting this into multiple wallets without detection. However, the missing transactions account for roughly 5% of the total diluted supply, which is approximately 1.4 billion Kaspa. Even if the transaction data were available, it would not necessarily prove or disprove that a single entity mined the entire supply, as miners can distribute their coins across multiple addresses.",
    "source":"twitter_discussions",
    "section":"Discussion Point 4",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"twitter_x_4",
    "content":"The missing block data is not contiguous. Due to the efforts of community members to collect and archive old data directories, the missing data is sporadic and randomly scattered among the blocks produced during the first few weeks. Therefore, even if an entity had pre-mined and mined all their coins into a single address, that address would be visible in all the coinbase transactions of the recovered blocks.",
    "source":"twitter_discussions",
    "section":"Discussion Point 5",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"twitter_x_5",
    "content":"Kaspa\u2019s architecture increases bandwidth and orphan risk requirements for full nodes, which may limit the number of individuals who can validate the network independently, potentially leading to centralization. Unlike Bitcoin, which employs a layered approach similar to the internet, Kaspa's fast emission schedule results in steep declines in block rewards by 2028. Unless transaction fees rise significantly, the long-term assumptions of this model may break down, as the cost for an attacker to launch a 51% attack decreases over time compared to Bitcoin.",
    "source":"twitter_discussions",
    "section":"Discussion Point 6",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"twitter_x_6",
    "content":"In terms of node requirements as of 2025, the following comparisons can be made:",
    "source":"twitter_discussions",
    "section":"Discussion Point 7",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"twitter_x_7",
    "content":"- **Bitcoin Full Node (Pruned)**: ~10\u201320 GB disk space, ~1\u20132 GB RAM, low bandwidth requirements, very high accessibility.\n- **Kaspa Full Node (Archival)**: ~40\u2013100 GB+ disk space, 8\u201316 GB+ RAM, medium to high bandwidth requirements, decreasing accessibility.\n- **Kaspa Full Node (Pruned)**: ~10\u201325 GB disk space, 4\u20138 GB+ RAM, medium bandwidth requirements, mixed accessibility.\n- **Ethereum Archival Node**: 2\u20135 TB+ disk space, 32 GB+ RAM, high bandwidth requirements, very low accessibility.\n- **Ethereum Full Node (Pruned)**: ~500 GB+ disk space, 8\u201316 GB RAM, high bandwidth requirements, limited accessibility.",
    "source":"twitter_discussions",
    "section":"Discussion Point 8",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"twitter_x_8",
    "content":"Kaspa's pruning does reduce disk space, which is beneficial, but it does not reduce the validation load. The high block rate and DAG logic mean that higher CPU and bandwidth needs remain. While pruning can lower disk usage, it is still not as accessible or lightweight as Bitcoin, especially for users on older hardware or low-bandwidth networks.",
    "source":"twitter_discussions",
    "section":"Discussion Point 9",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"twitter_x_9",
    "content":"Kaspa's design choices prioritize decentralization, security, and throughput. The project has no corporate issuer, no pre-mine, and no venture capital allocation, which fosters a grassroots Proof-of-Work community. The consensus mechanism, GHOSTDAG, allows for multiple blocks to be created concurrently while maintaining a consistent order, thus enabling high throughput without sacrificing decentralization.",
    "source":"twitter_discussions",
    "section":"Discussion Point 10",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"twitter_x_10",
    "content":"Critics often misunderstand Kaspa's architecture, equating speed with centralization and overlooking the unique properties of its BlockDAG structure. The project aims to maintain a lean base layer focused on sound money properties, allowing for the development of Layer 2 solutions without bloating the primary layer.",
    "source":"twitter_discussions",
    "section":"Discussion Point 11",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"twitter_x_11",
    "content":"In summary, Kaspa is designed to address the limitations of traditional blockchain architectures while ensuring decentralization and security. The project continues to evolve, focusing on community-driven development and open-source contributions.",
    "source":"twitter_discussions",
    "section":"Discussion Point 12",
    "url":null,
    "filename":"x",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_0",
    "content":"This is a blog series explaining the fundamentals of Kaspa in simple and concise language. I will assume the least possible prior knowledge, although some fundamentals in blockchain theory, specifically Bitcoin, may benefit the reader.",
    "source":"generic",
    "section":"Section 1",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_1",
    "content":"Kaspa is a pure Proof of Work (PoW) engine that generalizes and scales Bitcoin\u2019s blockchain paradigm.",
    "source":"generic",
    "section":"Section 2",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_2",
    "content":"The first change Kaspa introduces is the block-DAG mining paradigm. In Bitcoin, miners first select the longest (or, to be precise, the heaviest) chain and mine over its top-most block, also known as the selected tip. Essentially, miners do not share the full information they have; they do not share the knowledge of other non-selected chains they know of and chose not to mine over.",
    "source":"generic",
    "section":"Section 3",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_3",
    "content":"In contrast, in the block-DAG paradigm, all information is revealed. This is referred to as \u201cthe revelation principle.\u201d The miner references all tips they know of. Consequently, any protocol can be run to make choices based on this knowledge, including, for instance, the longest chain rule. However, the maximization of shared knowledge opens many more opportunities.",
    "source":"generic",
    "section":"Section 4",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_4",
    "content":"By having each miner mine over all known blocks, a maximal amount of time relations (e.g., this block was mined \u201cafter\u201d this block) is revealed and shared. Each miner mining over many block tips (referencing all their hashes in its header) creates a directed graph of blocks with a link pointing from a block to each of the referenced blocks. The cryptographic irreversibility of the PoW function implies that no cycles can be created in this directed graph, making it a Directed Acyclic Graph (DAG).",
    "source":"generic",
    "section":"Section 5",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_5",
    "content":"In block-DAG terminology, the set of blocks referenced by block B is denoted as parents(B). The set past(B) is the set of blocks reachable from block B through a chain of parent links (coined \u201cpast\u201d because we know they existed before B). Note that past(B) is never empty since it always contains genesis, which is the initial block defining the beginning of the DAG. Likewise, future(B) is the set of blocks that B is reachable from. The set anticone(B) is the set of blocks \u201cparallel\u201d to B, i.e., not in its past nor in its future. Essentially, no time causality information is known between B and blocks in anticone(B). It is called \u201canticone\u201d because both past and future can be seen as \u201ccones\u201d from B\u2019s perspective.",
    "source":"generic",
    "section":"Section 6",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_6",
    "content":"Before delving into the specifics of the GHOSTDAG protocol, which is the ordering protocol used by Kaspa, I will describe a general structure for ordering a block-DAG based on any parent selection rule.",
    "source":"generic",
    "section":"Section 7",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_7",
    "content":"Assume a parent selection function f mapping from each block B to one of its parents P. The sub-DAG containing only these special \u201cselected\u201d links (from every block B to its selected parent) is, in fact, a tree. Let\u2019s name a special non-existing block called \u201cvirtual,\u201d which always points at all DAG tips\/leaves. This virtual block represents the next mined block in the eyes of the local node.",
    "source":"generic",
    "section":"Section 8",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_8",
    "content":"The mapping function f can be applied on virtual in order to select a specific DAG tip. We can then walk down starting from this tip through the \u201cselected parent\u201d links until reaching genesis. Thus, a mapping f can be translated to selecting a chain C of blocks starting from virtual and ending at genesis.",
    "source":"generic",
    "section":"Section 9",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_9",
    "content":"This chain can be used to deterministically order the complete DAG structure.",
    "source":"generic",
    "section":"Section 10",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_10",
    "content":"To accomplish this task, we need one more definition. Let\u2019s define the mergeset of B, mergeset(B), to be the set of blocks that B merged into the DAG. Formally, this is the set of blocks which are in past(B) but not in the past of B\u2019s selected parent as chosen by the mapping function f. It\u2019s called a merge-set because it\u2019s the set of blocks that B merged into the DAG from its perspective relative to its selected parent perspective.",
    "source":"generic",
    "section":"Section 11",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_11",
    "content":"Given a chain C and the definition of a mergeset, we are ready to describe a complete ordering rule based on f. The idea is to start from genesis and walk up this chain, where at each chain block we add its merge-set to the ordering. Intuitively, the chain here acts as a spine of the DAG, where the merge-sets are layers added one after the other. From the definition of a mergeset and its relation to the preceding chain block, it follows that all mergesets are disjoint sets and that their union covers the entire DAG.",
    "source":"generic",
    "section":"Section 12",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_12",
    "content":"The following pseudo-code describes this process:",
    "source":"generic",
    "section":"Section 13",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_13",
    "content":"```\nfunction Order-DAG(G):\n    let C be the chain obtained by applying f on DAG G as described\n    ordering = []\n    for block B in C walking up from genesis up to virtual:\n        ordering.Add(mergeset(B))\n    return ordering\n```",
    "source":"generic",
    "section":"Section 14",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_14",
    "content":"Understanding the relation between a chain and DAG ordering helps reason about the relationship between a chain selection protocol and the security properties required from a secure ordering protocol.",
    "source":"generic",
    "section":"Section 15",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_15",
    "content":"For a block-DAG representing a transaction ledger, we want the ordering of the DAG to be \u201crobust\u201d in the sense that only a small set of blocks near the tips of the DAG might change their order. In other words, we want the ordering to \u201cstabilize\u201d for any block mined \u201cenough\u201d time ago, where \u201cenough\u201d depends on the amount of certainty required.",
    "source":"generic",
    "section":"Section 16",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_16",
    "content":"Because ordering is governed by a chain, it follows that if the chain is \u201crobust,\u201d i.e., does not change up to a suffix, then the DAG ordered by it is robust as well. Thus, all we need now is a secure way to find a robust chain\u2014a secure parent mapping function f.",
    "source":"generic",
    "section":"Section 17",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_17",
    "content":"In the following post, I will write about the special parent selection function f = GHOSTDAG and will provide more rigorous definitions for related terms used in Kaspa, such as \u201cblue score,\u201d \u201cblue work,\u201d etc.",
    "source":"generic",
    "section":"Section 18",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_MIchael_Sutton_Kaspa 101 - Part 1_18",
    "content":"I chose to explain the chain structure first because I think it\u2019s crucial to understand this decomposition for gaining a clear understanding of the Kaspa system. Regardless of the function f used, this chain structure is utilized by our UTXO algebra infrastructure and also plays a role in the framework we implemented for supporting DAG reachability queries.",
    "source":"generic",
    "section":"Section 19",
    "url":null,
    "filename":"MIchael_Sutton_Kaspa 101 - Part 1",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_0",
    "content":"In the previous discussion, I explained Bitcoin forks and 51% attacks, introducing the throughput-security trade-off that Bitcoin faces. Increasing the block size can lead to more forks and reduce the reorganization attack threshold to less than 50% of the hashing power. In this post, I will explain how we can circumvent this problem and increase throughput without compromising security.",
    "source":"generic",
    "section":"Section 1",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_1",
    "content":"**Introducing BlockDAGs**",
    "source":"generic",
    "section":"Section 2",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_2",
    "content":"The issue with forks is that their work could be used to secure the main chain, but instead, it is wasted and ignored. To solve this problem, we need to harness their work so they can help us face attackers. Directed Acyclic Graphs (DAGs) come to the rescue. A DAG is a graph where every node can point to any number of existing nodes. We can intuitively see how DAGs can help us solve the fork problem: if the main chain could point to the forked blocks, their work would not be discarded when facing an attacker.",
    "source":"generic",
    "section":"Section 3",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_3",
    "content":"In the blockDAG paradigm, the mining protocol differs slightly. Every miner must build blocks that extend all of the tips they are aware of (the DAG tips are the blocks that do not have any children).",
    "source":"generic",
    "section":"Section 4",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_4",
    "content":"One of the first questions that arise when dealing with blockDAGs is: How should the blocks and transactions be ordered? Because the DAG can have many parallel blocks that may include conflicting transactions, we need to find a deterministic way to order them. The ordering mechanism should take attackers into account, ensuring that if there are any transaction conflicts, the attacker blocks will come last.",
    "source":"generic",
    "section":"Section 5",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_5",
    "content":"To achieve this, we can adapt the longest chain rule to the DAG. The simplest solution is to give precedence to blocks with a larger past size, as long as the order remains topological (parents come before their children). The past size of a block is the number of blocks in its past, meaning the number of blocks it points to directly or indirectly.",
    "source":"generic",
    "section":"Section 6",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_6",
    "content":"To sort the DAG, we first calculate the past size of each block:",
    "source":"generic",
    "section":"Section 7",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_7",
    "content":"- Block A\u2019s past size is 0 because it points to nothing.\n- Blocks B, C, and D have a past size of 1 because they point only to A.\n- Block E directly points to C and D and indirectly to A, so its past size is 3.",
    "source":"generic",
    "section":"Section 8",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_8",
    "content":"Now we start ordering the DAG recursively, from its tips to the root:",
    "source":"generic",
    "section":"Section 9",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_9",
    "content":"- Block H comes before G because H has a greater past size.\n- Block F comes before E because of F\u2019s past size.\n- Blocks B, C, and D have identical past sizes, so we can order them by their hash. Let\u2019s assume their hash order is B > C > D.\n- Block A comes first.",
    "source":"generic",
    "section":"Section 10",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_10",
    "content":"Thus, our block order is A, B, C, D, F, E, H, G. The transaction order is defined by the order of blocks, meaning if two parallel blocks, like E and F, include conflicting transactions, we can ignore the transaction from block E because F precedes it.",
    "source":"generic",
    "section":"Section 11",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_11",
    "content":"If we adapt the attack scenario from the previous discussion to a blockDAG paradigm, we see that the attacker tip B has a smaller past size (7) than the honest DAG tip A (9), so its conflicting transaction won\u2019t be recorded in the ledger.",
    "source":"generic",
    "section":"Section 12",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_12",
    "content":"However, what if the attacker changes its behavior and points to blocks of the honest DAG? In this case, the attacker\u2019s chain is built such that every block in its chain points to a block in the honest DAG. This increases its past size to the maximum while still keeping its own block as the parent with the largest past size. When we apply the same recursive ordering, we find that the attacker\u2019s blocks will always precede the honest blocks, allowing the double spend to succeed, even though the attacker created fewer blocks than the honest network.",
    "source":"generic",
    "section":"Section 13",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_13",
    "content":"To prevent attackers from using the work of honest miners, we need a way to differentiate between attacker blocks and honest blocks. The PHANTOM paper describes such a mechanism, which I will outline in the remainder of this article.",
    "source":"generic",
    "section":"Section 14",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_14",
    "content":"To define attacking blocks, we must understand what an honest blockDAG looks like. We will define a few terms to help clarify our understanding of blockDAGs.",
    "source":"generic",
    "section":"Section 15",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_15",
    "content":"From a single block\u2019s perspective, the DAG can be divided into three subsets: the block\u2019s past, future, and anticone. The block\u2019s past consists of every block it points to, or that its parents point to, and so on. Its future consists of blocks that contain the block in their past. Blocks that are neither part of the block's past nor its future\u2014those that do not belong to the two former categories\u2014define the anticone. In an honest blockDAG, the anticone of a block consists of blocks that were not known to the miner at the time of the block's creation or that were created afterward by miners who were still unaware of the new block.",
    "source":"generic",
    "section":"Section 16",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_16",
    "content":"We can intuitively say that the size of a block\u2019s anticone depends on two factors: the block creation rate (denoted as \u03bb) and the network delay (denoted as D). If we increase either factor, more miners will mine blocks before they have a chance to receive all of their peer blocks, resulting in wider DAGs. By making empirical measurements to determine the maximum delay in the network, we can calculate the maximum anticone we expect to see in an honest network.",
    "source":"generic",
    "section":"Section 17",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_17",
    "content":"For example, if we define the block creation rate as 1 block per second and the maximum observed network delay as 4 seconds, we can expect a maximum anticone size of 8 blocks. When a miner mines a block, we expect its anticone to include a maximum of 4 blocks, as this is the number of blocks that can be created during the 4 seconds of delay (any blocks created more than 4 seconds ago should already be known by the miner and pointed to, directly or indirectly, by its mined block). Another 4 seconds may pass until the block is propagated throughout the entire network. During that time, miners who are not yet aware of this block could mine another 4 blocks. Thus, we derive that the maximum anticone size of the block would be 4 + 4 = 8. As a general rule, we can say that the maximum anticone size of a block in an honest network (denoted as k) is 2D\u03bb.",
    "source":"generic",
    "section":"Section 18",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_18",
    "content":"When deciding if a block is part of the honest DAG, we need to ask ourselves, \u201cIf we add this block to the honest DAG, will any block have an anticone size greater than k?\u201d If the answer is no, we can add the block to the honest DAG. If the answer is yes, it means this kind of DAG cannot be created as part of an honest network, so it cannot be added to the current honest DAG, and we reject it unless we find another alternative honest DAG that can include it. The PHANTOM rule can be summarized as \u201cfind the biggest sub-DAG where no block has an anticone greater than k.\u201d This is a generalization of the Bitcoin longest chain rule\u2014Bitcoin can be described as PHANTOM with k=0.",
    "source":"generic",
    "section":"Section 19",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_19",
    "content":"Let\u2019s examine the same DAG from earlier but with the PHANTOM rule, using k=3. Including all of the attacker blocks will result in every other block in the DAG having an anticone of 6 blocks, which means it cannot be part of an honest DAG. The attacker blocks (except the tip) will be excluded, they won\u2019t be rewarded, and the double spend attempt will fail.",
    "source":"generic",
    "section":"Section 20",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_20",
    "content":"**Choosing the Right k**",
    "source":"generic",
    "section":"Section 21",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_21",
    "content":"Choosing the wrong k can have significant implications. If k is set too low, many blocks from honest miners may be unjustly considered dishonest, meaning their work won\u2019t count, and the network will be more vulnerable to attacks. Conversely, if k is set too high, we risk mistakenly considering attacker blocks as honest. However, an attacker cannot create more than k blocks that will be considered honest, so to avoid such issues, we can simply wait k blocks before considering a transaction confirmed. For example, if k=3 and Alice is pending a transaction in block B, she can wait for block E before transferring her purchased goods. She knows that if the attacker submits blocks F and G with a conflicting transaction, they will have a 4-block anticone, and PHANTOM will categorize those blocks as malicious. If she does not wait for block E, there is no guarantee that the attack won\u2019t succeed, as PHANTOM cannot operate on resolutions lower than k.",
    "source":"generic",
    "section":"Section 22",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_22",
    "content":"In conclusion, it is better to choose a k that is too high rather than too low. The former may harm user experience by requiring longer confirmation times, while the latter decreases the reorganization attack threshold to less than 50%.",
    "source":"generic",
    "section":"Section 23",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_23",
    "content":"**PHANTOM for Practical Use**",
    "source":"generic",
    "section":"Section 24",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Scaling Bitcoin with BlockDAG_24",
    "content":"PHANTOM attempts to find the largest sub-DAG with an anticone smaller than k+1. Unfortunately, this operation is very costly when dealing with large DAGs. This is why the GHOSTDAG algorithm was developed as a greedy and more efficient variant of PHANTOM. This will not be covered in this article, but those interested in further reading can refer to the PHANTOM paper.",
    "source":"generic",
    "section":"Section 25",
    "url":null,
    "filename":"Scaling Bitcoin with BlockDAG",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_0",
    "content":"The slogan \u201cdon\u2019t trust, verify!\u201d is often misunderstood. Many people board airplanes without verifying the pilot or the aircraft; they eat at restaurants without knowing what is in their food; they take medications without checking the supply chain. This raises the question: why would one take extraordinary measures to protect their money while neglecting to protect their life?",
    "source":"generic",
    "section":"Section 1",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_1",
    "content":"This situation reminds me of Jacob, the forefather of Israel, who crossed the Jordan River back to his homeland about 3,500 years ago. According to later Talmudic Rabbis, he forgot a few small items (think of dust UTXOs) and returned to the east bank in the middle of the night to retrieve them. This was dangerous, and he encountered a mysterious figure who wrestled with him, resulting in a limp, a divine blessing, and a new name\u2014Israel. The Talmud concludes that the possessions of the righteous are dearer to them than their bodies, and they care about their possessions because they do not partake in stolen property.",
    "source":"generic",
    "section":"Section 2",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_2",
    "content":"The connection between this story and SPV sync mode based on multiplicative-hash UTXO commitments is significant. Verifying the proper functioning of all external systems one relies on is infeasible and unscalable. Civilization is about scaling up function and trust, and focusing solely on money verification is peculiar and can lead to complications.",
    "source":"generic",
    "section":"Section 3",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_3",
    "content":"Fiat currency is problematic due to unpredictable inflation, political corruption in money printing, and regulatory attempts to control financial transfers, eliminate cash, and restrict economic freedom. Cryptocurrencies offer predictable issuance and censorship resistance. The property of \u201cno fraudulent transaction ever occurring in this currency system\u201d is not the primary concern for users. When joining a cryptocurrency system, checking its issuance and decentralization is far more important than verifying the historical validity of transactions.",
    "source":"generic",
    "section":"Section 4",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_4",
    "content":"Users should focus on the state of their node being the one most likely to prevail by economic majority, rather than its validity in an abstract sense. The primary goal of consensus systems is to facilitate agreement, not enforce consistency. If the economic majority maintains a ledger that includes an invalid transaction from history, the system can still serve its purpose. Users are protected from unsafe networks as long as they can assume efficient communication methods exist to inform them of any issues. This novel way to diffuse information is facilitated by the Internet and the broader concept of civilization.",
    "source":"generic",
    "section":"Section 5",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_5",
    "content":"Users, like those boarding airplanes or dining at restaurants, assume they are engaging with a functioning system and that information about past security breaches would reach them through conventional channels. These channels are typically reliable due to the involvement of highly-staked, ideological, or philanthropic whistleblowers who verify the ledger, or previous users harmed by the system\u2019s failures, thus granting the system herd immunity. Running full nodes is crucial for the ledger\u2019s integrity, although the marginal utility of doing so is rapidly decreasing.",
    "source":"generic",
    "section":"Section 6",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_6",
    "content":"In summary, if you are considering joining the IOTA network, it is advisable to research it first.",
    "source":"generic",
    "section":"Section 7",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_7",
    "content":"Bitcoin\u2019s Initial Blockchain Download (IBD) is the process by which new nodes join the network. The ethos of Bitcoin core developers is \u201cdon\u2019t trust, verify!\u201d, leading new nodes to download and verify the entire history of the Bitcoin ledger. This design limits Bitcoin\u2019s throughput to enable fast IBD, as processing too many transactions per second would complicate verification for users joining in the future.",
    "source":"generic",
    "section":"Section 8",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_8",
    "content":"In 2013, my advisor shared a paper titled \u201cBitcoin: A Peer-to-Peer Electronic Cash System.\u201d The narrative has since shifted to \u201cBitcoin: An Electronic Store of Value,\u201d with the notion that attempts to create a peer-to-peer electronic cash coin are scams.",
    "source":"generic",
    "section":"Section 9",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_9",
    "content":"Kaspa aims to revive Satoshi Nakamoto's vision. PHANTOM is a generalization of Nakamoto Consensus that supports concurrency. It adheres to the same principles as Nakamoto Consensus, and implementing PHANTOM is essential for achieving the vision of electronic cash. Kaspa utilizes Directed Acyclic Graphs (DAGs) because of our expertise in this area, and we aim to facilitate transactions in a manner akin to receiving results from a Google search or sending an email.",
    "source":"generic",
    "section":"Section 10",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_10",
    "content":"Additionally, Kaspa seeks to create a base layer that prioritizes the needs of crypto-informed users. This involves implementing a default node that skips historical verification, making it an optional operation reliant on fewer archival nodes maintained by certain entities. This situation mirrors Bitcoin, where most full nodes prune data necessary for syncing newcomers. However, archival nodes can still prove fraudulent transactions by providing Merkle witnesses for inclusion in the relevant blocks.",
    "source":"generic",
    "section":"Section 11",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_11",
    "content":"Kaspa nodes prune block data by default, and new nodes sync in SPV mode, downloading and verifying only block headers. This approach does not impose a stronger trust assumption than a history-verifying node; it simply requires different operations. The node requests the UTXO set from untrusted peers and verifies it against the UTXO commitment embedded in the latest received header. If there is a mismatch, the node bans the sending peers and requests the UTXO set from new untrusted peers. If they match, the node checks for unexpected inflation by comparing the sum of UTXOs to the specified minting schedule, which can be done with block headers.",
    "source":"generic",
    "section":"Section 12",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_12",
    "content":"To scale Nakamoto Consensus, I propose several suggestions:",
    "source":"generic",
    "section":"Section 13",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_13",
    "content":"1. **Latency Constraint on Consensus**: Transition from the longest-chain rule to PHANTOM, which is tolerant of predetermined upper bounds on latency.\n2. **CPU Consumption**: Process fewer transactions per second on Layer 1 while supporting large payloads that are CPU-efficient, enabling healthy Layer 2 solutions (e.g., SN\/TARK proofs for Zero-Knowledge Rollups).\n3. **Bandwidth Consumption**: Design sharding of data and data availability proofs, similar to Ethereum 2.0, which is an open research question since Proof of Work lacks native identities for sharding.\n4. **Memory Consumption and Disk I\/O**: Implement class group-based accumulators that require no trusted setup, allowing for UTXO pruning and operation as a stateless client. Challenges include user experience in storing and updating witnesses and balancing memory savings against higher CPU consumption.\n5. **Storage**: Prune block data to reduce storage requirements significantly. Consider also pruning block headers, although this raises questions about how new nodes can ensure they are syncing to the consensus state rather than a stale or malicious branch.\n6. **IBD Time**: Implement a DAG-adapted version of FlyClient to reduce the cost of syncing a new node from O(num of blocks in history) to O(log(num of blocks in history)). This does not reduce storage at the syncer but allows the syncee to sync without downloading the entire history of block headers.",
    "source":"generic",
    "section":"Section 14",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_14",
    "content":"In conclusion, Kaspa is a Proof of Work system optimized for informed users rather than ideologues. Its throughput should be constrained by real-time performance considerations rather than the performance of downloading and verifying historical ledgers, which serve as an auxiliary trust gateway rather than the primary pillar of trust in the system.",
    "source":"generic",
    "section":"Section 15",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_In which mayday mayday we are syncing about*_15",
    "content":"Kaspa aims to achieve 100 blocks per second, and to facilitate this, nodes should prune data by default. New nodes should sync against the heaviest PoW DAG, which is most likely to represent the current consensus view. Node operators must connect to a sufficient number of peers to avoid being eclipsed from the network, ensuring they are informed about historical issues such as invalid blocks and finality violations, which are recorded and propagated by full nodes to keep new nodes aware of what they are syncing.",
    "source":"generic",
    "section":"Section 16",
    "url":null,
    "filename":"In which mayday mayday we are syncing about*",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_How Increasing the Throughput Harms Bitcoin\u2019s Security_0",
    "content":"Satoshi Nakamoto invented Bitcoin in 2008, creating for the first time a trustless decentralized currency. Despite its many innovations, blockchain technology has some issues. This text investigates some of these issues, particularly how Bitcoin forks work and how they affect its security.",
    "source":"generic",
    "section":"Section 1",
    "url":null,
    "filename":"How Increasing the Throughput Harms Bitcoin\u2019s Security",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_How Increasing the Throughput Harms Bitcoin\u2019s Security_1",
    "content":"Bitcoin miners always mine blocks that point to the tip of the current chain. However, the situation can be more complex. The Bitcoin network occasionally experiences \"forks,\" where a miner must decide between competing chains. For example, if a miner has a chain of four blocks A, B, C, D and then receives a new chain with blocks E and F, the miner must decide whether to extend block D or block F. The simplest solution would be to ignore blocks that do not extend the current tip, but this introduces another problem: what happens if a miner that was offline when blocks A-D were created receives blocks E and F first? If it follows the previous rule, it will mine on top of block F, while all other miners ignore its blocks, resulting in a split from the rest of the network.",
    "source":"generic",
    "section":"Section 2",
    "url":null,
    "filename":"How Increasing the Throughput Harms Bitcoin\u2019s Security",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_How Increasing the Throughput Harms Bitcoin\u2019s Security_2",
    "content":"To prevent such issues, miners follow the longest-chain rule, which states that an honest miner should always mine on the longest chain. In the example above, all miners, both up-to-date and those that join later, will mine on top of block D. The only exception to this rule occurs when there are two or more chains of equal length. This situation usually arises when one miner mines block D and another miner mines block E before being aware of block D. Although this occurrence is rare, it can happen due to the average block rate in the Bitcoin network being 10 minutes.",
    "source":"generic",
    "section":"Section 3",
    "url":null,
    "filename":"How Increasing the Throughput Harms Bitcoin\u2019s Security",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_How Increasing the Throughput Harms Bitcoin\u2019s Security_3",
    "content":"When miners encounter equal-length chains, each will mine on the first tip they see. This is a temporary condition that resolves once one of the miners successfully mines on top of one of the chains, allowing the longest-chain rule to be applied again.",
    "source":"generic",
    "section":"Section 4",
    "url":null,
    "filename":"How Increasing the Throughput Harms Bitcoin\u2019s Security",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_How Increasing the Throughput Harms Bitcoin\u2019s Security_4",
    "content":"Forks are rare because the blockchain is designed as a chain rather than a tree. The vast majority of Bitcoin blocks belong to the main chain, with only a limited number of forks occurring. The fork rate is influenced by two variables: the block creation rate and the network delay. The network delay is the time it takes for a block to be known to all miners. Bitcoin\u2019s network delay is approximately 1 second, while a new block is created on average every 600 seconds (10 minutes). Since the average block creation time is significantly longer than the network delay, it is highly unlikely that a block will be mined while another block is still being propagated.",
    "source":"generic",
    "section":"Section 5",
    "url":null,
    "filename":"How Increasing the Throughput Harms Bitcoin\u2019s Security",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_How Increasing the Throughput Harms Bitcoin\u2019s Security_5",
    "content":"The longest-chain rule makes the network vulnerable to history rewrites if an attacker mines a chain longer than the honest chain after the fact. A history rewrite attack, often referred to as a reorganization (reorg), can be used for fraudulent payments. For instance, if Chuck pays Alice 2 BTC for a car, and Alice sees the transaction included in block D, she gives him the car. However, if Chuck later mines two consecutive blocks E and F on top of block C, using the same funds to pay himself, all miners will abandon block D and start extending block F, leaving Alice without her bitcoin and her car. This scenario exemplifies a double spend attack.",
    "source":"generic",
    "section":"Section 6",
    "url":null,
    "filename":"How Increasing the Throughput Harms Bitcoin\u2019s Security",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_How Increasing the Throughput Harms Bitcoin\u2019s Security_6",
    "content":"To protect against such attacks, Alice can wait for several blocks to be built on top of block D before giving Chuck the car. If she sees 10 blocks built on top of block D without any forks, she can be reasonably assured that Chuck will not successfully build a competing chain of 10 blocks. However, if Chuck controls more than 51% of the mining power, he can successfully execute a reorg regardless of how long Alice waits, as his block creation rate would exceed that of all other miners combined. The 51% reorg attack represents a fundamental flaw in all proof-of-work systems: the longest-chain rule cannot differentiate between honest and malicious miners, allowing a malicious miner with sufficient computational power to rewrite history.",
    "source":"generic",
    "section":"Section 7",
    "url":null,
    "filename":"How Increasing the Throughput Harms Bitcoin\u2019s Security",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_How Increasing the Throughput Harms Bitcoin\u2019s Security_7",
    "content":"Research by Yonatan Sompolinsky and Aviv Zohar has shown that the 51% attack threshold can be reduced when increasing Bitcoin\u2019s throughput. Currently, Bitcoin\u2019s throughput is about 7 transactions per second, with blocks limited to approximately 2.3 MB, allowing for around 4,000 transactions per block. If Bitcoin were to scale to Visa levels, processing 2,000 transactions per second, we would expect blocks to be 285 times larger (655 MB). This naive calculation suggests that the network delay could increase from 1 second to 285 seconds.",
    "source":"generic",
    "section":"Section 8",
    "url":null,
    "filename":"How Increasing the Throughput Harms Bitcoin\u2019s Security",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_How Increasing the Throughput Harms Bitcoin\u2019s Security_8",
    "content":"In a network with a 285-second delay and an average block creation rate of one block every 600 seconds, there is a 0.475 chance that another block will be created. This means that nearly 50% of the blocks could belong to forks. If an attacker wants to double spend a transaction in block B, they would only need to create a chain of 7 blocks instead of 10. To sustain a continuous reorg attack, the attacker must create blocks faster than the main chain but not faster than the entire network. If half of the blocks are forked, only two-thirds will be included in the main chain, allowing an attacker to sustain an attack with only 33% of the hashing power.",
    "source":"generic",
    "section":"Section 9",
    "url":null,
    "filename":"How Increasing the Throughput Harms Bitcoin\u2019s Security",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_How Increasing the Throughput Harms Bitcoin\u2019s Security_9",
    "content":"Thus, increasing Bitcoin\u2019s throughput can make it more vulnerable to attacks, highlighting a significant problem and one of the main reasons why Bitcoin\u2019s block size remains small. There is a trade-off between Bitcoin\u2019s throughput and security; as throughput increases, the number of forks rises, and the threshold for reorg attacks can drop below 50%.",
    "source":"generic",
    "section":"Section 10",
    "url":null,
    "filename":"How Increasing the Throughput Harms Bitcoin\u2019s Security",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_0",
    "content":"Global adoption of cryptocurrency has been a significant challenge since the introduction of Bitcoin in 2009. The need for scaling and speeding up Bitcoin to make it globally accessible and competitive with centralized solutions has been a persistent issue. Over the years, Bitcoin's conservative approach to innovation led to the abandonment of the idea of a scalable currency, favoring the concept of \"Digital Gold.\"",
    "source":"generic",
    "section":"Section 1",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_1",
    "content":"Enthusiasts and professionals seeking to enhance Bitcoin's scalability were motivated to create new networks. As these networks emerged, the vision of a scalable Bitcoin became overshadowed by a multitude of diverse ideas and ambitious goals, leading to the development of various branches of financial cryptography. Today, the cryptocurrency landscape features numerous networks, yet arguably none are capable of achieving true global scalability. These networks can be categorized into two groups: Proof-of-Work (PoW) networks, which adhere to Bitcoin's ethos, and Proof-of-Stake (PoS) networks, which draw inspiration from Bitcoin but operate on fundamentally different principles.",
    "source":"generic",
    "section":"Section 2",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_2",
    "content":"The scaling potential of both PoW and PoS will be explored, highlighting how scientific research has refined and improved the scalability of PoW, while also addressing why PoS cannot leverage these academic advancements due to its inherent structure.",
    "source":"generic",
    "section":"Section 3",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_3",
    "content":"A critical issue in the cryptocurrency space is the costliness associated with consensus mechanisms. Proof of Work, first implemented by Bitcoin, relies on costly digital signatures to achieve decentralized consensus without a central point of trust. Prior to Bitcoin, protocols struggled to eliminate internal points of trust, but Bitcoin successfully delegated these points to the mining process, which involves a chain-linked structure where transactions are grouped into blocks, and a hash solution is produced that meets the network's self-adjusting difficulty.",
    "source":"generic",
    "section":"Section 4",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_4",
    "content":"Following Bitcoin's introduction, some argued that costly digital signatures were unnecessary for decentralized consensus and proposed Proof of Stake as an alternative. This argument posits that instead of incurring high computational costs, coin holders can lock their currency for a set period to participate in consensus. While this simplified view of PoS may appear appealing, a deeper examination reveals significant shortcomings.",
    "source":"generic",
    "section":"Section 5",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_5",
    "content":"Without the costliness of mining, any protocol risks reverting to a lower security threshold. PoW networks enjoy 50% Byzantine Fault Tolerance (BFT), while PoS networks are limited to 33% BFT. This discrepancy raises important questions about the implications of BFT on security, scalability, and potential vulnerabilities.",
    "source":"generic",
    "section":"Section 6",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_6",
    "content":"In PoW, distribution occurs solely through mining, assuming a fair launch. The costliness of mining ensures that the distribution process is unforgeable and equitable, rewarding participants based on their contributions. A miner with a large mining facility receives compensation proportional to that of a home miner with a few machines. However, removing the costliness of block production undermines fair distribution. Many PoS networks exploit the absence of cost to implement distribution schemes that disproportionately benefit founders, insiders, and venture capitalists.",
    "source":"generic",
    "section":"Section 7",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_7",
    "content":"This situation draws parallels between PoS networks and equity financing in traditional finance. Just as companies raise capital by selling shares, PoS networks can sell portions of their coin supply to various stakeholders, including venture capitalists and service providers. For instance, during Ethereum's launch, the founders allocated 12 million ETH to themselves and sold an additional 60 million coins, raising significant capital.",
    "source":"generic",
    "section":"Section 8",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_8",
    "content":"The coin supply in PoW is directly tied to real-world energy and resource expenditures, while PoS networks often lack this connection. The unfair distribution practices in popular PoS networks can lead to early investors gaining disproportionate influence and control over the network, exacerbating issues of centralization.",
    "source":"generic",
    "section":"Section 9",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_9",
    "content":"The supply fairness and manipulation problem is just one of many challenges stemming from the abandonment of costly block production. Each PoS network has unique adaptations and trade-offs, but all remain vulnerable to critical attacks and exploits. One notable attack vector is the \"Wrench Attack,\" where attackers can target validators' keys, leading to severe consequences for the network's consensus.",
    "source":"generic",
    "section":"Section 10",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_10",
    "content":"If the staked supply is small, the impact on consensus may be minimal, but with a larger staked supply, compromised keys can halt finalization and prevent consensus. If attackers control 34% of the supply, they can permanently disrupt the network unless intervention occurs. This vulnerability, termed \"Weak Subjectivity,\" arises because newly syncing or out-of-sync validators cannot distinguish between the true ledger history and a forged one without an external source of trust.",
    "source":"generic",
    "section":"Section 11",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_11",
    "content":"In contrast, PoW requires an immense cost to forge a new history, making it nearly impossible to reverse the entire Bitcoin ledger without controlling 100% of the hashrate for an extended period. The vulnerabilities inherent in PoS raise critical questions about its feasibility for global scalability.",
    "source":"generic",
    "section":"Section 12",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_12",
    "content":"The distinction between internal and external block creation processes is crucial for understanding scalability. PoS participants lock their coins to participate in block creation, resulting in a consistent and orderly process. Conversely, PoW miners engage in a chaotic race to find block solutions, which can lead to inefficiencies.",
    "source":"generic",
    "section":"Section 13",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_13",
    "content":"Researchers have extended the utility of PoW by developing methods to prune consensus data while maintaining security. Under PoW, miners seek block solutions that meet specific difficulty criteria, and the emergence of \"superblocks\" has been observed, which can be chained together to form a secure record of Proof of Work at a fraction of the original size.",
    "source":"generic",
    "section":"Section 14",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_14",
    "content":"Kaspa employs a pruning mechanism that allows nodes to maintain near-constant storage growth, contrasting with the linear growth experienced by PoS networks. This difference highlights how the security-speed trade-offs in PoS also limit scalability.",
    "source":"generic",
    "section":"Section 15",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_15",
    "content":"In the current cryptocurrency landscape, many users gravitate toward networks like BNB, XRP, and Solana due to their user-friendly experiences, despite being aware of their drawbacks. BNB is centralized, Solana faces outages and lacks a maximum supply, and XRP has a low fault tolerance, all of which impact security and scalability.",
    "source":"generic",
    "section":"Section 16",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_16",
    "content":"Kaspa's unique storage dynamics, enabled by its pruning mechanism, make it more sustainable in the long term. For example, if payment processors handle approximately 2 billion transactions daily, the storage costs for PoS networks would quickly become unsustainable. In contrast, Kaspa's GhostDAG protocol allows for scaling without security-speed trade-offs, making it a more viable solution.",
    "source":"generic",
    "section":"Section 17",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_17",
    "content":"Kaspa's current implementation, while not optimal, is significantly more efficient than other networks with comparable speeds. The decision to rewrite Kaspa in Rust aims to enhance performance and security, addressing the challenges posed by code debt and enabling higher block rates.",
    "source":"generic",
    "section":"Section 18",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 Towards a Viable Path to Global Scalability_18",
    "content":"Testnet 11 demonstrated that a standard computer could run a node at 10 blocks per second, with a storage ceiling of only 260GB. This testnet successfully handled 150\u2013200 million transactions daily without faults, showcasing the potential for Kaspa to support global adoption and new paradigms in cryptocurrency. The future prospects of innovations like DAGKnight and smart contracts, enabled by Kaspa's design, are beginning to materialize, promising exciting developments in the space.",
    "source":"generic",
    "section":"Section 19",
    "url":null,
    "filename":"Kaspa \u2014 Towards a Viable Path to Global Scalability",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_0",
    "content":"hashdag",
    "source":"generic",
    "section":"Section 1",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_1",
    "content":"This post is based on extensive conversations and brainstorming with Sutton, Roma, and Ilia@Starkware.",
    "source":"generic",
    "section":"Section 2",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_2",
    "content":"We are putting efforts into designing Kaspa\u2019s L1 support for L2. Our design follows the principles of zk-based rollups (ZK RUs): all smart contract activity is recorded in L1 as payloads (blobs in Ethereum jargon), and the state of all logic zones (smart contracts or rollups, used interchangeably for reasons explained later) is committed to in block headers.",
    "source":"generic",
    "section":"Section 3",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_3",
    "content":"The term rollups originally required on-chain sequencing, but nowadays, on-chain sequenced rollups have become the exception rather than the rule and are referred to as based rollups. To anchor a new state of a certain logic zone to the base layer, after one or multiple state transitions, some prover node must send a transaction to the base layer that provides a zero-knowledge proof (ZKP). The ZKP is verified in the base consensus through a new op_code, and the (commitment to the) state of the logic zone is updated. Crucially, the proofs may be submitted with non-negligible delays; however, users can receive instant (~100 ms) confirmation by any node following this logic zone, executing its (L1-sequenced) transactions, and parsing its state. In short, proof latency does not affect finality latency; it affects the state-sync time of new L2 nodes, the L1-pruning interval, and the computational load of cross-logic zone transactions.",
    "source":"generic",
    "section":"Section 4",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_4",
    "content":"The best smart contract layers are designed for atomic or synchronous composability, where a smart contract can allow functions from other smart contracts to call it and interact with its variables (read and write) on the spot, atomically, in the scope of the triggering transactions. This cross-smart contract functionality describes the on-chain activity during Ethereum\u2019s early years and arguably facilitated the incredible growth of its ecosystem and developer community. Unfortunately, Ethereum\u2019s rollup-centric roadmap is working against this atomic composability feature and settles for asynchronous composability (which is still much better than traditional finance user experience, which requires manual composing).",
    "source":"generic",
    "section":"Section 5",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_5",
    "content":"In asynchronous composability, smart contracts can still interact with and send messages to one another, yet this is done through some layer that carries or bridges these messages\u2014typically the base layer\u2014which suffers from some latency. Consequently, read\/write actions are not treated in the scope of the originating transaction, atomicity is not guaranteed, and the effect of a composable transaction (the contracts\u2019 variables and the issuer\u2019s account post-transaction) cannot be guaranteed in advance.",
    "source":"generic",
    "section":"Section 6",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_6",
    "content":"The unavoidable lack of predictability due to multiple users acting simultaneously is a separate issue; transaction issuers can enforce behavior through several techniques, such as slippage specification, explicit conditions in the transaction, or intent specification. The issue with asynchronous composability is that the effect of only parts of the transaction can be fully enforced.",
    "source":"generic",
    "section":"Section 7",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_7",
    "content":"There are arguments for why asynchronous composability is good enough, but I will not delve into them here. Let\u2019s assume we don\u2019t want to settle on that. The good news is that we don\u2019t need to since we are going full zk-based mode: Since all data is on-chain, the state of each logic zone is fully reconstructable from on-chain data (until the pruning point). Consequently, the effect of a multi-logic zone transaction occurs at its very sequencing, with no latency, and conditions on its effect across all logic zones can be simultaneously enforced. This dynamic contrasts with the non-based rollup-centric Ethereum, wherein the semi-off-chain sequencing of logic zone I transactions may be inaccessible to L1 (and to logic zone II provers), hence not provable to it. I reiterate that the synchronous atomicity of transactions is irrespective of prover latency: Proof arrival frequency does not affect confirmation times in L1 or L2.",
    "source":"generic",
    "section":"Section 8",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_8",
    "content":"Now, consider a composable transaction that not only acts on two logic zones but also triggers an interaction between them; for example, the transaction calls a function inside logic zone I and uses the output of this interaction as an argument for a function call to logic zone II. To verify the correct execution of logic zone II, the base layer must see a proof of the correct state transition of logic zone II and that of logic zone I, since the output or intermediate state of the latter served as input to the state transition of the former. Similarly, the operators (provers) of logic zone II that wish to follow and parse their state must follow and execute logic zone I as well.",
    "source":"generic",
    "section":"Section 9",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_9",
    "content":"This dependency seems problematic at first glance\u2014if the existence of composable transactions implies that all provers need to execute all transactions of all logic zones, then the architecture supposedly collapses back to one grand logic zone that suffers from the same scalability hindrances as a computation-oriented L1\u2014each transaction consumes the same computational load that serves all other transactions. However, this is not the case because:",
    "source":"generic",
    "section":"Section 10",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_10",
    "content":"1. Executing transactions of other logic zones needs to occur only when logic zones interact.\n2. Logic zones can define permissions (in their program code) for specific logic zones to interact with them in synchronous mode and require other logic zones to interact in asynchronous mode through the base layer\u2019s messaging protocol.\n3. Transaction execution is cheaper than proof generation by two or three orders of magnitude. Provers of logic zone II need to execute but not prove the (intermediate) state of logic zone I, which is the computationally intense part.\n4. Running a prover needs to be permissionless but not necessarily decentralized in the sense of optimizing for commodity hardware being able to run system-wide provers.",
    "source":"generic",
    "section":"Section 11",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_11",
    "content":"These considerations imply that an ideal ecosystem would minimize the scope of logic zones, which as a byproduct would minimize cross-logic zone dependencies as well as the implications (e.g., the aforementioned execution burden) of dependencies. I strongly encourage L2\/smart contract projects building on Kaspa to follow this design principle and avoid aggregating many separable logic zones under one overarching logic zone.",
    "source":"generic",
    "section":"Section 12",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_12",
    "content":"It is important to note that when logic zones do not support atomic composability and instead use asynchronous composability through L1\u2019s messaging feature, they suffer the latency of provers and not (only) the latency of the base layer. Thus, even when Kaspa implements 10 (Sutton, read: 100) BPS, if the prover of logic zone I provides a proof every 10 minutes, then that is the latency that asynchronous-composable transactions would suffer; for many applications, 10 minutes equals infinity (which is why Bitcoin cannot realistically serve as a base layer for zk-based rollups). This is why I think we should insist on atomic composability.",
    "source":"generic",
    "section":"Section 13",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_13",
    "content":"A final comment on this construction: Recall that the composable transaction described above forces provers of logic zone II to execute the state of logic zone I after the transaction\u2019s first part. A proof by the former operators can appear on-chain only after the latter submitted one; let\u2019s denote this state by state_I_pre. However, logic zone I provers might submit a proof that batches a series of state transitions of I, of which state_I_pre is only an intermediate member. To allow II\u2019s provers to build their proof utilizing the (chunk) proof of I, we must ensure L1 has access to the intermediate states that have been proven by I\u2019s provers. In other words, we need all proofs to commit to all intermediate states in an accumulator (e.g., Merkle tree), and then II\u2019s provers can add a witness to that commitment alongside the proof of their execution.",
    "source":"generic",
    "section":"Section 14",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_14",
    "content":"At the risk of overselling the feature discussed in this post, I believe that the construction proposed here extracts the best of all architectures: Bitcoin, Ethereum (rollup-centric roadmap), and Solana\u2014an internet-speed version of Nakamoto base layer (verification-oriented), a zk-based computation layer, and a Solana-like unified defragmented state.",
    "source":"generic",
    "section":"Section 15",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_15",
    "content":"How to control the throughput of L2? Let\u2019s denominate computation with the familiar \u201cgas\u201d unit. How should the gas limit be enforced? Since L1\u2019s sequencers\u2014miners, in Kaspa\u2014are the only entities capable of selecting and prioritizing transactions entering the system, the gas regulation mechanism must also be employed at the L1 layer. The most simplistic design is to convert gas units to mass units, and since the latter are capped per block, so will gas per block be. Such a unidimensional restriction pools together resources of different natures\u2014L1 mass (script computation and storage) and L2 proving loads\u2014and this is economically inefficient. It implies, for instance, that a user issuing a gas-heavy, storage-light transaction may be outcompeted by users issuing storage-heavy transactions, despite the fact that she imposes no externality on them and can be co-approved without consuming the same resource. We should thus keep the mass and gas throughput constraints decoupled, providing a two-dimensional throughput restriction on blocks in the form: mass(block) < mass_limit AND gas(block) < gas_limit. This proposal implies miners will face a two-dimensional knapsack problem when selecting transactions from the mempool.",
    "source":"generic",
    "section":"Section 16",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_16",
    "content":"The very same discussion applies to our coupling of L1 script computation mass and KIP-9 storage mass. We opted to couple them nonetheless under the same mass function and accept the theoretical economic inefficiency.",
    "source":"generic",
    "section":"Section 17",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_17",
    "content":"Notice that a surge in demand for L2 operations will not translate to higher revenue for provers\u2014miners, the selectors of the L1 club, will collect the profits. This profit flow seems acceptable since the gas limit implies provers\u2019 load does not increase (beyond the limit) in times of higher demand.",
    "source":"generic",
    "section":"Section 18",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_18",
    "content":"Another proposal that came up is to run a variant of the EIP-1559 mechanism on the gas units, which would (i) flow base fee profits to provers and (ii) remove the complexity of running a dual knapsack, as it provides an in-consensus sufficiently precise price per gas unit.",
    "source":"generic",
    "section":"Section 19",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_19",
    "content":"When setting gas_limit, one consideration to keep in mind is the gap between the average and the peak load on a prover: While logic zone I may typically comprise 10% of the gas capacity in blocks, its relative demand can reach 100% in peak demand when users want to interact with it more than anything else. Here too, an economically efficient design would restrict the block\u2019s gas per logic zone. This, however, would result in an n-dimensional knapsack problem for constructing a block out of the mempool, and so we are currently opting for a simpler design with one gas_limit per block, acknowledging the economic suboptimality.",
    "source":"generic",
    "section":"Section 20",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_20",
    "content":"With either of the above mechanisms, L2 projects may conceive of additional funding schemes for provers. From an ecosystem vantage point, it is imperative that these fees be given in KAS, contribute to the flywheel of Kaspa, and align all players.",
    "source":"generic",
    "section":"Section 21",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Atomic Composability and other considerations for L1-L2 support_21",
    "content":"I have summarized here ideas and considerations raised by the aforementioned co-contributors. Some of the topics discussed here are still works in progress and open for discussion.",
    "source":"generic",
    "section":"Section 22",
    "url":null,
    "filename":"Atomic Composability and other considerations for L1-L2 support",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_0",
    "content":"It is astonishing to see how fast the Kaspa community is growing. However, as Kaspa gains more traction and popularity, it becomes clear that many people do not fully understand what Kaspa actually is. This is not their fault, as the core technology behind Kaspa has not been explained in an accessible manner. While the information exists in technical papers and conference talks, these are not written with the common user in mind. The goal here is to rectify this.",
    "source":"generic",
    "section":"Section 1",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_1",
    "content":"Kaspa is a broad term that describes a complicated system with many components and aspects. At its core, Kaspa is an implementation of the GHOSTDAG protocol, which was first conceptualized by Yonatan Sompolinsky and Aviv Zohar in 2016. The following content is dedicated to describing this particular aspect of Kaspa.",
    "source":"generic",
    "section":"Section 2",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_2",
    "content":"Cryptocurrencies can be very complicated, and many users tend to forgo fully understanding the promise of one coin or another, which is acceptable. However, the true power of GHOSTDAG lies in its simplicity: GHOSTDAG is a gentle generalization of Nakamoto consensus. Unlike many coins, anyone who understands Bitcoin can easily grasp GHOSTDAG, what it achieves, and how it achieves it.",
    "source":"generic",
    "section":"Section 3",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_3",
    "content":"Furthermore, GHOSTDAG offers a simple, albeit challenging to implement, solution to the core scaling issue present in Nakamoto consensus (i.e., in any Proof of Work (PoW) based blockchain). It has the potential to replace Bitcoin and Ethereum as the layer one framework capable of supporting a decentralized global-scale economy. With this goal in mind, Kaspa is planned to provide tools that will facilitate the development of layer two applications.",
    "source":"generic",
    "section":"Section 4",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_4",
    "content":"This discussion assumes basic familiarity with Nakamoto consensus (e.g., with Bitcoin). The uninitiated can fill in the gaps with available resources.",
    "source":"generic",
    "section":"Section 5",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_5",
    "content":"The Nakamoto Consensus Scaling Problem",
    "source":"generic",
    "section":"Section 6",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_6",
    "content":"Bitcoin and other blockchains claim to provide 51% security. This means that as long as most of the hashes in the network are created by honest miners, the network is protected from adversaries who wish to revert arbitrarily old transactions. However, this is only approximately true, and this issue is at the crux of all blockchain scaling challenges.",
    "source":"generic",
    "section":"Section 7",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_7",
    "content":"Imagine an adversary who wishes to revert a transaction that took place 10 blocks ago. If the adversary has been preparing to do so since the block was created, they must create a longer alternative chain faster than the network. Bitcoin operates on a longest chain rule (technically, it works on a heaviest chain rule, but this detail is simplified for clarity). If the adversary has less computational power than the rest of the network, the probability of successfully mining, say, 12 blocks before the honest network does is extremely low.",
    "source":"generic",
    "section":"Section 8",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_8",
    "content":"The crux of the issue arises when honest network blocks are not always arranged in a single chain. Occasionally, two honest miners will create blocks at approximately the same time, leading to competition between these blocks until one is discarded. Such discarded blocks are often referred to as orphan blocks, and conservative estimates suggest that at least one in every 150 Bitcoin blocks is orphaned.",
    "source":"generic",
    "section":"Section 9",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_9",
    "content":"This means that to revert a transaction, the attacker only needs to create slightly fewer blocks than the honest network: for every 150 honest blocks, the attacker needs to create more than 149 blocks, which can be achieved with 49.9% of the global hash rate.",
    "source":"generic",
    "section":"Section 10",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_10",
    "content":"While this may not seem significant, there is little difference between a 50.1% attacker and a 49.9% attacker. The problem arises when attempting to increase the throughput of the network (by either increasing the block rate or the block size), which inevitably raises the orphan rate and decreases the network's security.",
    "source":"generic",
    "section":"Section 11",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_11",
    "content":"The security of any blockchain relies on the fact that the delay between blocks is significantly larger than the time it takes for the entire network to learn of a new block. Parallel blocks are orphaned, which decreases the growth rate of the honest chain. Overcoming this throughput\/security tradeoff is the main motivation behind the GHOSTDAG protocol.",
    "source":"generic",
    "section":"Section 12",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_12",
    "content":"So How Can We Allow Parallel Blocks?",
    "source":"generic",
    "section":"Section 13",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_13",
    "content":"The core idea is straightforward: instead of having any block point to a single parent block, allow it to point to multiple parents, thus giving the blocks in the network the structure of a Directed Acyclic Graph (DAG) rather than a chain.",
    "source":"generic",
    "section":"Section 14",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_14",
    "content":"The first natural question about this approach is: what about double spends? If we allow two parallel blocks to coexist, how do we handle the possibility that they contain conflicting transactions?",
    "source":"generic",
    "section":"Section 15",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_15",
    "content":"The solution we are working towards is to choose an ordering of the blocks. We take the DAG structure and arrange it in a chain. We then traverse the chain and include all transactions that do not contradict previous transactions.",
    "source":"generic",
    "section":"Section 16",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_16",
    "content":"Choosing this ordering is crucial and can determine the success of a blockDAG. The GHOSTDAG (and its computationally unfeasible precursor PHANTOM) protocols are essentially methods to order blocks in a DAG.",
    "source":"generic",
    "section":"Section 17",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_17",
    "content":"Before delving into these protocols, let us outline some properties we expect from a good ordering:",
    "source":"generic",
    "section":"Section 18",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_18",
    "content":"1. It must be topological: a block cannot appear in the ordering before any of its parent blocks.\n2. It must be in consensus: at any point in time, all nodes in the network must agree on the ordering of all but a constant number of new blocks.\n3. It must be secure: a computationally inferior adversary cannot retroactively revert the ordering of blocks.\n4. It must offer liveness: there should be a clear criterion for when a block is \u201cfinalized\u201d in the sense that it will never change its place in the ordering, and every block should satisfy this criterion within a constant amount of time.\n5. It must be efficient: determining, calculating, and maintaining the order should be feasible for today\u2019s computers, even as the DAG grows.",
    "source":"generic",
    "section":"Section 19",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_19",
    "content":"An ordering with these properties could provide a solution to the scaling problem of traditional blockchains by removing the need for a large block delay. Indeed, the GHOSTDAG protocol is provably secure regardless of the ratio between block delay and block round trip time. This is the central promise of GHOSTDAG.",
    "source":"generic",
    "section":"Section 20",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_20",
    "content":"For a more detailed account of how orphaned blocks affect Bitcoin security, further reading is recommended.",
    "source":"generic",
    "section":"Section 21",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_21",
    "content":"PHANTOM \u2014 GHOSTDAG In an Ideal World",
    "source":"generic",
    "section":"Section 22",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_22",
    "content":"Before diving into GHOSTDAG, it is instructive to consider a scenario where efficiency is not a concern. In this ideal world, we assume that any combinatorial calculations, even NP-complete ones, are feasible (while still assuming the existence of a hard-to-invert hash function, or else the entire PoW paradigm collapses). In such a world, how would one design a good ordering of the blocks?",
    "source":"generic",
    "section":"Section 23",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_23",
    "content":"The core idea is that the honest network blocks should be well connected. Since all honest miners communicate with each other and do not withhold blocks, their honest work should form a well-connected DAG. An attacker working on a side chain would appear disconnected from the main chain.",
    "source":"generic",
    "section":"Section 24",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_24",
    "content":"Translating this imprecise idea into an actual algorithm involves the mathematical notion of a k-cluster.",
    "source":"generic",
    "section":"Section 25",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_25",
    "content":"Given a block B, its past is the set of blocks reachable from B. Similarly, its future is the set of all blocks that can reach B (equivalently, the set of all blocks that have B in their past). The remaining blocks are called B\u2019s anticone.",
    "source":"generic",
    "section":"Section 26",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_26",
    "content":"A k-cluster in a DAG is a subset with the property that no block in the subset has an anticone larger than k (when only counting blocks within this subset). A k-cluster is maximal if there are no larger k-clusters.",
    "source":"generic",
    "section":"Section 27",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_27",
    "content":"With this concept in hand, we can describe the PHANTOM ordering almost formally:",
    "source":"generic",
    "section":"Section 28",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_28",
    "content":"1. Choose k such that most of the time, the honest network does not create more than k+1 parallel blocks.\n2. Find a maximal k-cluster (choose an arbitrary tie-breaking rule if there are several maximal k-clusters).\n3. Order the blocks in the maximal k-cluster via an arbitrary topological order with the property that a block outside the chosen k-cluster will appear as late as possible, either after all blocks inside the k-cluster or when the ordering reaches a block in the k-cluster that has this block in its past.",
    "source":"generic",
    "section":"Section 29",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_29",
    "content":"Some details are simplified here, such as what \u201cmost of the time\u201d means and how the occasional creation of more than k parallel blocks affects the security of the protocol. These details are thoroughly discussed in the relevant literature.",
    "source":"generic",
    "section":"Section 30",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_30",
    "content":"An interesting aspect of this approach is that it directly generalizes Nakamoto consensus. If we choose k=0 and discard blocks outside the maximal k-cluster, we are left with the longest chain.",
    "source":"generic",
    "section":"Section 31",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_31",
    "content":"From PHANTOM to GHOSTDAG",
    "source":"generic",
    "section":"Section 32",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_32",
    "content":"There are two issues with the PHANTOM protocol as presented:",
    "source":"generic",
    "section":"Section 33",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_33",
    "content":"1. It could not be implemented efficiently: finding a maximal k-cluster in a given DAG is NP-complete.\n2. It is not incremental: every time the DAG updates, the entire computation must restart, requiring storage of the entire DAG structure.",
    "source":"generic",
    "section":"Section 34",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_34",
    "content":"GHOSTDAG is a greedy variant of PHANTOM that addresses both issues. The idea is that the (now approximate) k-cluster is maintained incrementally. Each block has a number called its blue score, indicating how many blocks in its past are in the k-cluster. Given a particular block, its selected parent is the parent with the highest blue score. When a new block is created, it does not need to calculate the entire k-cluster; instead, it inherits most of the k-cluster from its selected parent, with the remainder chosen from the anticone of the selected parent. However, since this is a k-cluster, at most k elements from this set can be included.",
    "source":"generic",
    "section":"Section 35",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_35",
    "content":"This means that any block should only track at most k additional blocks: those in its blue past (the k-cluster from that block's perspective) but not in the blue past of its selected parent.",
    "source":"generic",
    "section":"Section 36",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_36",
    "content":"From this perspective, the generalization of Nakamoto consensus becomes clearer: choosing k=0, the blue score represents the length of the longest chain, and the selected chain (the chain starting from the block with the highest blue score and traversing the selected parents) is the original Nakamoto chain.",
    "source":"generic",
    "section":"Section 37",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_37",
    "content":"For a more detailed account of GHOSTDAG, further reading is recommended.",
    "source":"generic",
    "section":"Section 38",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_38",
    "content":"But Why Should GHOSTDAG Be Secure?",
    "source":"generic",
    "section":"Section 39",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_39",
    "content":"One might hope that the security of GHOSTDAG would be immediately implied by the security of Nakamoto consensus. However, additional steps are necessary.",
    "source":"generic",
    "section":"Section 40",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_40",
    "content":"Allowing parallel blocks and multiple parents creates a phenomenon called freeloading, which does not exist in Bitcoin. Freeloading occurs when an attacker allows their blocks to point to honest blocks to increase their own blue score. This raises the question of why their ability to do so does not imply that they could rearrange the block structure without creating as many blocks as the honest network.",
    "source":"generic",
    "section":"Section 41",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_41",
    "content":"Fortunately, the GHOSTDAG ordering has a special property known as the freeloading bound. It essentially means that an attacker wishing to revert arbitrarily old blocks cannot use honest blocks in a meaningful way. The number of blocks they could freeload from is limited by a constant (specifically, 4k blocks). This means that any attack seeking to change the ordering of arbitrarily old blocks will soon encounter a race where freeloading does not provide any advantage. With careful argumentation, this can be used to relate the security of GHOSTDAG to the security of Bitcoin.",
    "source":"generic",
    "section":"Section 42",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_42",
    "content":"Following this reasoning, we can prove the security property of GHOSTDAG: a computationally inferior attacker cannot revert arbitrarily old blocks, regardless of the ratio between block delay and block propagation time.",
    "source":"generic",
    "section":"Section 43",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_43",
    "content":"In summary, GHOSTDAG achieves the same security as Bitcoin but without constraints on the block rate, alleviating the blockchain scaling problem. It also offers nearly immediate confirmation times (in the order of seconds).",
    "source":"generic",
    "section":"Section 44",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_44",
    "content":"From GHOSTDAG To Kaspa \u2014 Concluding Remarks",
    "source":"generic",
    "section":"Section 45",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_45",
    "content":"GHOSTDAG is an intriguing protocol, but implementing it presents its own challenges. Describing Kaspa as a straightforward implementation of GHOSTDAG would be a significant understatement. In practice, many engineering and theoretical challenges had to be addressed before a usable implementation was feasible. For example, it is non-trivial to implement an efficient method to determine whether two blocks are in each other's anticone.",
    "source":"generic",
    "section":"Section 46",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_46",
    "content":"Additionally, Kaspa includes many other aspects not discussed in the original paper, such as a novel approach to difficulty adjustment, a sophisticated pruning mechanism, and future plans for infrastructure supporting layer two applications.",
    "source":"generic",
    "section":"Section 47",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_47",
    "content":"Kaspa still has a long way to go. For instance, it has not yet been stress-tested to determine how many transactions it can handle, although it has demonstrated support for 40 transactions per second, which exceeds the theoretical limit of Bitcoin and Ethereum combined, without difficulty.",
    "source":"generic",
    "section":"Section 48",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa \u2014 What are We Actually Doing Here?_48",
    "content":"The future remains uncertain, but there is a non-negligible chance that Kaspa could become the most resilient, robust, and fast PoW blockchain (or rather, blockDAG) in the world.",
    "source":"generic",
    "section":"Section 49",
    "url":null,
    "filename":"Kaspa \u2014 What are We Actually Doing Here?",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_0",
    "content":"Last Saturday (16\/12\/2023), Kaspa mining halted for about 20\u201330 minutes, and no new blocks were added to the BlockDAG due to a bug, which was subsequently fixed by the release of version v0.12.15. I delayed posting a post-mortem until 99% of the miners upgraded to the new version to prevent potential attackers from exploiting the situation. Now that this threshold has been reached (validated with Michael Sutton\u2019s tool), here is a detailed explanation of the bug and how it was resolved.",
    "source":"generic",
    "section":"Section 1",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_1",
    "content":"In February, an Italian group working on implementing atomic swaps on Kaspa noticed an issue: even after formulating a perfect atomic swap transaction, their transaction could not be accepted into the mempool. They reached out to me for assistance, and after some investigation, I discovered the reason was a peculiar bug.",
    "source":"generic",
    "section":"Section 2",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_2",
    "content":"When a transaction is received from RPC, it is converted to an internal Golang type called DomainTransaction, which is then used when processing the transaction in the mempool or within the consensus layer as part of a block. There was a small bug that copied the content of one field, called lockTime, to the value of another field, called gas.",
    "source":"generic",
    "section":"Section 3",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_3",
    "content":"The bug can be observed in a snippet from kaspad v0.12.14. The lockTime field is related to implementing contracts where funds are locked for a specified period (for more information, you can refer to Andreas Antonopoulos\u2019 explanation). It is utilized by atomic swaps. The gas field is reserved for future integration of subnetworks in Kaspa, and since subnetworks support is not currently enabled, any valid transaction must set it to 0. For a typical transaction, the lockTime field is set to 0, so the bug simply copied this 0 value to the gas field, allowing the transaction to remain valid. However, in the case of atomic swap transactions, the lockTime field is set to a non-zero value, which is copied to the gas field, rendering the transaction invalid.",
    "source":"generic",
    "section":"Section 4",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_4",
    "content":"The solution was straightforward, but I wanted to wait for more feedback from the Italian group regarding my solution before publishing it. At the time, I believed the fix was not urgent since the function of locking funds was not available to non-developers. If a developer attempted to use that function, the worst that could happen was that their transaction would be rejected.",
    "source":"generic",
    "section":"Section 5",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_5",
    "content":"I was mistaken. The bug fix was overlooked, and on December 16th, the consequences materialized. A new member of the Rust team, Maxim Biryukov, began experimenting with HTLC transactions. In one of his tests, he used a transaction with lockTime set to 1. To clarify, it was entirely acceptable for Maxim to run this test, as such transactions were not anticipated to be problematic. Since Maxim used a Rusty-Kaspa node that was free of this bug, his transaction was accepted into his mempool without issue. This transaction, referred to as mtx (denoting \"Maxim Transaction\"), was then broadcast to the rest of the network in the P2P layer. The bug did not appear in the P2P code, so all Golang nodes accepted the transaction into their mempool without any problems.",
    "source":"generic",
    "section":"Section 6",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_6",
    "content":"The tricky part arose when any miner found a block that included mtx (since it had not yet been mined). The miner then sent the block to their Golang node via RPC for propagation to the rest of the network. During the conversion of the RPC block transactions to DomainTransactions, the bug was triggered: the conversion code took mtx, and since mtx.lockTime was set to 1, it also set mtx.gas to 1. This change in the block transactions resulted in an invalid Merkle root (the part of the block header that commits to the block content), as it was built before mtx was altered. Consequently, no blocks were mined, and mtx remained in everyone\u2019s mempool, leading to each mined block being invalid.",
    "source":"generic",
    "section":"Section 7",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_7",
    "content":"When mining pools reported receiving an ErrBadMerkleRoot error when submitting blocks, and I learned about Maxim\u2019s tests, I connected the dots and released a new version with the fix.",
    "source":"generic",
    "section":"Section 8",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_8",
    "content":"To summarize:",
    "source":"generic",
    "section":"Section 9",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_9",
    "content":"1. Maxim creates mtx and sends it to his Rusty-Kaspa node (where mtx.lockTime=1 and mtx.gas=0).\n2. Maxim\u2019s node propagates mtx to the rest of the network, where it reaches the miners' nodes (still, mtx.lockTime=1 and mtx.gas=0).\n3. When a miner solves a block b, they include mtx in it and send it to their Golang node via RPC.\n4. When converting the RPC transactions of b to DomainTransactions, the miner node sets mtx.gas=mtx.lockTime=1. When the block is validated, it throws an ErrBadMerkleRoot error, and the block is rejected.\n5. This results in no mining until the fix is released.",
    "source":"generic",
    "section":"Section 10",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_10",
    "content":"In conclusion, this case teaches us several lessons:",
    "source":"generic",
    "section":"Section 11",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_11",
    "content":"Even when the consensus layer is well tested with near 100% coverage, a bug in communication between components (in this case, the bridge between the RPC layer and the consensus layer) can lead to significant issues. To prevent this, more integration tests involving multiple components should be developed.",
    "source":"generic",
    "section":"Section 12",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Kaspa 20 minute BlockDAG freeze post-mortem_12",
    "content":"Even with perfect testing conventions, no system is immune to bugs, and we need to consider better ways to handle them when they occur. For example, I discussed this case with Yonatan Sompolinsky, and we are considering implementing a fallback mechanism that will mine empty blocks in the event of such bugs, helping to secure the network during extreme situations. More on that will follow in the future.",
    "source":"generic",
    "section":"Section 13",
    "url":null,
    "filename":"Kaspa 20 minute BlockDAG freeze post-mortem",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_0",
    "content":"In recent weeks, a supposed counterargument to the usability of Kaspa has been circulating, claiming that high block rates limit the functionality of smart contracts. The argument suggests that increased block throughput implies more processing, making it unfeasible for nodes to handle complex functionalities. I have never taken this argument seriously, as it lacks substantiation. However, it was brought up by Kadena\u2019s director of engineering, Doug Beardsley, during one of their periodic Office Hours Twitter spaces.",
    "source":"generic",
    "section":"Section 1",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_1",
    "content":"While I appreciate Doug's contribution to the discussion, I disagree with much of what he said. The purpose of this rebuttal is to present my objections in detail. This is not intended as a confrontation, but rather as an explanation to our community and users regarding why this criticism is not constructive.",
    "source":"generic",
    "section":"Section 2",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_2",
    "content":"I have made every effort to make this post self-contained, but readers are welcome to listen to the recording, starting from about 16:00. A technical note: the order in which I address the points is not the order they were originally made in the talk; I present them in decreasing order of annoyance.",
    "source":"generic",
    "section":"Section 3",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_3",
    "content":"The argument that irked me the most is the distinction between \u201ca smart-contract blockchain\u201d and \u201ca cryptocurrency.\u201d The implicit assumption here is that a blockchain must make a choice between the two. This is patently false: any network can allocate some of its throughput for smart contracts and the rest for simple transactions. Downscaling smart contract processing speed does not necessitate downscaling the entire network.",
    "source":"generic",
    "section":"Section 4",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_4",
    "content":"One argument made in the space is that \u201c30-second block times are a nice sweet spot between too fast and too slow.\u201d For the sake of discussion, let us assume this is correct. If the \u201cbest\u201d block delay for processing transactions is indeed 30 seconds, what prevents any technology capable of higher throughput from designating every 30th block as a \u201csmart-contract block\u201d and the remaining 29 blocks as \u201ctransaction blocks\u201d? This way, we can enjoy the best of both worlds: our cryptocurrency remains fast while our smart contracts operate at optimal speed. The only rational reason I see for any technology to avoid this path is if they cannot support shorter confirmation times.",
    "source":"generic",
    "section":"Section 5",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_5",
    "content":"The second problematic argument is the \u201csweet spot\u201d argument regarding the 30-second block time as the \u201ccorrect\u201d trade-off between speed and functionality. The claim is that we cannot make block times arbitrarily slow because we cannot predict how long they would take to process when they carry arbitrary code, necessitating a large margin of error. This argument annoys me because it presents the 30-second confirmation time as a choice rather than a limitation of the system. All systems have limitations, and great engineers find ways to work around them. However, presenting a limitation imposed by the protocol as conveniently optimal is misleading. Why bother upscaling the network if we can simply declare Bitcoin's original 10-minute block delay as a \u201cnice sweet spot\u201d?",
    "source":"generic",
    "section":"Section 6",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_6",
    "content":"Let us illustrate this with a thought experiment: suppose someone at Kadena develops a solution that allows them to reduce confirmation times to a millisecond. They could either try to make smart contracts work as fast as possible without sacrificing functionality or say, \u201c30 seconds is a nice trade-off, no reason to change that.\u201d Most would agree that the first option is the reasonable one. Why limit yourself to 30 seconds when you might achieve better results? While estimating the computational costs of arbitrary code is challenging, \u201c30 seconds\u201d is not a magic number, and quicker response times may be attainable without compromising functionality or security.",
    "source":"generic",
    "section":"Section 7",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_7",
    "content":"Kaspa\u2019s current block rate is 1 block per second (bps). After the Rust rewrite is complete, we intend to increase it to 10 bps and gradually raise it to 32 bps, with aspirations of reaching 100 bps, as noted by Dr. Sompolinsky. Could we process 10 blocks of smart contracts per second? Probably not. Could we process 1 block of smart contracts per second? Likely yes. Could we process 1 block of smart contracts every five seconds? Almost definitely. This is without even considering the possibility of applying roll-ups, which defer most of the processing overhead off-chain.",
    "source":"generic",
    "section":"Section 8",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_8",
    "content":"The key point is that processing power is the only limitation, whereas in other technologies, the limitation is imposed by the protocol. This positions us uniquely as the first pure Proof of Work (PoW) blockchain capable of testing how fast smart contracts can potentially operate.",
    "source":"generic",
    "section":"Section 9",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_9",
    "content":"The discourse has become so focused on the consequences of fast confirmation times that it has neglected the equally important consequences of slow confirmation times. While there are no convincing arguments against fast confirmations, it is easy to explain why slow confirmations are a handicap.",
    "source":"generic",
    "section":"Section 10",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_10",
    "content":"Consider a hypothetical example: a user of WhateverCoin (WC) creates a smart contract that awards 10,000 WC based on sequential messages. The first user to post \u201cone\u201d receives one WC, then \u201ctwo,\u201d and so on. Processing this contract requires waiting for confirmation ten thousand times, as it cannot award the user posting \u201cforty-two\u201d before confirming \u201cforty-one,\u201d which must wait for \u201cforty,\u201d and so forth. This example, while simplistic, illustrates the sequential behavior that can occur in many applications, such as decentralized exchanges.",
    "source":"generic",
    "section":"Section 11",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_11",
    "content":"Another argument that raised my eyebrows was the comparison between confirmation times and stock exchange closures. The claim was that minute-long confirmation times are superior to the days-long confirmations of stock markets and credit card companies, and that stock exchanges use \u201cdecades-old techniques\u201d to create the illusion of fast confirmations.",
    "source":"generic",
    "section":"Section 12",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_12",
    "content":"As far as I know, traditional finance systems rely on trust, centralization, and liquidity. When you buy stock on an exchange, the platform aggregates transactions throughout the day. This is possible because the platform centralizes many transactions, users trust the platform to include their transactions before the stock exchange closes, and the platform has liquidity to lend to users for transactions that have not yet been finalized.",
    "source":"generic",
    "section":"Section 13",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_13",
    "content":"Removing centralization and trust from the equation is not as trivial as it may seem. If it were possible, we would not need blockchains at all. If Kadena has a solution that allows for safely and trustlessly \u201cconfirming\u201d a transaction that is not actually confirmed yet, it must involve significant ingenuity. To me, it sounds impossible, as there is no centralized third party with the liquidity to cover discrepancies in case of a false positive. I see no difference between creating the illusion of a fast confirmation and actually reducing confirmation times unless there is someone to cover the costs when the estimation is wrong.",
    "source":"generic",
    "section":"Section 14",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_14",
    "content":"The Robinhood example illustrates the dangers of relying on an untrustworthy service provider. It exemplifies why actual control is desirable. Current platforms do not reduce confirmation times because they do not need to; their reputation and high liquidity solve the problem more easily.",
    "source":"generic",
    "section":"Section 15",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  },
  {
    "id":"generic_Are High Block Rates Limiting Smart Contracts? (Spoiler: No)_15",
    "content":"In conclusion, I remain skeptical of the assertion that a 100 ms block time is not feasible. We will see.",
    "source":"generic",
    "section":"Section 16",
    "url":null,
    "filename":"Are High Block Rates Limiting Smart Contracts? (Spoiler: No)",
    "chunk_type":null,
    "word_count":null,
    "pdf_pages":null,
    "extraction_method":null,
    "pdf_path":null
  }
]